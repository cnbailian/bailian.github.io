{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","path":"static/css/style.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","path":"static/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","path":"static/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","path":"static/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","path":"static/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","path":"static/images/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","path":"static/images/favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.png","path":"static/images/gravatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","path":"static/js/meizi.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-meizi/.gitignore","hash":"5163f3d9e05f8be9025633bac924c47c777b41e6","modified":1560153108780},{"_id":"themes/hexo-theme-meizi/README.md","hash":"bd5f1ef099ca4f621c29f319165c6470b0cb7014","modified":1560153108781},{"_id":"themes/hexo-theme-meizi/_config.yml","hash":"cf77dce09751c29634a6a4bd34537fc1484a1d1f","modified":1595464318493},{"_id":"themes/hexo-theme-meizi/bower.json","hash":"dedf03e9e405d4be38cebaa753fe23158e32b066","modified":1560153108781},{"_id":"themes/hexo-theme-meizi/gulpfile.js","hash":"805dbc9e619c0e4be563a8a32b39060fb7475655","modified":1560153108781},{"_id":"themes/hexo-theme-meizi/package.json","hash":"4a88f9f1450747b0b1c13d1f2500ef63a2383de8","modified":1560153108787},{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1583811014788},{"_id":"themes/hexo-theme-meizi/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1560153108775},{"_id":"themes/hexo-theme-meizi/.git/config","hash":"7b81e6fbe592203925fa7afb3503851de853853e","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1560153105558},{"_id":"themes/hexo-theme-meizi/.git/index","hash":"7285a6064386b8b3a2fef119630b78626d376a79","modified":1560155345505},{"_id":"themes/hexo-theme-meizi/.git/packed-refs","hash":"972281fc35737309bbcc9b09cc6fbc570deaa255","modified":1560153108773},{"_id":"themes/hexo-theme-meizi/languages/zh-cn.yml","hash":"658a3c2d7c3a76a4658ea5b097acdc935fc1f526","modified":1595464312745},{"_id":"themes/hexo-theme-meizi/layout/about.ejs","hash":"4323c21b553780269f2cac5d6e5a8f33d6243290","modified":1560153108785},{"_id":"themes/hexo-theme-meizi/layout/all-archives.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/index.ejs","hash":"b0d62a2f93de7917e67556f30dee33214d9b7d74","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/links.ejs","hash":"1514d633dae3c5c5a76344afeaa0fbdf154c025c","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/tags.ejs","hash":"17a1f47a1b54624645fcb182d4e275512e918386","modified":1560153108786},{"_id":"source/_posts/2019-年终总结.dat","hash":"2baf56659831dd14855bd461c0647cd5e6d0dd5d","modified":1595464158286},{"_id":"source/_posts/API-security.md","hash":"17cdb241b10da48c3b70d93a526b2ccf27908ec4","modified":1595464158287},{"_id":"source/_posts/CleanArchitecture.md","hash":"fe87447b23dc6f74246066cfab709a5b381e6e91","modified":1595464848165},{"_id":"source/_posts/Concurrency-and-scheduler-of-Go.md","hash":"b09d78defbb8ac4e28dcc38997f41ee9b73ff480","modified":1595464158289},{"_id":"source/_posts/Dynamic-Provisioning.md","hash":"1e9292fd918c91e0cad1276563672d64c9e68e14","modified":1595464791843},{"_id":"source/_posts/JSON Schema.md","hash":"a6ad8e3a7db409ec5eb954755da2d2467fd603b8","modified":1595464158292},{"_id":"source/_posts/JWT-and-OAuth2.0.md","hash":"b7341c777d3add7255c09bde622f722a2cee08eb","modified":1595464158293},{"_id":"source/_posts/KubernetesClusterAutoscaler.md","hash":"5505bcaba966a7e078551dd51aa5c75338ab3e93","modified":1595464793306},{"_id":"source/_posts/OAuth2.0-and-oauth2-server-package.md","hash":"d9ae98db0bf3d611ca4caafbc3f14afb372238dc","modified":1595464158295},{"_id":"source/_posts/RESTful-API-Practice.md","hash":"e76bde82a42f3ba2bde6ef0f8ce19028742a35fe","modified":1595464158296},{"_id":"source/_posts/RESTful-cache.md","hash":"0a53f8bf00989366ff4e04a16c4499490ec4235f","modified":1595464158298},{"_id":"source/_posts/Vue-learning-route.md","hash":"b752d958b1d9e41c42643e48c7eeb91afe452793","modified":1595464158299},{"_id":"source/_posts/chromeBox 大纲.dat","hash":"26d44ea5427717e9a087f0fb0e1c761b9ce8ce9a","modified":1585905305832},{"_id":"source/_posts/hypertext-driven.md","hash":"3af33d64b3af86a6f94387ef67afb323e67c60e0","modified":1595464158300},{"_id":"source/_posts/session-and-JWT.md","hash":"1c103327aae9148db4b1984f43f32f6653ac800b","modified":1595464158300},{"_id":"source/_posts/tpshop代码审计--续.dat","hash":"a364ec4317bbbf9bd2e355726344e0d9335de13c","modified":1595464158301},{"_id":"source/_posts/tpshop代码审计.dat","hash":"c6b836d318b4d08b294f94135262b27946d7959b","modified":1595464158301},{"_id":"source/_posts/记一次 Traefik 无法代理 MySQL 问题.md","hash":"4ccefce87fc1fe06d66f05cc53c494cd9461c9e3","modified":1595464158301},{"_id":"source/about/index.md","hash":"23964c39a2d0c5c4cfb02a97a8dc066f0fc9ad46","modified":1595464158302},{"_id":"source/archive/index.md","hash":"fc18302dc4b2a347ac7969bab93eda360f3b7bd3","modified":1585905305835},{"_id":"source/links/index.md","hash":"49e30f19d6276ac9f7ddd5956d05c854ae37d99a","modified":1585905305836},{"_id":"source/resume/index.md","hash":"9a0380d790fd067f912891b34951327e7ac0fad7","modified":1595557237526},{"_id":"source/tags/index.md","hash":"35867ca3284afb0c225bd922f41386fd8b21d8e8","modified":1585905305837},{"_id":"themes/hexo-theme-meizi/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1560153105560},{"_id":"themes/hexo-theme-meizi/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1560153105559},{"_id":"themes/hexo-theme-meizi/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1560153105560},{"_id":"themes/hexo-theme-meizi/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1560153105560},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1560153105559},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1560153105562},{"_id":"themes/hexo-theme-meizi/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1560153105557},{"_id":"themes/hexo-theme-meizi/.git/logs/HEAD","hash":"73566d03be4f63179ecae0a3123f0f80fc3fba6f","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/layout/_partial/about.ejs","hash":"a08ffc6ab76217d05facb9cc2b4fcc7ae5148a3e","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/layout/_partial/archive.ejs","hash":"8126fd297918132825fe3110f5ebb0efe2b9d024","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/layout/_partial/index.ejs","hash":"3d0bd9cc0b5f1660d74c63166c62155e76c92102","modified":1560155265716},{"_id":"themes/hexo-theme-meizi/layout/_partial/links.ejs","hash":"f70a0579a35f2815b919080ae643574e7156e59d","modified":1560153108785},{"_id":"themes/hexo-theme-meizi/layout/_partial/post.ejs","hash":"26c6d0915c9164a4eafe8118898cc4bdd120fec9","modified":1560153219752},{"_id":"themes/hexo-theme-meizi/layout/_partial/tags.ejs","hash":"b5121bf77d8da66cdb18c1d6269854951fd1c0e5","modified":1560153108785},{"_id":"themes/hexo-theme-meizi/scripts/helpers/func.js","hash":"9deec4d350f6baffae85f44c91097139c3fefe46","modified":1560153108787},{"_id":"themes/hexo-theme-meizi/source/_css/style.scss","hash":"3b7fd5a263afc20c60557326827c5bd0bfc75de8","modified":1560153108790},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1560153108791},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1560153108791},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1560153108792},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1560153108792},{"_id":"themes/hexo-theme-meizi/source/_images/.DS_Store","hash":"fdb1ed4f0bead0080922ca8622f7e774458c8140","modified":1572484707204},{"_id":"themes/hexo-theme-meizi/source/_images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1560153108792},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647768474},{"_id":"themes/hexo-theme-meizi/source/_images/gravatar.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647777925},{"_id":"themes/hexo-theme-meizi/source/_js/meizi.js","hash":"e8e2709c6202af825f28a1fc413922c7297dd160","modified":1560153108793},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.idx","hash":"ddc8d023560997562e71b97d44a538fb0ed1e1f5","modified":1560153108762},{"_id":"themes/hexo-theme-meizi/.git/refs/heads/master","hash":"9e0459116ecb93cf28843d634c4f246e721004fd","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/disqus.ejs","hash":"e6658fa854c46077b797289599fb1158a05d47dd","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/duoshuo.ejs","hash":"fa58511057fb387b59771193b1d7eebfe9273c59","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/footer.ejs","hash":"fa6d3667d0bebd00475fd67c1426cd30c80e8ed3","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/head.ejs","hash":"7a463f03d7fa36e44750f63ccf51ecf52bfde3c3","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/header.ejs","hash":"f27ad620e4d3b036ede31a5068066581e0d35532","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/pagination.ejs","hash":"244782d6b1fdc6bd71517709a0407272a33c7919","modified":1560153108784},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/scripts.ejs","hash":"c3138803ca03ea4b94aa620b626f1d9cfe477bb2","modified":1560153108784},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/sidebar.ejs","hash":"4ecc51d5c94ab12dab9c8516bb8bfcd720482fa1","modified":1560153108784},{"_id":"themes/hexo-theme-meizi/source/_css/include/_core.scss","hash":"cc72e8ef196ada45f663ab94f0b5862bf0f60f43","modified":1560153108787},{"_id":"themes/hexo-theme-meizi/source/_css/include/_header.scss","hash":"30643e4b7b2fc920c3474ab79936afd619e521ac","modified":1560153108788},{"_id":"themes/hexo-theme-meizi/source/_css/include/_iconfont.scss","hash":"7de2c0a7dc1ae4f16eb2da1a4fdddd9a0a4acd74","modified":1560153108788},{"_id":"themes/hexo-theme-meizi/source/_css/include/_layout.scss","hash":"313456db88a9ffef298bce6f5041456b98f3f2a6","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/include/_main.scss","hash":"f89d6f8c0225f60d958deb88c239ce2ba97528bb","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/include/_markdown.scss","hash":"2ee28dada07096cf1537652e3105d8e9216c88d3","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/include/_sidebar.scss","hash":"d9a9cd8d52ed2d8e3b23074f1c1e7f9b179eaaf4","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_query.scss","hash":"b0c46b67d87e7548ccf0704bb43363f2cc6278bd","modified":1560153108790},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_variables.scss","hash":"38138cafcc3b702b032bb576fa46815b2f0cff3f","modified":1560153108790},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1560153108793},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1560153108794},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1560153108794},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1560153108794},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1560153108795},{"_id":"themes/hexo-theme-meizi/source/static/images/.DS_Store","hash":"fed247035d4674543b77b7f34dcf1d214dc0d729","modified":1572484707205},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1560153108795},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647812337},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647817605},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1560153108796},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/heads/master","hash":"73566d03be4f63179ecae0a3123f0f80fc3fba6f","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1560153108775},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/remotes/origin/HEAD","hash":"73566d03be4f63179ecae0a3123f0f80fc3fba6f","modified":1560153108775},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.pack","hash":"deb8601f46513acdf5c099767f143977c23340d2","modified":1560153108760},{"_id":"public/atom.xml","hash":"fcb91a54dd4388da97cd5f10ead5a97ed1eb8834","modified":1595465764562},{"_id":"public/about/index.html","hash":"449c363a79e53b83094c1da95fbd568729bbaf93","modified":1595465764575},{"_id":"public/archive/index.html","hash":"207a9871ee689f04e95de5729b9cd58fe550bf5d","modified":1595465764575},{"_id":"public/links/index.html","hash":"3a9307c5ed0c77a6930eb3a53d2ae72b2447ca42","modified":1595465764575},{"_id":"public/resume/index.html","hash":"d091124c73a6e8e14e81ac3a9d056118ab580b13","modified":1595557258598},{"_id":"public/tags/index.html","hash":"b056eca3f731cfc348065fc095b0a040a1926ac2","modified":1595465764575},{"_id":"public/2017/08/session-and-JWT/index.html","hash":"61ecaafd811ba86dd4bebf03b26083a562dc54db","modified":1595465764576},{"_id":"public/2017/04/hypertext-driven/index.html","hash":"b758ef9719052e9078e9d0ea4798612b72edbd9b","modified":1595465764576},{"_id":"public/2016/09/RESTful-cache/index.html","hash":"000034289f20cd6c5e89bacd42464311ccf56157","modified":1595465764576},{"_id":"public/2016/09/JWT-and-OAuth2.0/index.html","hash":"26023d62a0c4539667294f021952cb2c9d0218d1","modified":1595465764576},{"_id":"public/2016/07/API-security/index.html","hash":"e0c4e6c0ea374e60a9377e8f2635af3857c413c3","modified":1595465764576},{"_id":"public/archives/page/2/index.html","hash":"df413bc7f9dd2f820bfa2c0343630723e020dcf4","modified":1595465764576},{"_id":"public/archives/2016/index.html","hash":"3dbaa0c4feeb6559a02e8b65af78ce85b40566a5","modified":1595465764576},{"_id":"public/archives/2016/07/index.html","hash":"46e82407bfad103bfc38be7887e76524a46498db","modified":1595465764576},{"_id":"public/archives/2016/09/index.html","hash":"a03664c17b02534b6cc5bc1caf3bb72fbdb9a5a8","modified":1595465764576},{"_id":"public/archives/2016/10/index.html","hash":"1ce6cd329d3e0bb82a656b623bdbe2af943affd7","modified":1595465764576},{"_id":"public/archives/2017/index.html","hash":"d1ce35e9da2d72cbc3d6f793859fddfecef6d5d1","modified":1595465764576},{"_id":"public/archives/2017/04/index.html","hash":"d8f4a151495187578a3d4e1541b4b90148d063a9","modified":1595465764576},{"_id":"public/archives/2017/08/index.html","hash":"49055cbd36bd2aba483fe61fdae4b9198a930f02","modified":1595465764576},{"_id":"public/archives/2018/index.html","hash":"75c805872faa749f89a642a8404be5db68cebb69","modified":1595465764576},{"_id":"public/archives/2018/11/index.html","hash":"8d1453783db0f9fb4568f936d71a349e2750e25e","modified":1595465764576},{"_id":"public/archives/2018/12/index.html","hash":"84df96e93aee16bc4a0e924eb95d4d5089cd11b7","modified":1595465764576},{"_id":"public/archives/2019/index.html","hash":"55758d9c80512bd3bc34d87d8ddbced816248b7f","modified":1595465764577},{"_id":"public/archives/2019/03/index.html","hash":"705164aac113ba2c9de083553700032e6224770b","modified":1595465764577},{"_id":"public/archives/2019/04/index.html","hash":"e3990c468d7712ff65ac89cdf9ceddf1c1d1485f","modified":1595465764577},{"_id":"public/archives/2020/index.html","hash":"549e38a845de130da06d61e790a60fe7d15e8b00","modified":1595465764577},{"_id":"public/archives/2020/03/index.html","hash":"9138b16d7c5b4bebf46c96e7a613566589d263cb","modified":1595465764577},{"_id":"public/archives/2020/04/index.html","hash":"1cd6fc28d9609284a2de24950fc648d26d0e7012","modified":1595465764577},{"_id":"public/page/2/index.html","hash":"df413bc7f9dd2f820bfa2c0343630723e020dcf4","modified":1595465764577},{"_id":"public/2020/04/记一次 Traefik 无法代理 MySQL 问题/index.html","hash":"de712e0c0949f1399d447067ef1b015630224e38","modified":1595465764577},{"_id":"public/2020/03/KubernetesClusterAutoscaler/index.html","hash":"bdda0a748870390ddb223066f9c16a0354503ee3","modified":1595465764577},{"_id":"public/2020/03/CleanArchitecture/index.html","hash":"33889cce27c94d00e5b24e9125350dcb80dfc82e","modified":1595465764577},{"_id":"public/2020/03/Dynamic-Provisioning/index.html","hash":"1c9ace73b9f1d5865cd28fda58ca29b7f10a6802","modified":1595465764577},{"_id":"public/2019/04/Vue-learning-route/index.html","hash":"0b162c5889ad46a6e552e414268cb5498a14c3ec","modified":1595465764577},{"_id":"public/2019/03/Concurrency-and-scheduler-of-Go/index.html","hash":"3b37f59a92a4f365fe4da957676fb8126e69d382","modified":1595465764577},{"_id":"public/2018/12/JSON Schema/index.html","hash":"55d96139ff12988b4e59c66425683621f0d405e8","modified":1595465764577},{"_id":"public/2018/11/OAuth2.0-and-oauth2-server-package/index.html","hash":"c311c9b857b016f42693c4fcb6a70c307c68b426","modified":1595465764578},{"_id":"public/2016/10/RESTful-API-Practice/index.html","hash":"a31ebdc7ba42bc09b1f62ef12e8bedcef09a0991","modified":1595465764578},{"_id":"public/archives/index.html","hash":"c5153f71dfbc06049ae0f73977264c2f70ce8645","modified":1595465764578},{"_id":"public/index.html","hash":"96fcd970c6933cf637b208f53ad64ef62c10c8e9","modified":1595465764578},{"_id":"public/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1595465764581},{"_id":"public/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1595465764581},{"_id":"public/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1595465764581},{"_id":"public/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1595465764581},{"_id":"public/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1595465764581},{"_id":"public/static/images/favicon.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1595465764581},{"_id":"public/static/images/gravatar.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1595465764581},{"_id":"public/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1595465764587},{"_id":"public/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1595465764587}],"Category":[],"Data":[],"Page":[{"title":"关于我","layout":"about","_content":"\n<!-- 这里写你的简介 -->\n\n全栈程序员~~(伪)~~，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、REST 规范，还接触过 Flutter。\n\n目前正向着技术专家与软件架构方向前进。","source":"about/index.md","raw":"title: \"关于我\"\nlayout: \"about\"\n---\n\n<!-- 这里写你的简介 -->\n\n全栈程序员~~(伪)~~，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、REST 规范，还接触过 Flutter。\n\n目前正向着技术专家与软件架构方向前进。","date":"2020-07-23T00:29:18.302Z","updated":"2020-07-23T00:29:18.302Z","path":"about/index.html","comments":1,"_id":"ckcy34e9s0001cyze0qlup7sy","content":"<!-- 这里写你的简介 -->\n<p>全栈程序员<del>(伪)</del>，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、REST 规范，还接触过 Flutter。</p>\n<p>目前正向着技术专家与软件架构方向前进。</p>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的简介 -->\n<p>全栈程序员<del>(伪)</del>，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、REST 规范，还接触过 Flutter。</p>\n<p>目前正向着技术专家与软件架构方向前进。</p>\n"},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"title: \"归档\"\nlayout: \"all-archives\"\n---","date":"2020-04-03T09:15:05.835Z","updated":"2020-04-03T09:15:05.835Z","path":"archive/index.html","comments":1,"_id":"ckcy34e9v0003cyze9nztrfjt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"友情链接","layout":"links","_content":"\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","source":"links/index.md","raw":"title: \"友情链接\"\nlayout: \"links\"\n---\n\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","date":"2020-04-03T09:15:05.836Z","updated":"2020-04-03T09:15:05.836Z","path":"links/index.html","comments":1,"_id":"ckcy34e9w0005cyzehaylthhe","content":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n"},{"title":"简历","layout":"resume","_content":"\n### 个人信息\n\n* 姓名：白联\n* 年龄：25\n* 工作经验：4年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 工作状态：在职\n\n### 联系方式\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n### 工作经历\n\n* 沈阳xx数据科技有限公司 （2018-10 ~）\n  * 容器化 PAAS 平台项目\n    * 一个 Kubernetes 应用部署引擎，适用于任何标准版本的 Kubernetes 集群。通过 Kubernetes CRD 或 CLI 进行操作，用户可以将应用部署到 Kubernetes 中，并且有 CI/CD、HTTPS、Routing、Monitoring、Alerting、Autoscaling、Webhook 等功能。\n    * 我负责其中大部分的产品功能设计、软件架构设计及编码工作。\n    * 用到的技术点：设计 Kubernetes CRD，并实现其控制器，通过开源组件 Tekton 等组合实现 CI/CD 功能，通过 Prometheus 等实现监控报警模块。通过 Traefik 作为集群 Ingress，实现 HTTPS、Routing 等部分功能。\n  * Kubernetes 集群管理工具\n    * 可基于公有云创建 Kubernetes 集群，并且进行维护管理集群的基础设施。\n    * 用到的技术点：对各类公有云接口进行统一接口设计，调度云资源实现 Kubernetes 集群的基础管理。于 Kubernetes ClusterAutoscaler 组件中完成自己的实例组接口，实现对集群节点的自动扩容等。\n\n### 技术能力\n\n* 熟练使用 Go 语言；阅读过部分源码，了解 gin 框架。\n* 熟练使用 PHP 语言；熟悉各类框架：Laravel、Slim、CI等，阅读过部分框架源码。\n* 熟悉领域驱动设计；熟悉领域模型构建方法，可与领域专家合作设计出符合领域模型的软件架构。\n* 熟悉 REST 设计风格及 HTTP 协议；可设计出符合 RESTful 风格的 web 接口。\n* 熟悉了解部分云原生软件：Docker、Kubernetes、Prometheus 等。\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解其他语言：Python、dart(flutter)。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n* 熟悉 Git；阅读过《Pro Git》知晓基础原理。\n\n### 技术文章\n\n* 《Kubernetes Cluster Autoscaler》 https://cnbailian.github.io/2020/03/KubernetesClusterAutoscaler/\n* 《Go 的并发性与调度器》https://cnbailian.github.io/2019/03/Concurrency-and-scheduler-of-Go/\n* 《RESTful API 实践》 https://cnbailian.github.io/2016/10/RESTful-API-Practice/\n\n### 技术演讲\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n### 致谢\n\n感谢您的阅读，期待有机会能与您共事。\n","source":"resume/index.md","raw":"title: \"简历\"\nlayout: \"resume\"\n---\n\n### 个人信息\n\n* 姓名：白联\n* 年龄：25\n* 工作经验：4年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 工作状态：在职\n\n### 联系方式\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n### 工作经历\n\n* 沈阳xx数据科技有限公司 （2018-10 ~）\n  * 容器化 PAAS 平台项目\n    * 一个 Kubernetes 应用部署引擎，适用于任何标准版本的 Kubernetes 集群。通过 Kubernetes CRD 或 CLI 进行操作，用户可以将应用部署到 Kubernetes 中，并且有 CI/CD、HTTPS、Routing、Monitoring、Alerting、Autoscaling、Webhook 等功能。\n    * 我负责其中大部分的产品功能设计、软件架构设计及编码工作。\n    * 用到的技术点：设计 Kubernetes CRD，并实现其控制器，通过开源组件 Tekton 等组合实现 CI/CD 功能，通过 Prometheus 等实现监控报警模块。通过 Traefik 作为集群 Ingress，实现 HTTPS、Routing 等部分功能。\n  * Kubernetes 集群管理工具\n    * 可基于公有云创建 Kubernetes 集群，并且进行维护管理集群的基础设施。\n    * 用到的技术点：对各类公有云接口进行统一接口设计，调度云资源实现 Kubernetes 集群的基础管理。于 Kubernetes ClusterAutoscaler 组件中完成自己的实例组接口，实现对集群节点的自动扩容等。\n\n### 技术能力\n\n* 熟练使用 Go 语言；阅读过部分源码，了解 gin 框架。\n* 熟练使用 PHP 语言；熟悉各类框架：Laravel、Slim、CI等，阅读过部分框架源码。\n* 熟悉领域驱动设计；熟悉领域模型构建方法，可与领域专家合作设计出符合领域模型的软件架构。\n* 熟悉 REST 设计风格及 HTTP 协议；可设计出符合 RESTful 风格的 web 接口。\n* 熟悉了解部分云原生软件：Docker、Kubernetes、Prometheus 等。\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解其他语言：Python、dart(flutter)。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n* 熟悉 Git；阅读过《Pro Git》知晓基础原理。\n\n### 技术文章\n\n* 《Kubernetes Cluster Autoscaler》 https://cnbailian.github.io/2020/03/KubernetesClusterAutoscaler/\n* 《Go 的并发性与调度器》https://cnbailian.github.io/2019/03/Concurrency-and-scheduler-of-Go/\n* 《RESTful API 实践》 https://cnbailian.github.io/2016/10/RESTful-API-Practice/\n\n### 技术演讲\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n### 致谢\n\n感谢您的阅读，期待有机会能与您共事。\n","date":"2020-07-24T02:20:37.526Z","updated":"2020-07-24T02:20:37.526Z","path":"resume/index.html","_id":"ckcy34e9y0007cyzehw973xsd","comments":1,"content":"<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3><ul>\n<li>姓名：白联</li>\n<li>年龄：25</li>\n<li>工作经验：4年</li>\n<li>技术博客：<a href=\"https://cnbailian.github.io/\">https://cnbailian.github.io/</a></li>\n<li>GitHub：<a href=\"https://github.com/cnbailian\" target=\"_blank\" rel=\"noopener\">https://github.com/cnbailian</a></li>\n<li>工作状态：在职</li>\n</ul>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>手机号：15142556834</li>\n<li>邮箱：captainbailian@gmail.com</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ul>\n<li>沈阳xx数据科技有限公司 （2018-10 ~）<ul>\n<li>容器化 PAAS 平台项目<ul>\n<li>一个 Kubernetes 应用部署引擎，适用于任何标准版本的 Kubernetes 集群。通过 Kubernetes CRD 或 CLI 进行操作，用户可以将应用部署到 Kubernetes 中，并且有 CI/CD、HTTPS、Routing、Monitoring、Alerting、Autoscaling、Webhook 等功能。</li>\n<li>我负责其中大部分的产品功能设计、软件架构设计及编码工作。</li>\n<li>用到的技术点：设计 Kubernetes CRD，并实现其控制器，通过开源组件 Tekton 等组合实现 CI/CD 功能，通过 Prometheus 等实现监控报警模块。通过 Traefik 作为集群 Ingress，实现 HTTPS、Routing 等部分功能。</li>\n</ul>\n</li>\n<li>Kubernetes 集群管理工具<ul>\n<li>可基于公有云创建 Kubernetes 集群，并且进行维护管理集群的基础设施。</li>\n<li>用到的技术点：对各类公有云接口进行统一接口设计，调度云资源实现 Kubernetes 集群的基础管理。于 Kubernetes ClusterAutoscaler 组件中完成自己的实例组接口，实现对集群节点的自动扩容等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"技术能力\"><a href=\"#技术能力\" class=\"headerlink\" title=\"技术能力\"></a>技术能力</h3><ul>\n<li>熟练使用 Go 语言；阅读过部分源码，了解 gin 框架。</li>\n<li>熟练使用 PHP 语言；熟悉各类框架：Laravel、Slim、CI等，阅读过部分框架源码。</li>\n<li>熟悉领域驱动设计；熟悉领域模型构建方法，可与领域专家合作设计出符合领域模型的软件架构。</li>\n<li>熟悉 REST 设计风格及 HTTP 协议；可设计出符合 RESTful 风格的 web 接口。</li>\n<li>熟悉了解部分云原生软件：Docker、Kubernetes、Prometheus 等。</li>\n<li>熟悉前端技术：JS、CSS、HTML、VueJS。</li>\n<li>了解其他语言：Python、dart(flutter)。</li>\n<li>了解 Chrome 扩展开发。</li>\n<li>熟悉 MySQL，基本数据库设计。</li>\n<li>熟悉 Linux 系统基本操作。</li>\n<li>熟悉 Git；阅读过《Pro Git》知晓基础原理。</li>\n</ul>\n<h3 id=\"技术文章\"><a href=\"#技术文章\" class=\"headerlink\" title=\"技术文章\"></a>技术文章</h3><ul>\n<li>《Kubernetes Cluster Autoscaler》 <a href=\"https://cnbailian.github.io/2020/03/KubernetesClusterAutoscaler/\">https://cnbailian.github.io/2020/03/KubernetesClusterAutoscaler/</a></li>\n<li>《Go 的并发性与调度器》<a href=\"https://cnbailian.github.io/2019/03/Concurrency-and-scheduler-of-Go/\">https://cnbailian.github.io/2019/03/Concurrency-and-scheduler-of-Go/</a></li>\n<li>《RESTful API 实践》 <a href=\"https://cnbailian.github.io/2016/10/RESTful-API-Practice/\">https://cnbailian.github.io/2016/10/RESTful-API-Practice/</a></li>\n</ul>\n<h3 id=\"技术演讲\"><a href=\"#技术演讲\" class=\"headerlink\" title=\"技术演讲\"></a>技术演讲</h3><ul>\n<li>公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。</li>\n</ul>\n<h3 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h3><p>感谢您的阅读，期待有机会能与您共事。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3><ul>\n<li>姓名：白联</li>\n<li>年龄：25</li>\n<li>工作经验：4年</li>\n<li>技术博客：<a href=\"https://cnbailian.github.io/\">https://cnbailian.github.io/</a></li>\n<li>GitHub：<a href=\"https://github.com/cnbailian\" target=\"_blank\" rel=\"noopener\">https://github.com/cnbailian</a></li>\n<li>工作状态：在职</li>\n</ul>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>手机号：15142556834</li>\n<li>邮箱：captainbailian@gmail.com</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ul>\n<li>沈阳xx数据科技有限公司 （2018-10 ~）<ul>\n<li>容器化 PAAS 平台项目<ul>\n<li>一个 Kubernetes 应用部署引擎，适用于任何标准版本的 Kubernetes 集群。通过 Kubernetes CRD 或 CLI 进行操作，用户可以将应用部署到 Kubernetes 中，并且有 CI/CD、HTTPS、Routing、Monitoring、Alerting、Autoscaling、Webhook 等功能。</li>\n<li>我负责其中大部分的产品功能设计、软件架构设计及编码工作。</li>\n<li>用到的技术点：设计 Kubernetes CRD，并实现其控制器，通过开源组件 Tekton 等组合实现 CI/CD 功能，通过 Prometheus 等实现监控报警模块。通过 Traefik 作为集群 Ingress，实现 HTTPS、Routing 等部分功能。</li>\n</ul>\n</li>\n<li>Kubernetes 集群管理工具<ul>\n<li>可基于公有云创建 Kubernetes 集群，并且进行维护管理集群的基础设施。</li>\n<li>用到的技术点：对各类公有云接口进行统一接口设计，调度云资源实现 Kubernetes 集群的基础管理。于 Kubernetes ClusterAutoscaler 组件中完成自己的实例组接口，实现对集群节点的自动扩容等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"技术能力\"><a href=\"#技术能力\" class=\"headerlink\" title=\"技术能力\"></a>技术能力</h3><ul>\n<li>熟练使用 Go 语言；阅读过部分源码，了解 gin 框架。</li>\n<li>熟练使用 PHP 语言；熟悉各类框架：Laravel、Slim、CI等，阅读过部分框架源码。</li>\n<li>熟悉领域驱动设计；熟悉领域模型构建方法，可与领域专家合作设计出符合领域模型的软件架构。</li>\n<li>熟悉 REST 设计风格及 HTTP 协议；可设计出符合 RESTful 风格的 web 接口。</li>\n<li>熟悉了解部分云原生软件：Docker、Kubernetes、Prometheus 等。</li>\n<li>熟悉前端技术：JS、CSS、HTML、VueJS。</li>\n<li>了解其他语言：Python、dart(flutter)。</li>\n<li>了解 Chrome 扩展开发。</li>\n<li>熟悉 MySQL，基本数据库设计。</li>\n<li>熟悉 Linux 系统基本操作。</li>\n<li>熟悉 Git；阅读过《Pro Git》知晓基础原理。</li>\n</ul>\n<h3 id=\"技术文章\"><a href=\"#技术文章\" class=\"headerlink\" title=\"技术文章\"></a>技术文章</h3><ul>\n<li>《Kubernetes Cluster Autoscaler》 <a href=\"https://cnbailian.github.io/2020/03/KubernetesClusterAutoscaler/\">https://cnbailian.github.io/2020/03/KubernetesClusterAutoscaler/</a></li>\n<li>《Go 的并发性与调度器》<a href=\"https://cnbailian.github.io/2019/03/Concurrency-and-scheduler-of-Go/\">https://cnbailian.github.io/2019/03/Concurrency-and-scheduler-of-Go/</a></li>\n<li>《RESTful API 实践》 <a href=\"https://cnbailian.github.io/2016/10/RESTful-API-Practice/\">https://cnbailian.github.io/2016/10/RESTful-API-Practice/</a></li>\n</ul>\n<h3 id=\"技术演讲\"><a href=\"#技术演讲\" class=\"headerlink\" title=\"技术演讲\"></a>技术演讲</h3><ul>\n<li>公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。</li>\n</ul>\n<h3 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h3><p>感谢您的阅读，期待有机会能与您共事。</p>\n"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---","date":"2020-04-03T09:15:05.837Z","updated":"2020-04-03T09:15:05.837Z","path":"tags/index.html","comments":1,"_id":"ckcy34e9z0009cyze8zpsqx7p","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Api安全 研究","date":"2016-07-13T12:46:25.000Z","_content":"\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","source":"_posts/API-security.md","raw":"---\ntitle: Api安全 研究\ndate: 2016/7/13 20:46:25\n---\n\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","slug":"API-security","published":1,"updated":"2020-07-23T00:29:18.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34e9o0000cyzejd6epzl2","content":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>\n<a id=\"more\"></a>  \n<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'data' : &#123;</span><br><span class=\"line\">\t\t'id' : 1</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t'time' : 14000000000,,</span><br><span class=\"line\">\t'token' : 'xxxxxxxxxx',</span><br><span class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></span><br><span class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></span><br><span class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</span><br><span class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></span><br><span class=\"line\">$total = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></span><br><span class=\"line\">$cycle = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></span><br><span class=\"line\">$blackTime = <span class=\"number\">600</span>;</span><br><span class=\"line\"><span class=\"comment\">// 验证黑名单</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</span><br><span class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></span><br><span class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></span><br><span class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></span><br><span class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></span><br><span class=\"line\">      $start = $k;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 存储访问记录</span></span><br><span class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</span><br><span class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>","more":"<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'data' : &#123;</span><br><span class=\"line\">\t\t'id' : 1</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t'time' : 14000000000,,</span><br><span class=\"line\">\t'token' : 'xxxxxxxxxx',</span><br><span class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></span><br><span class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></span><br><span class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</span><br><span class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></span><br><span class=\"line\">$total = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></span><br><span class=\"line\">$cycle = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></span><br><span class=\"line\">$blackTime = <span class=\"number\">600</span>;</span><br><span class=\"line\"><span class=\"comment\">// 验证黑名单</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</span><br><span class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></span><br><span class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></span><br><span class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></span><br><span class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></span><br><span class=\"line\">      $start = $k;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 存储访问记录</span></span><br><span class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</span><br><span class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</span><br></pre></td></tr></table></figure></p>"},{"title":"Clean Architecture 读书笔记","date":"2020-03-12T16:00:00.000Z","_content":"\n\n## 什么是软件架构\n\n软件架构本身是一门划分边界的艺术，边界的作用是将软件划分成各种元素，重要的是分清高层策略与底层细节的边界，同时保证这些边界的依赖关系原则。\n\n软件架构的目标：围绕着用例展开，支撑起系统的整个生命周期，让系统便于理解、易于修改、方便维护，并且能轻松部署。用最小的人力成本来满足构建和维护该系统的需求。\n\n<!--more-->  \n\n\n\n## 为好的软件架构而持续斗争\n\n#### 价值维度\n\n系统行为，是紧急的。系统架构，是重要的。根据艾森豪威尔矩阵来说：要优先重要的事。而业务人员有没有能力评估系统架构的重要程度，这是开发人员自己的工作职责。\n\n#### 持续抗争\n\n研发团队必须从长远的利益出发与其他部门抗争，软件的可维护性需要由你来保护，这是你角色的一部分，也是你职责中不可缺少的一部分。如果忽视软件架构的价值，系统将变得越来越难以维护，成本也会越来越高。终会有一天，系统将变得再也无法修改。\n\n\n\n## 如何设计一个好的软件架构\n\n#### 编程范式\n\n编程范式告诉我了我们不能做什么，而不是可以做什么：\n\n* 结构化编程对程序控制权的直接转移做出了限制。\n\n* 面向对象编程对程序控制权的间接转移进行了限制和规范。\n\n* 函数式编程对程序中的赋值进行了限制和规范。\n\n编程范式的历史知识和软件架构的关系密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是个模块的算法实现基础。折合软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。\n\n#### 设计原则\n\nSOLID 设计原则可以写出整洁的代码，它的主要作用是告诉我们如何将数据和函数组织成“类”，以及如何将这些类连接起来成为程序。概要：\n\n* SRP：单一职责原则\n\n  定义任何一个软件模块都应该只对某一类行为者负责。如果要有其他因素的干扰，通过 facade 设计模式进行类与函数的拆分。简单的类比就是 Entity 与 Use Case 或 DDD 中的聚合与领域服务。\n\n* OCP：开闭原则\n\n  我们应该通过扩展来实现新的需求，而不是修改现有代码。在软件架构层面，软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些相互隔离的函数分组整理成组件结构。\n\n* LSP：里式替换原则\n\n  如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作独享 T 类型的程序 P 在使用 o2 替换 o1 时行为保持不变，我们就可以将 S 成为 T 的字类型。这里强调的是行为保持不变，也就是说子类型可以实现父类型的抽象方法，但不能覆盖父类型的实现。\n\n* ISP：接口隔离原则\n\n  避免不必要的依赖。\n\n* DIP：依赖反转原则\n\n  高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，相反，细节应该依赖抽象。\n\n#### 组件\n\n组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。设计良好饿组件应该永远保持可被独立部署的特性。\n\n组件的聚合遵守以下三个基本原则：\n\n* REP：复用/发布等同原则\n\n  软件复用的最小粒度应等同于其发布的最小粒度\n\n* CCP：共同闭包原则\n\n  将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。\n\n* CRP：共同复用原则\n\n  不要强迫一个组件的用户依赖他们不需要的东西。也就是说，不是紧密相连的类不应该被放在同一个组件里。\n\n其中 REP 和 CCP 是黏合性原则，它们会让组件变得更大，而 CRP 原则是排除性原则，它会让组件变小。软件架构师的任务就是要在这三个原则中进行取舍。一般来说，先期主要牺牲的是复用性，随着项目成熟，要达到平衡状态。\n\n组件的互相依赖形成的依赖图中，不应该出现环，可通过依赖反转原则来打破。\n\n组件的依赖关系必须要指向更稳定的方向。依赖越多越不稳定，越少越稳定。被依赖越多越稳定，越少越不稳定。以此，高层组件策略应该被放到稳定组件中，而不稳定组件中应该只包含哪些我们想要快速和方便修改的部分。\n\n#### 保持独立性\n\n一个设计良好的架构在行为上对系统对重要的作用就是明确和显示地反映系统设计意图的行为，非常直观地支持可能会涉及的所有用例，使其在架构层面上清晰可见。\n\n但我们无法预知系统的所有用例，而且我们也无法提前预知系统的运行条件、开发团队的结构，或者系统的部署需求。就算我们能提前了解这些需求，随着系统生命周期的演进，这些需求也会不可避免的地发生变化。所以我们应该通过保留可选项的方式，让系统在任何情况下都能方便地作出必要的变更。\n\n#### 重复\n\n作为软件开发者，我们总是讨厌重复的内容，但是重复也存在着很多情况，其中有些是真正的重复，有些只是表面性的，随着时间推移，表面性重复随着时间的演变，最终可能会完全不同。正是这样的原因，我们必须加倍小心地避免让两个用例复用同一段代码。\n\n*对业务逻辑的复用，会随着业务逻辑的改变而变得不可复用，这些只是表面性复用。真正的重复应该是辅助函数这种。*\n\n#### 解耦模式\n\n* 源码层次：我们可以控制源代码之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要重新变更。人们经常把这种模式叫单体结构。\n* 部署层次：我们可以控制部署单元之间的依赖关系，以此实现一个模块的变更不会影响到其他模块的部署。在这中模式下，大部分组件还是存在同一个地址空间内，通过彼此的函数调用通信。比如 DLL 文件。\n* 服务层次：我们可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。例如 SOA 或微服务。\n\n服务层次的解耦不仅系统资源成本高昂，而且研发成本更高。通常我会更倾向于将系统的解耦推行到某种一旦有需要就可以随时转变为服务的程度即可，让整个程序尽量长时间地保持单体结构，以便给未来留下可选项。\n\n\n\n## 整洁架构\n\n![clean-architecture](https://tva1.sinaimg.cn/large/00831rSTly1gckddk2lbvj30lg0frwh4.jpg)\n\n图中的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外圆代表的是机制，内圆代表的是策略。这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。\n\n#### Entities 业务实体层\n\n业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。\n\n#### Use Case 用例层\n\n*用例，也可以叫做使用案例，是软件系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。*\n\n软件的用例层通常包含的是特定场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。\n\n#### Controllers、Gateways、Presenters 接口适配器层\n\n软件的接口适配器层通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便的操作格式，转化成外部系统（譬如数据库和 Web）最方便的操作的格式。\n\n总之，在从该层再往内的同心圆中，其代码就不应该依赖任何数据库了。\n\n#### DB、External Interfaces、UI...... 框架与驱动程序\n\n最外层的模型层一般是由工具、数据库、Web 框架等组成的。这一层包含了所有的实现细节，我们将这些细节放在最外层，这样它们就很难影响到其他层了。\n\n#### 只有这四层吗？\n\n这个图是示意性的。你可能会发现你需要的不仅仅是这四个，也没有规定说你必须始终只有这四个。但是，依赖关系原则始终适用，源代码的依赖关系总是由外向内。外层是低层次的具体细节，内层是高层策略逻辑。\n\n#### 跨边界流程\n\n当发生如图右下角这样跨越边界的流程时，可通过依赖反转原则解决内向外的依赖关系。","source":"_posts/CleanArchitecture.md","raw":"---\ntitle: Clean Architecture 读书笔记\ndate: 2020/3/13 00:00:00\n---\n\n\n## 什么是软件架构\n\n软件架构本身是一门划分边界的艺术，边界的作用是将软件划分成各种元素，重要的是分清高层策略与底层细节的边界，同时保证这些边界的依赖关系原则。\n\n软件架构的目标：围绕着用例展开，支撑起系统的整个生命周期，让系统便于理解、易于修改、方便维护，并且能轻松部署。用最小的人力成本来满足构建和维护该系统的需求。\n\n<!--more-->  \n\n\n\n## 为好的软件架构而持续斗争\n\n#### 价值维度\n\n系统行为，是紧急的。系统架构，是重要的。根据艾森豪威尔矩阵来说：要优先重要的事。而业务人员有没有能力评估系统架构的重要程度，这是开发人员自己的工作职责。\n\n#### 持续抗争\n\n研发团队必须从长远的利益出发与其他部门抗争，软件的可维护性需要由你来保护，这是你角色的一部分，也是你职责中不可缺少的一部分。如果忽视软件架构的价值，系统将变得越来越难以维护，成本也会越来越高。终会有一天，系统将变得再也无法修改。\n\n\n\n## 如何设计一个好的软件架构\n\n#### 编程范式\n\n编程范式告诉我了我们不能做什么，而不是可以做什么：\n\n* 结构化编程对程序控制权的直接转移做出了限制。\n\n* 面向对象编程对程序控制权的间接转移进行了限制和规范。\n\n* 函数式编程对程序中的赋值进行了限制和规范。\n\n编程范式的历史知识和软件架构的关系密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是个模块的算法实现基础。折合软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。\n\n#### 设计原则\n\nSOLID 设计原则可以写出整洁的代码，它的主要作用是告诉我们如何将数据和函数组织成“类”，以及如何将这些类连接起来成为程序。概要：\n\n* SRP：单一职责原则\n\n  定义任何一个软件模块都应该只对某一类行为者负责。如果要有其他因素的干扰，通过 facade 设计模式进行类与函数的拆分。简单的类比就是 Entity 与 Use Case 或 DDD 中的聚合与领域服务。\n\n* OCP：开闭原则\n\n  我们应该通过扩展来实现新的需求，而不是修改现有代码。在软件架构层面，软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些相互隔离的函数分组整理成组件结构。\n\n* LSP：里式替换原则\n\n  如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作独享 T 类型的程序 P 在使用 o2 替换 o1 时行为保持不变，我们就可以将 S 成为 T 的字类型。这里强调的是行为保持不变，也就是说子类型可以实现父类型的抽象方法，但不能覆盖父类型的实现。\n\n* ISP：接口隔离原则\n\n  避免不必要的依赖。\n\n* DIP：依赖反转原则\n\n  高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，相反，细节应该依赖抽象。\n\n#### 组件\n\n组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。设计良好饿组件应该永远保持可被独立部署的特性。\n\n组件的聚合遵守以下三个基本原则：\n\n* REP：复用/发布等同原则\n\n  软件复用的最小粒度应等同于其发布的最小粒度\n\n* CCP：共同闭包原则\n\n  将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。\n\n* CRP：共同复用原则\n\n  不要强迫一个组件的用户依赖他们不需要的东西。也就是说，不是紧密相连的类不应该被放在同一个组件里。\n\n其中 REP 和 CCP 是黏合性原则，它们会让组件变得更大，而 CRP 原则是排除性原则，它会让组件变小。软件架构师的任务就是要在这三个原则中进行取舍。一般来说，先期主要牺牲的是复用性，随着项目成熟，要达到平衡状态。\n\n组件的互相依赖形成的依赖图中，不应该出现环，可通过依赖反转原则来打破。\n\n组件的依赖关系必须要指向更稳定的方向。依赖越多越不稳定，越少越稳定。被依赖越多越稳定，越少越不稳定。以此，高层组件策略应该被放到稳定组件中，而不稳定组件中应该只包含哪些我们想要快速和方便修改的部分。\n\n#### 保持独立性\n\n一个设计良好的架构在行为上对系统对重要的作用就是明确和显示地反映系统设计意图的行为，非常直观地支持可能会涉及的所有用例，使其在架构层面上清晰可见。\n\n但我们无法预知系统的所有用例，而且我们也无法提前预知系统的运行条件、开发团队的结构，或者系统的部署需求。就算我们能提前了解这些需求，随着系统生命周期的演进，这些需求也会不可避免的地发生变化。所以我们应该通过保留可选项的方式，让系统在任何情况下都能方便地作出必要的变更。\n\n#### 重复\n\n作为软件开发者，我们总是讨厌重复的内容，但是重复也存在着很多情况，其中有些是真正的重复，有些只是表面性的，随着时间推移，表面性重复随着时间的演变，最终可能会完全不同。正是这样的原因，我们必须加倍小心地避免让两个用例复用同一段代码。\n\n*对业务逻辑的复用，会随着业务逻辑的改变而变得不可复用，这些只是表面性复用。真正的重复应该是辅助函数这种。*\n\n#### 解耦模式\n\n* 源码层次：我们可以控制源代码之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要重新变更。人们经常把这种模式叫单体结构。\n* 部署层次：我们可以控制部署单元之间的依赖关系，以此实现一个模块的变更不会影响到其他模块的部署。在这中模式下，大部分组件还是存在同一个地址空间内，通过彼此的函数调用通信。比如 DLL 文件。\n* 服务层次：我们可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。例如 SOA 或微服务。\n\n服务层次的解耦不仅系统资源成本高昂，而且研发成本更高。通常我会更倾向于将系统的解耦推行到某种一旦有需要就可以随时转变为服务的程度即可，让整个程序尽量长时间地保持单体结构，以便给未来留下可选项。\n\n\n\n## 整洁架构\n\n![clean-architecture](https://tva1.sinaimg.cn/large/00831rSTly1gckddk2lbvj30lg0frwh4.jpg)\n\n图中的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外圆代表的是机制，内圆代表的是策略。这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。\n\n#### Entities 业务实体层\n\n业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。\n\n#### Use Case 用例层\n\n*用例，也可以叫做使用案例，是软件系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。*\n\n软件的用例层通常包含的是特定场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。\n\n#### Controllers、Gateways、Presenters 接口适配器层\n\n软件的接口适配器层通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便的操作格式，转化成外部系统（譬如数据库和 Web）最方便的操作的格式。\n\n总之，在从该层再往内的同心圆中，其代码就不应该依赖任何数据库了。\n\n#### DB、External Interfaces、UI...... 框架与驱动程序\n\n最外层的模型层一般是由工具、数据库、Web 框架等组成的。这一层包含了所有的实现细节，我们将这些细节放在最外层，这样它们就很难影响到其他层了。\n\n#### 只有这四层吗？\n\n这个图是示意性的。你可能会发现你需要的不仅仅是这四个，也没有规定说你必须始终只有这四个。但是，依赖关系原则始终适用，源代码的依赖关系总是由外向内。外层是低层次的具体细节，内层是高层策略逻辑。\n\n#### 跨边界流程\n\n当发生如图右下角这样跨越边界的流程时，可通过依赖反转原则解决内向外的依赖关系。","slug":"CleanArchitecture","published":1,"updated":"2020-07-23T00:40:48.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34e9t0002cyzeg5nr77oi","content":"<h2 id=\"什么是软件架构\"><a href=\"#什么是软件架构\" class=\"headerlink\" title=\"什么是软件架构\"></a>什么是软件架构</h2><p>软件架构本身是一门划分边界的艺术，边界的作用是将软件划分成各种元素，重要的是分清高层策略与底层细节的边界，同时保证这些边界的依赖关系原则。</p>\n<p>软件架构的目标：围绕着用例展开，支撑起系统的整个生命周期，让系统便于理解、易于修改、方便维护，并且能轻松部署。用最小的人力成本来满足构建和维护该系统的需求。</p>\n<a id=\"more\"></a>  \n<h2 id=\"为好的软件架构而持续斗争\"><a href=\"#为好的软件架构而持续斗争\" class=\"headerlink\" title=\"为好的软件架构而持续斗争\"></a>为好的软件架构而持续斗争</h2><h4 id=\"价值维度\"><a href=\"#价值维度\" class=\"headerlink\" title=\"价值维度\"></a>价值维度</h4><p>系统行为，是紧急的。系统架构，是重要的。根据艾森豪威尔矩阵来说：要优先重要的事。而业务人员有没有能力评估系统架构的重要程度，这是开发人员自己的工作职责。</p>\n<h4 id=\"持续抗争\"><a href=\"#持续抗争\" class=\"headerlink\" title=\"持续抗争\"></a>持续抗争</h4><p>研发团队必须从长远的利益出发与其他部门抗争，软件的可维护性需要由你来保护，这是你角色的一部分，也是你职责中不可缺少的一部分。如果忽视软件架构的价值，系统将变得越来越难以维护，成本也会越来越高。终会有一天，系统将变得再也无法修改。</p>\n<h2 id=\"如何设计一个好的软件架构\"><a href=\"#如何设计一个好的软件架构\" class=\"headerlink\" title=\"如何设计一个好的软件架构\"></a>如何设计一个好的软件架构</h2><h4 id=\"编程范式\"><a href=\"#编程范式\" class=\"headerlink\" title=\"编程范式\"></a>编程范式</h4><p>编程范式告诉我了我们不能做什么，而不是可以做什么：</p>\n<ul>\n<li><p>结构化编程对程序控制权的直接转移做出了限制。</p>\n</li>\n<li><p>面向对象编程对程序控制权的间接转移进行了限制和规范。</p>\n</li>\n<li><p>函数式编程对程序中的赋值进行了限制和规范。</p>\n</li>\n</ul>\n<p>编程范式的历史知识和软件架构的关系密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是个模块的算法实现基础。折合软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</p>\n<h4 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h4><p>SOLID 设计原则可以写出整洁的代码，它的主要作用是告诉我们如何将数据和函数组织成“类”，以及如何将这些类连接起来成为程序。概要：</p>\n<ul>\n<li><p>SRP：单一职责原则</p>\n<p>定义任何一个软件模块都应该只对某一类行为者负责。如果要有其他因素的干扰，通过 facade 设计模式进行类与函数的拆分。简单的类比就是 Entity 与 Use Case 或 DDD 中的聚合与领域服务。</p>\n</li>\n<li><p>OCP：开闭原则</p>\n<p>我们应该通过扩展来实现新的需求，而不是修改现有代码。在软件架构层面，软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些相互隔离的函数分组整理成组件结构。</p>\n</li>\n<li><p>LSP：里式替换原则</p>\n<p>如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作独享 T 类型的程序 P 在使用 o2 替换 o1 时行为保持不变，我们就可以将 S 成为 T 的字类型。这里强调的是行为保持不变，也就是说子类型可以实现父类型的抽象方法，但不能覆盖父类型的实现。</p>\n</li>\n<li><p>ISP：接口隔离原则</p>\n<p>避免不必要的依赖。</p>\n</li>\n<li><p>DIP：依赖反转原则</p>\n<p>高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，相反，细节应该依赖抽象。</p>\n</li>\n</ul>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><p>组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。设计良好饿组件应该永远保持可被独立部署的特性。</p>\n<p>组件的聚合遵守以下三个基本原则：</p>\n<ul>\n<li><p>REP：复用/发布等同原则</p>\n<p>软件复用的最小粒度应等同于其发布的最小粒度</p>\n</li>\n<li><p>CCP：共同闭包原则</p>\n<p>将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。</p>\n</li>\n<li><p>CRP：共同复用原则</p>\n<p>不要强迫一个组件的用户依赖他们不需要的东西。也就是说，不是紧密相连的类不应该被放在同一个组件里。</p>\n</li>\n</ul>\n<p>其中 REP 和 CCP 是黏合性原则，它们会让组件变得更大，而 CRP 原则是排除性原则，它会让组件变小。软件架构师的任务就是要在这三个原则中进行取舍。一般来说，先期主要牺牲的是复用性，随着项目成熟，要达到平衡状态。</p>\n<p>组件的互相依赖形成的依赖图中，不应该出现环，可通过依赖反转原则来打破。</p>\n<p>组件的依赖关系必须要指向更稳定的方向。依赖越多越不稳定，越少越稳定。被依赖越多越稳定，越少越不稳定。以此，高层组件策略应该被放到稳定组件中，而不稳定组件中应该只包含哪些我们想要快速和方便修改的部分。</p>\n<h4 id=\"保持独立性\"><a href=\"#保持独立性\" class=\"headerlink\" title=\"保持独立性\"></a>保持独立性</h4><p>一个设计良好的架构在行为上对系统对重要的作用就是明确和显示地反映系统设计意图的行为，非常直观地支持可能会涉及的所有用例，使其在架构层面上清晰可见。</p>\n<p>但我们无法预知系统的所有用例，而且我们也无法提前预知系统的运行条件、开发团队的结构，或者系统的部署需求。就算我们能提前了解这些需求，随着系统生命周期的演进，这些需求也会不可避免的地发生变化。所以我们应该通过保留可选项的方式，让系统在任何情况下都能方便地作出必要的变更。</p>\n<h4 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h4><p>作为软件开发者，我们总是讨厌重复的内容，但是重复也存在着很多情况，其中有些是真正的重复，有些只是表面性的，随着时间推移，表面性重复随着时间的演变，最终可能会完全不同。正是这样的原因，我们必须加倍小心地避免让两个用例复用同一段代码。</p>\n<p><em>对业务逻辑的复用，会随着业务逻辑的改变而变得不可复用，这些只是表面性复用。真正的重复应该是辅助函数这种。</em></p>\n<h4 id=\"解耦模式\"><a href=\"#解耦模式\" class=\"headerlink\" title=\"解耦模式\"></a>解耦模式</h4><ul>\n<li>源码层次：我们可以控制源代码之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要重新变更。人们经常把这种模式叫单体结构。</li>\n<li>部署层次：我们可以控制部署单元之间的依赖关系，以此实现一个模块的变更不会影响到其他模块的部署。在这中模式下，大部分组件还是存在同一个地址空间内，通过彼此的函数调用通信。比如 DLL 文件。</li>\n<li>服务层次：我们可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。例如 SOA 或微服务。</li>\n</ul>\n<p>服务层次的解耦不仅系统资源成本高昂，而且研发成本更高。通常我会更倾向于将系统的解耦推行到某种一旦有需要就可以随时转变为服务的程度即可，让整个程序尽量长时间地保持单体结构，以便给未来留下可选项。</p>\n<h2 id=\"整洁架构\"><a href=\"#整洁架构\" class=\"headerlink\" title=\"整洁架构\"></a>整洁架构</h2><p><img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gckddk2lbvj30lg0frwh4.jpg\" alt=\"clean-architecture\"></p>\n<p>图中的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外圆代表的是机制，内圆代表的是策略。这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</p>\n<h4 id=\"Entities-业务实体层\"><a href=\"#Entities-业务实体层\" class=\"headerlink\" title=\"Entities 业务实体层\"></a>Entities 业务实体层</h4><p>业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。</p>\n<h4 id=\"Use-Case-用例层\"><a href=\"#Use-Case-用例层\" class=\"headerlink\" title=\"Use Case 用例层\"></a>Use Case 用例层</h4><p><em>用例，也可以叫做使用案例，是软件系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。</em></p>\n<p>软件的用例层通常包含的是特定场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。</p>\n<h4 id=\"Controllers、Gateways、Presenters-接口适配器层\"><a href=\"#Controllers、Gateways、Presenters-接口适配器层\" class=\"headerlink\" title=\"Controllers、Gateways、Presenters 接口适配器层\"></a>Controllers、Gateways、Presenters 接口适配器层</h4><p>软件的接口适配器层通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便的操作格式，转化成外部系统（譬如数据库和 Web）最方便的操作的格式。</p>\n<p>总之，在从该层再往内的同心圆中，其代码就不应该依赖任何数据库了。</p>\n<h4 id=\"DB、External-Interfaces、UI……-框架与驱动程序\"><a href=\"#DB、External-Interfaces、UI……-框架与驱动程序\" class=\"headerlink\" title=\"DB、External Interfaces、UI…… 框架与驱动程序\"></a>DB、External Interfaces、UI…… 框架与驱动程序</h4><p>最外层的模型层一般是由工具、数据库、Web 框架等组成的。这一层包含了所有的实现细节，我们将这些细节放在最外层，这样它们就很难影响到其他层了。</p>\n<h4 id=\"只有这四层吗？\"><a href=\"#只有这四层吗？\" class=\"headerlink\" title=\"只有这四层吗？\"></a>只有这四层吗？</h4><p>这个图是示意性的。你可能会发现你需要的不仅仅是这四个，也没有规定说你必须始终只有这四个。但是，依赖关系原则始终适用，源代码的依赖关系总是由外向内。外层是低层次的具体细节，内层是高层策略逻辑。</p>\n<h4 id=\"跨边界流程\"><a href=\"#跨边界流程\" class=\"headerlink\" title=\"跨边界流程\"></a>跨边界流程</h4><p>当发生如图右下角这样跨越边界的流程时，可通过依赖反转原则解决内向外的依赖关系。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是软件架构\"><a href=\"#什么是软件架构\" class=\"headerlink\" title=\"什么是软件架构\"></a>什么是软件架构</h2><p>软件架构本身是一门划分边界的艺术，边界的作用是将软件划分成各种元素，重要的是分清高层策略与底层细节的边界，同时保证这些边界的依赖关系原则。</p>\n<p>软件架构的目标：围绕着用例展开，支撑起系统的整个生命周期，让系统便于理解、易于修改、方便维护，并且能轻松部署。用最小的人力成本来满足构建和维护该系统的需求。</p>","more":"<h2 id=\"为好的软件架构而持续斗争\"><a href=\"#为好的软件架构而持续斗争\" class=\"headerlink\" title=\"为好的软件架构而持续斗争\"></a>为好的软件架构而持续斗争</h2><h4 id=\"价值维度\"><a href=\"#价值维度\" class=\"headerlink\" title=\"价值维度\"></a>价值维度</h4><p>系统行为，是紧急的。系统架构，是重要的。根据艾森豪威尔矩阵来说：要优先重要的事。而业务人员有没有能力评估系统架构的重要程度，这是开发人员自己的工作职责。</p>\n<h4 id=\"持续抗争\"><a href=\"#持续抗争\" class=\"headerlink\" title=\"持续抗争\"></a>持续抗争</h4><p>研发团队必须从长远的利益出发与其他部门抗争，软件的可维护性需要由你来保护，这是你角色的一部分，也是你职责中不可缺少的一部分。如果忽视软件架构的价值，系统将变得越来越难以维护，成本也会越来越高。终会有一天，系统将变得再也无法修改。</p>\n<h2 id=\"如何设计一个好的软件架构\"><a href=\"#如何设计一个好的软件架构\" class=\"headerlink\" title=\"如何设计一个好的软件架构\"></a>如何设计一个好的软件架构</h2><h4 id=\"编程范式\"><a href=\"#编程范式\" class=\"headerlink\" title=\"编程范式\"></a>编程范式</h4><p>编程范式告诉我了我们不能做什么，而不是可以做什么：</p>\n<ul>\n<li><p>结构化编程对程序控制权的直接转移做出了限制。</p>\n</li>\n<li><p>面向对象编程对程序控制权的间接转移进行了限制和规范。</p>\n</li>\n<li><p>函数式编程对程序中的赋值进行了限制和规范。</p>\n</li>\n</ul>\n<p>编程范式的历史知识和软件架构的关系密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是个模块的算法实现基础。折合软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</p>\n<h4 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h4><p>SOLID 设计原则可以写出整洁的代码，它的主要作用是告诉我们如何将数据和函数组织成“类”，以及如何将这些类连接起来成为程序。概要：</p>\n<ul>\n<li><p>SRP：单一职责原则</p>\n<p>定义任何一个软件模块都应该只对某一类行为者负责。如果要有其他因素的干扰，通过 facade 设计模式进行类与函数的拆分。简单的类比就是 Entity 与 Use Case 或 DDD 中的聚合与领域服务。</p>\n</li>\n<li><p>OCP：开闭原则</p>\n<p>我们应该通过扩展来实现新的需求，而不是修改现有代码。在软件架构层面，软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些相互隔离的函数分组整理成组件结构。</p>\n</li>\n<li><p>LSP：里式替换原则</p>\n<p>如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作独享 T 类型的程序 P 在使用 o2 替换 o1 时行为保持不变，我们就可以将 S 成为 T 的字类型。这里强调的是行为保持不变，也就是说子类型可以实现父类型的抽象方法，但不能覆盖父类型的实现。</p>\n</li>\n<li><p>ISP：接口隔离原则</p>\n<p>避免不必要的依赖。</p>\n</li>\n<li><p>DIP：依赖反转原则</p>\n<p>高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，相反，细节应该依赖抽象。</p>\n</li>\n</ul>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><p>组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。设计良好饿组件应该永远保持可被独立部署的特性。</p>\n<p>组件的聚合遵守以下三个基本原则：</p>\n<ul>\n<li><p>REP：复用/发布等同原则</p>\n<p>软件复用的最小粒度应等同于其发布的最小粒度</p>\n</li>\n<li><p>CCP：共同闭包原则</p>\n<p>将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。</p>\n</li>\n<li><p>CRP：共同复用原则</p>\n<p>不要强迫一个组件的用户依赖他们不需要的东西。也就是说，不是紧密相连的类不应该被放在同一个组件里。</p>\n</li>\n</ul>\n<p>其中 REP 和 CCP 是黏合性原则，它们会让组件变得更大，而 CRP 原则是排除性原则，它会让组件变小。软件架构师的任务就是要在这三个原则中进行取舍。一般来说，先期主要牺牲的是复用性，随着项目成熟，要达到平衡状态。</p>\n<p>组件的互相依赖形成的依赖图中，不应该出现环，可通过依赖反转原则来打破。</p>\n<p>组件的依赖关系必须要指向更稳定的方向。依赖越多越不稳定，越少越稳定。被依赖越多越稳定，越少越不稳定。以此，高层组件策略应该被放到稳定组件中，而不稳定组件中应该只包含哪些我们想要快速和方便修改的部分。</p>\n<h4 id=\"保持独立性\"><a href=\"#保持独立性\" class=\"headerlink\" title=\"保持独立性\"></a>保持独立性</h4><p>一个设计良好的架构在行为上对系统对重要的作用就是明确和显示地反映系统设计意图的行为，非常直观地支持可能会涉及的所有用例，使其在架构层面上清晰可见。</p>\n<p>但我们无法预知系统的所有用例，而且我们也无法提前预知系统的运行条件、开发团队的结构，或者系统的部署需求。就算我们能提前了解这些需求，随着系统生命周期的演进，这些需求也会不可避免的地发生变化。所以我们应该通过保留可选项的方式，让系统在任何情况下都能方便地作出必要的变更。</p>\n<h4 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h4><p>作为软件开发者，我们总是讨厌重复的内容，但是重复也存在着很多情况，其中有些是真正的重复，有些只是表面性的，随着时间推移，表面性重复随着时间的演变，最终可能会完全不同。正是这样的原因，我们必须加倍小心地避免让两个用例复用同一段代码。</p>\n<p><em>对业务逻辑的复用，会随着业务逻辑的改变而变得不可复用，这些只是表面性复用。真正的重复应该是辅助函数这种。</em></p>\n<h4 id=\"解耦模式\"><a href=\"#解耦模式\" class=\"headerlink\" title=\"解耦模式\"></a>解耦模式</h4><ul>\n<li>源码层次：我们可以控制源代码之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要重新变更。人们经常把这种模式叫单体结构。</li>\n<li>部署层次：我们可以控制部署单元之间的依赖关系，以此实现一个模块的变更不会影响到其他模块的部署。在这中模式下，大部分组件还是存在同一个地址空间内，通过彼此的函数调用通信。比如 DLL 文件。</li>\n<li>服务层次：我们可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。例如 SOA 或微服务。</li>\n</ul>\n<p>服务层次的解耦不仅系统资源成本高昂，而且研发成本更高。通常我会更倾向于将系统的解耦推行到某种一旦有需要就可以随时转变为服务的程度即可，让整个程序尽量长时间地保持单体结构，以便给未来留下可选项。</p>\n<h2 id=\"整洁架构\"><a href=\"#整洁架构\" class=\"headerlink\" title=\"整洁架构\"></a>整洁架构</h2><p><img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gckddk2lbvj30lg0frwh4.jpg\" alt=\"clean-architecture\"></p>\n<p>图中的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外圆代表的是机制，内圆代表的是策略。这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</p>\n<h4 id=\"Entities-业务实体层\"><a href=\"#Entities-业务实体层\" class=\"headerlink\" title=\"Entities 业务实体层\"></a>Entities 业务实体层</h4><p>业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。</p>\n<h4 id=\"Use-Case-用例层\"><a href=\"#Use-Case-用例层\" class=\"headerlink\" title=\"Use Case 用例层\"></a>Use Case 用例层</h4><p><em>用例，也可以叫做使用案例，是软件系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。</em></p>\n<p>软件的用例层通常包含的是特定场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。</p>\n<h4 id=\"Controllers、Gateways、Presenters-接口适配器层\"><a href=\"#Controllers、Gateways、Presenters-接口适配器层\" class=\"headerlink\" title=\"Controllers、Gateways、Presenters 接口适配器层\"></a>Controllers、Gateways、Presenters 接口适配器层</h4><p>软件的接口适配器层通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便的操作格式，转化成外部系统（譬如数据库和 Web）最方便的操作的格式。</p>\n<p>总之，在从该层再往内的同心圆中，其代码就不应该依赖任何数据库了。</p>\n<h4 id=\"DB、External-Interfaces、UI……-框架与驱动程序\"><a href=\"#DB、External-Interfaces、UI……-框架与驱动程序\" class=\"headerlink\" title=\"DB、External Interfaces、UI…… 框架与驱动程序\"></a>DB、External Interfaces、UI…… 框架与驱动程序</h4><p>最外层的模型层一般是由工具、数据库、Web 框架等组成的。这一层包含了所有的实现细节，我们将这些细节放在最外层，这样它们就很难影响到其他层了。</p>\n<h4 id=\"只有这四层吗？\"><a href=\"#只有这四层吗？\" class=\"headerlink\" title=\"只有这四层吗？\"></a>只有这四层吗？</h4><p>这个图是示意性的。你可能会发现你需要的不仅仅是这四个，也没有规定说你必须始终只有这四个。但是，依赖关系原则始终适用，源代码的依赖关系总是由外向内。外层是低层次的具体细节，内层是高层策略逻辑。</p>\n<h4 id=\"跨边界流程\"><a href=\"#跨边界流程\" class=\"headerlink\" title=\"跨边界流程\"></a>跨边界流程</h4><p>当发生如图右下角这样跨越边界的流程时，可通过依赖反转原则解决内向外的依赖关系。</p>"},{"title":"Go 的并发性与调度器","date":"2019-03-06T12:12:19.000Z","_content":"\n本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。\n\n<!--more-->  \n\n### 你真的了解并发吗？\n\n相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 `go` 关键字，就可以轻松的实现并发。但是，你真正的了解**并发**吗？\n\n并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指**同一时刻的请求量**，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。*高并发在这里还有个可能的概念是：**同时应对许多请求所使用的技术**，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。*\n\n并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。\n\n下面，让我们看看 Go 语言编程中，“并发”这个词的概念。\n\n### Go 语言中的并发性\n\nGo 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：\n\n* 为什么要有并发？\n* 什么是并发？\n* 这个想法源自哪里？\n* 并发有什么好处？\n* 我该如何使用它？\n\n面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：[《Go Concurrency Patterns》](https://www.youtube.com/watch?v=f6kdp27TYZs)，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。\n\n简单的总结一下并发在 Go 语言编程中的概念：\n\n**“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。**\n\n在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个[素数筛选程序](https://play.golang.org/p/9U22NfrXeq)来理解 Go 的并发编程：\n\n```go\n// A concurrent prime sieve\n\npackage main\n\n// Send the sequence 2, 3, 4, ... to channel 'ch'.\nfunc Generate(ch chan<- int) {\n\tfor i := 2; ; i++ {\n\t\tch <- i // Send 'i' to channel 'ch'.\n\t}\n}\n\n// Copy the values from channel 'in' to channel 'out',\n// removing those divisible by 'prime'.\nfunc Filter(in <-chan int, out chan<- int, prime int) {\n\tfor {\n\t\ti := <-in // Receive value from 'in'.\n\t\tif i%prime != 0 {\n\t\t\tout <- i // Send 'i' to 'out'.\n\t\t}\n\t}\n}\n\n// The prime sieve: Daisy-chain Filter processes.\nfunc main() {\n\tch := make(chan int) // Create a new channel.\n\tgo Generate(ch)      // Launch Generate goroutine.\n\tfor i := 0; i < 10; i++ {\n\t\tprime := <-ch\n\t\tprint(prime, \"\\n\")\n\t\tch1 := make(chan int)\n\t\tgo Filter(ch, ch1, prime)\n\t\tch = ch1\n\t}\n}\n```\n\n它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、[**通过通信共享内存**](https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes)的理念，而且非常优雅。\n\n在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。\n\n通过下面的 gif 动画能清晰的看到程序运行过程：\n\n![primesieve](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif)\n\n### 并发不是并行\n\n#### Go 的并行\n\n只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？\n\n我们需要明确一个观点：**并发不是为了效率，并发的程序不一定可以并行。**还是上面素数的例子，这段代码是并发的，但不可以并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。\n\n#### 正交概念\n\n*正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。*\n\n在广义概念上来讲，并发与并行是**正交概念**，对于 Go 语言的并发性来讲也是如此。\n\n#### 《Concurrency is not Parallelism》\n\n同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。\n\n这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：\n\n**并行是指同时能执行多个事情。**\n\n**并发关乎结构，是一种结构化程序的方式。**\n\n**并行关乎执行，表述的是程序的运行状态。**\n\n### Go 语言是如何支持并发的？\n\n上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。\n\n我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。\n\n#### 模型演化过程\n\n在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在[**《Scalable Go Scheduler Design Doc》**](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit)中指出了该模型在并发伸缩性方面的问题：\n\n> 1. 所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。\n> 2. 当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；\n> 3. M 用到的 `mCache` 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；\n> 4. 由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。\n\n并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：\n\n![gpm-nino](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg)\n\n#### G-P-M 模型\n\n那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：\n\n* G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。\n* P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 >= P的数量），由用户设置的 GOMAXPROCS 决定。\n* M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。\n\n接下来了解这套模型的基本调度，在调度过程中还有一个 [*work-stealing*](http://supertech.csail.mit.edu/papers/steal.pdf) 的算法：\n\n* 每个 P 维护一个本地队列；\n* 当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；\n* 当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；\n* 如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。\n\nGo 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。\n\n### Goroutine 调度器的深入\n\n让我们深入的了解一下 goroutine 调度器。\n\n#### 调度器解决了什么问题？\n\n##### 阻塞问题\n\n> 如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。\n\nGo 在执行阻塞的系统调用时会调用 `entersyscallblock` ，然后通过 `handoffp` 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 `pidle` 链表，等待有需要时被取出。\n\n如果是调用的 `entersyscall`，会将 P 的状态置为 `_Psyscall`。监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现是 `_Psyscall` 状态，就会调用 `handoffp` 来释放。\n\n##### 抢占调度\n\n在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。\n\n于是 Dmitry Vyukov 提出了[《Go Preemptive Scheduler Design Doc》](https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit), 并在1.2版本中引入了初级的抢占。\n\n监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现运行时间超出 `forcePreemptNS` 限制（10ms）的 P，就会通过 `preemptone` 发起抢占。\n\n##### Goroutine 的负载均衡\n\n> 内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。\n\n这部分的实现是在 M 的启动函数 `mstart` 中 `schedule` 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。\n\n#### 调度器相关源码\n\n调度器部分的代码主要集中在 `src/runtime/runtime2.go` 与 `src/runtime/proc.go` 这两个文件中。\n\n调度器的4个基本结构：g、m、p、schedt，都在 `runtime2.go` 中，`schedt` 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 `pidle`，空闲的 M 链表 `midle` 等等。\n\n调度器的具体实现函数都在 `proc.go` 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 `main` 中的代码放入 `main goroutine` 中运行，这时还会启动监控系统 `sysmon`。\n\n更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。\n\n### 结束语\n\n看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。\n\n### 参考文章\n\n[《Go Concurrency Patterns》](https://talks.golang.org/2012/concurrency.slide#1)\n\n[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)\n\n[《go-under-the-hood》](https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md)\n\n[《也谈goroutine调度器》](https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/)\n\n[《Goroutine浅析》](https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/)","source":"_posts/Concurrency-and-scheduler-of-Go.md","raw":"---\ntitle: Go 的并发性与调度器\ndate: 2019/03/06 20:12:19\n---\n\n本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。\n\n<!--more-->  \n\n### 你真的了解并发吗？\n\n相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 `go` 关键字，就可以轻松的实现并发。但是，你真正的了解**并发**吗？\n\n并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指**同一时刻的请求量**，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。*高并发在这里还有个可能的概念是：**同时应对许多请求所使用的技术**，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。*\n\n并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。\n\n下面，让我们看看 Go 语言编程中，“并发”这个词的概念。\n\n### Go 语言中的并发性\n\nGo 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：\n\n* 为什么要有并发？\n* 什么是并发？\n* 这个想法源自哪里？\n* 并发有什么好处？\n* 我该如何使用它？\n\n面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：[《Go Concurrency Patterns》](https://www.youtube.com/watch?v=f6kdp27TYZs)，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。\n\n简单的总结一下并发在 Go 语言编程中的概念：\n\n**“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。**\n\n在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个[素数筛选程序](https://play.golang.org/p/9U22NfrXeq)来理解 Go 的并发编程：\n\n```go\n// A concurrent prime sieve\n\npackage main\n\n// Send the sequence 2, 3, 4, ... to channel 'ch'.\nfunc Generate(ch chan<- int) {\n\tfor i := 2; ; i++ {\n\t\tch <- i // Send 'i' to channel 'ch'.\n\t}\n}\n\n// Copy the values from channel 'in' to channel 'out',\n// removing those divisible by 'prime'.\nfunc Filter(in <-chan int, out chan<- int, prime int) {\n\tfor {\n\t\ti := <-in // Receive value from 'in'.\n\t\tif i%prime != 0 {\n\t\t\tout <- i // Send 'i' to 'out'.\n\t\t}\n\t}\n}\n\n// The prime sieve: Daisy-chain Filter processes.\nfunc main() {\n\tch := make(chan int) // Create a new channel.\n\tgo Generate(ch)      // Launch Generate goroutine.\n\tfor i := 0; i < 10; i++ {\n\t\tprime := <-ch\n\t\tprint(prime, \"\\n\")\n\t\tch1 := make(chan int)\n\t\tgo Filter(ch, ch1, prime)\n\t\tch = ch1\n\t}\n}\n```\n\n它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、[**通过通信共享内存**](https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes)的理念，而且非常优雅。\n\n在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。\n\n通过下面的 gif 动画能清晰的看到程序运行过程：\n\n![primesieve](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif)\n\n### 并发不是并行\n\n#### Go 的并行\n\n只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？\n\n我们需要明确一个观点：**并发不是为了效率，并发的程序不一定可以并行。**还是上面素数的例子，这段代码是并发的，但不可以并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。\n\n#### 正交概念\n\n*正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。*\n\n在广义概念上来讲，并发与并行是**正交概念**，对于 Go 语言的并发性来讲也是如此。\n\n#### 《Concurrency is not Parallelism》\n\n同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。\n\n这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：\n\n**并行是指同时能执行多个事情。**\n\n**并发关乎结构，是一种结构化程序的方式。**\n\n**并行关乎执行，表述的是程序的运行状态。**\n\n### Go 语言是如何支持并发的？\n\n上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。\n\n我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。\n\n#### 模型演化过程\n\n在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在[**《Scalable Go Scheduler Design Doc》**](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit)中指出了该模型在并发伸缩性方面的问题：\n\n> 1. 所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。\n> 2. 当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；\n> 3. M 用到的 `mCache` 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；\n> 4. 由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。\n\n并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：\n\n![gpm-nino](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg)\n\n#### G-P-M 模型\n\n那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：\n\n* G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。\n* P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 >= P的数量），由用户设置的 GOMAXPROCS 决定。\n* M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。\n\n接下来了解这套模型的基本调度，在调度过程中还有一个 [*work-stealing*](http://supertech.csail.mit.edu/papers/steal.pdf) 的算法：\n\n* 每个 P 维护一个本地队列；\n* 当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；\n* 当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；\n* 如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。\n\nGo 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。\n\n### Goroutine 调度器的深入\n\n让我们深入的了解一下 goroutine 调度器。\n\n#### 调度器解决了什么问题？\n\n##### 阻塞问题\n\n> 如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。\n\nGo 在执行阻塞的系统调用时会调用 `entersyscallblock` ，然后通过 `handoffp` 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 `pidle` 链表，等待有需要时被取出。\n\n如果是调用的 `entersyscall`，会将 P 的状态置为 `_Psyscall`。监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现是 `_Psyscall` 状态，就会调用 `handoffp` 来释放。\n\n##### 抢占调度\n\n在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。\n\n于是 Dmitry Vyukov 提出了[《Go Preemptive Scheduler Design Doc》](https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit), 并在1.2版本中引入了初级的抢占。\n\n监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现运行时间超出 `forcePreemptNS` 限制（10ms）的 P，就会通过 `preemptone` 发起抢占。\n\n##### Goroutine 的负载均衡\n\n> 内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。\n\n这部分的实现是在 M 的启动函数 `mstart` 中 `schedule` 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。\n\n#### 调度器相关源码\n\n调度器部分的代码主要集中在 `src/runtime/runtime2.go` 与 `src/runtime/proc.go` 这两个文件中。\n\n调度器的4个基本结构：g、m、p、schedt，都在 `runtime2.go` 中，`schedt` 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 `pidle`，空闲的 M 链表 `midle` 等等。\n\n调度器的具体实现函数都在 `proc.go` 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 `main` 中的代码放入 `main goroutine` 中运行，这时还会启动监控系统 `sysmon`。\n\n更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。\n\n### 结束语\n\n看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。\n\n### 参考文章\n\n[《Go Concurrency Patterns》](https://talks.golang.org/2012/concurrency.slide#1)\n\n[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)\n\n[《go-under-the-hood》](https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md)\n\n[《也谈goroutine调度器》](https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/)\n\n[《Goroutine浅析》](https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/)","slug":"Concurrency-and-scheduler-of-Go","published":1,"updated":"2020-07-23T00:29:18.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34e9v0004cyzea9mepjfc","content":"<p>本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。</p>\n<a id=\"more\"></a>  \n<h3 id=\"你真的了解并发吗？\"><a href=\"#你真的了解并发吗？\" class=\"headerlink\" title=\"你真的了解并发吗？\"></a>你真的了解并发吗？</h3><p>相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 <code>go</code> 关键字，就可以轻松的实现并发。但是，你真正的了解<strong>并发</strong>吗？</p>\n<p>并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指<strong>同一时刻的请求量</strong>，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。<em>高并发在这里还有个可能的概念是：<strong>同时应对许多请求所使用的技术</strong>，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。</em></p>\n<p>并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。</p>\n<p>下面，让我们看看 Go 语言编程中，“并发”这个词的概念。</p>\n<h3 id=\"Go-语言中的并发性\"><a href=\"#Go-语言中的并发性\" class=\"headerlink\" title=\"Go 语言中的并发性\"></a>Go 语言中的并发性</h3><p>Go 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：</p>\n<ul>\n<li>为什么要有并发？</li>\n<li>什么是并发？</li>\n<li>这个想法源自哪里？</li>\n<li>并发有什么好处？</li>\n<li>我该如何使用它？</li>\n</ul>\n<p>面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：<a href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a>，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。</p>\n<p>简单的总结一下并发在 Go 语言编程中的概念：</p>\n<p><strong>“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。</strong></p>\n<p>在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个<a href=\"https://play.golang.org/p/9U22NfrXeq\" target=\"_blank\" rel=\"noopener\">素数筛选程序</a>来理解 Go 的并发编程：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A concurrent prime sieve</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Generate</span><span class=\"params\">(ch <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; ; i++ &#123;</span><br><span class=\"line\">\t\tch &lt;- i <span class=\"comment\">// Send 'i' to channel 'ch'.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Copy the values from channel 'in' to channel 'out',</span></span><br><span class=\"line\"><span class=\"comment\">// removing those divisible by 'prime'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Filter</span><span class=\"params\">(in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, out <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, prime <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\ti := &lt;-in <span class=\"comment\">// Receive value from 'in'.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i%prime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tout &lt;- i <span class=\"comment\">// Send 'i' to 'out'.</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The prime sieve: Daisy-chain Filter processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// Create a new channel.</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> Generate(ch)      <span class=\"comment\">// Launch Generate goroutine.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tprime := &lt;-ch</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(prime, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t\tch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> Filter(ch, ch1, prime)</span><br><span class=\"line\">\t\tch = ch1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、<a href=\"https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes\" target=\"_blank\" rel=\"noopener\"><strong>通过通信共享内存</strong></a>的理念，而且非常优雅。</p>\n<p>在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。</p>\n<p>通过下面的 gif 动画能清晰的看到程序运行过程：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif\" alt=\"primesieve\"></p>\n<h3 id=\"并发不是并行\"><a href=\"#并发不是并行\" class=\"headerlink\" title=\"并发不是并行\"></a>并发不是并行</h3><h4 id=\"Go-的并行\"><a href=\"#Go-的并行\" class=\"headerlink\" title=\"Go 的并行\"></a>Go 的并行</h4><p>只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？</p>\n<p>我们需要明确一个观点：<strong>并发不是为了效率，并发的程序不一定可以并行。</strong>还是上面素数的例子，这段代码是并发的，但不可以并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。</p>\n<h4 id=\"正交概念\"><a href=\"#正交概念\" class=\"headerlink\" title=\"正交概念\"></a>正交概念</h4><p><em>正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。</em></p>\n<p>在广义概念上来讲，并发与并行是<strong>正交概念</strong>，对于 Go 语言的并发性来讲也是如此。</p>\n<h4 id=\"《Concurrency-is-not-Parallelism》\"><a href=\"#《Concurrency-is-not-Parallelism》\" class=\"headerlink\" title=\"《Concurrency is not Parallelism》\"></a>《Concurrency is not Parallelism》</h4><p>同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲<a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a>，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。</p>\n<p>这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：</p>\n<p><strong>并行是指同时能执行多个事情。</strong></p>\n<p><strong>并发关乎结构，是一种结构化程序的方式。</strong></p>\n<p><strong>并行关乎执行，表述的是程序的运行状态。</strong></p>\n<h3 id=\"Go-语言是如何支持并发的？\"><a href=\"#Go-语言是如何支持并发的？\" class=\"headerlink\" title=\"Go 语言是如何支持并发的？\"></a>Go 语言是如何支持并发的？</h3><p>上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。</p>\n<p>我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。</p>\n<h4 id=\"模型演化过程\"><a href=\"#模型演化过程\" class=\"headerlink\" title=\"模型演化过程\"></a>模型演化过程</h4><p>在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit\" target=\"_blank\" rel=\"noopener\"><strong>《Scalable Go Scheduler Design Doc》</strong></a>中指出了该模型在并发伸缩性方面的问题：</p>\n<blockquote>\n<ol>\n<li>所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。</li>\n<li>当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；</li>\n<li>M 用到的 <code>mCache</code> 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；</li>\n<li>由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。</li>\n</ol>\n</blockquote>\n<p>并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg\" alt=\"gpm-nino\"></p>\n<h4 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h4><p>那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：</p>\n<ul>\n<li>G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。</li>\n<li>P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 &gt;= P的数量），由用户设置的 GOMAXPROCS 决定。</li>\n<li>M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。</li>\n</ul>\n<p>接下来了解这套模型的基本调度，在调度过程中还有一个 <a href=\"http://supertech.csail.mit.edu/papers/steal.pdf\" target=\"_blank\" rel=\"noopener\"><em>work-stealing</em></a> 的算法：</p>\n<ul>\n<li>每个 P 维护一个本地队列；</li>\n<li>当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；</li>\n<li>当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；</li>\n<li>如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。</li>\n</ul>\n<p>Go 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。</p>\n<h3 id=\"Goroutine-调度器的深入\"><a href=\"#Goroutine-调度器的深入\" class=\"headerlink\" title=\"Goroutine 调度器的深入\"></a>Goroutine 调度器的深入</h3><p>让我们深入的了解一下 goroutine 调度器。</p>\n<h4 id=\"调度器解决了什么问题？\"><a href=\"#调度器解决了什么问题？\" class=\"headerlink\" title=\"调度器解决了什么问题？\"></a>调度器解决了什么问题？</h4><h5 id=\"阻塞问题\"><a href=\"#阻塞问题\" class=\"headerlink\" title=\"阻塞问题\"></a>阻塞问题</h5><blockquote>\n<p>如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。</p>\n</blockquote>\n<p>Go 在执行阻塞的系统调用时会调用 <code>entersyscallblock</code> ，然后通过 <code>handoffp</code> 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 <code>pidle</code> 链表，等待有需要时被取出。</p>\n<p>如果是调用的 <code>entersyscall</code>，会将 P 的状态置为 <code>_Psyscall</code>。监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现是 <code>_Psyscall</code> 状态，就会调用 <code>handoffp</code> 来释放。</p>\n<h5 id=\"抢占调度\"><a href=\"#抢占调度\" class=\"headerlink\" title=\"抢占调度\"></a>抢占调度</h5><p>在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。</p>\n<p>于是 Dmitry Vyukov 提出了<a href=\"https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit\" target=\"_blank\" rel=\"noopener\">《Go Preemptive Scheduler Design Doc》</a>, 并在1.2版本中引入了初级的抢占。</p>\n<p>监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现运行时间超出 <code>forcePreemptNS</code> 限制（10ms）的 P，就会通过 <code>preemptone</code> 发起抢占。</p>\n<h5 id=\"Goroutine-的负载均衡\"><a href=\"#Goroutine-的负载均衡\" class=\"headerlink\" title=\"Goroutine 的负载均衡\"></a>Goroutine 的负载均衡</h5><blockquote>\n<p>内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。</p>\n</blockquote>\n<p>这部分的实现是在 M 的启动函数 <code>mstart</code> 中 <code>schedule</code> 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。</p>\n<h4 id=\"调度器相关源码\"><a href=\"#调度器相关源码\" class=\"headerlink\" title=\"调度器相关源码\"></a>调度器相关源码</h4><p>调度器部分的代码主要集中在 <code>src/runtime/runtime2.go</code> 与 <code>src/runtime/proc.go</code> 这两个文件中。</p>\n<p>调度器的4个基本结构：g、m、p、schedt，都在 <code>runtime2.go</code> 中，<code>schedt</code> 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 <code>pidle</code>，空闲的 M 链表 <code>midle</code> 等等。</p>\n<p>调度器的具体实现函数都在 <code>proc.go</code> 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 <code>main</code> 中的代码放入 <code>main goroutine</code> 中运行，这时还会启动监控系统 <code>sysmon</code>。</p>\n<p>更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://talks.golang.org/2012/concurrency.slide#1\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a></p>\n<p><a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a></p>\n<p><a href=\"https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md\" target=\"_blank\" rel=\"noopener\">《go-under-the-hood》</a></p>\n<p><a href=\"https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/\" target=\"_blank\" rel=\"noopener\">《也谈goroutine调度器》</a></p>\n<p><a href=\"https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">《Goroutine浅析》</a></p>\n","site":{"data":{}},"excerpt":"<p>本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。</p>","more":"<h3 id=\"你真的了解并发吗？\"><a href=\"#你真的了解并发吗？\" class=\"headerlink\" title=\"你真的了解并发吗？\"></a>你真的了解并发吗？</h3><p>相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 <code>go</code> 关键字，就可以轻松的实现并发。但是，你真正的了解<strong>并发</strong>吗？</p>\n<p>并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指<strong>同一时刻的请求量</strong>，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。<em>高并发在这里还有个可能的概念是：<strong>同时应对许多请求所使用的技术</strong>，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。</em></p>\n<p>并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。</p>\n<p>下面，让我们看看 Go 语言编程中，“并发”这个词的概念。</p>\n<h3 id=\"Go-语言中的并发性\"><a href=\"#Go-语言中的并发性\" class=\"headerlink\" title=\"Go 语言中的并发性\"></a>Go 语言中的并发性</h3><p>Go 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：</p>\n<ul>\n<li>为什么要有并发？</li>\n<li>什么是并发？</li>\n<li>这个想法源自哪里？</li>\n<li>并发有什么好处？</li>\n<li>我该如何使用它？</li>\n</ul>\n<p>面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：<a href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a>，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。</p>\n<p>简单的总结一下并发在 Go 语言编程中的概念：</p>\n<p><strong>“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。</strong></p>\n<p>在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个<a href=\"https://play.golang.org/p/9U22NfrXeq\" target=\"_blank\" rel=\"noopener\">素数筛选程序</a>来理解 Go 的并发编程：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A concurrent prime sieve</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Generate</span><span class=\"params\">(ch <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; ; i++ &#123;</span><br><span class=\"line\">\t\tch &lt;- i <span class=\"comment\">// Send 'i' to channel 'ch'.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Copy the values from channel 'in' to channel 'out',</span></span><br><span class=\"line\"><span class=\"comment\">// removing those divisible by 'prime'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Filter</span><span class=\"params\">(in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, out <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, prime <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\ti := &lt;-in <span class=\"comment\">// Receive value from 'in'.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i%prime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tout &lt;- i <span class=\"comment\">// Send 'i' to 'out'.</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The prime sieve: Daisy-chain Filter processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// Create a new channel.</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> Generate(ch)      <span class=\"comment\">// Launch Generate goroutine.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tprime := &lt;-ch</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(prime, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t\tch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> Filter(ch, ch1, prime)</span><br><span class=\"line\">\t\tch = ch1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、<a href=\"https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes\" target=\"_blank\" rel=\"noopener\"><strong>通过通信共享内存</strong></a>的理念，而且非常优雅。</p>\n<p>在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。</p>\n<p>通过下面的 gif 动画能清晰的看到程序运行过程：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif\" alt=\"primesieve\"></p>\n<h3 id=\"并发不是并行\"><a href=\"#并发不是并行\" class=\"headerlink\" title=\"并发不是并行\"></a>并发不是并行</h3><h4 id=\"Go-的并行\"><a href=\"#Go-的并行\" class=\"headerlink\" title=\"Go 的并行\"></a>Go 的并行</h4><p>只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？</p>\n<p>我们需要明确一个观点：<strong>并发不是为了效率，并发的程序不一定可以并行。</strong>还是上面素数的例子，这段代码是并发的，但不可以并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。</p>\n<h4 id=\"正交概念\"><a href=\"#正交概念\" class=\"headerlink\" title=\"正交概念\"></a>正交概念</h4><p><em>正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。</em></p>\n<p>在广义概念上来讲，并发与并行是<strong>正交概念</strong>，对于 Go 语言的并发性来讲也是如此。</p>\n<h4 id=\"《Concurrency-is-not-Parallelism》\"><a href=\"#《Concurrency-is-not-Parallelism》\" class=\"headerlink\" title=\"《Concurrency is not Parallelism》\"></a>《Concurrency is not Parallelism》</h4><p>同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲<a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a>，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。</p>\n<p>这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：</p>\n<p><strong>并行是指同时能执行多个事情。</strong></p>\n<p><strong>并发关乎结构，是一种结构化程序的方式。</strong></p>\n<p><strong>并行关乎执行，表述的是程序的运行状态。</strong></p>\n<h3 id=\"Go-语言是如何支持并发的？\"><a href=\"#Go-语言是如何支持并发的？\" class=\"headerlink\" title=\"Go 语言是如何支持并发的？\"></a>Go 语言是如何支持并发的？</h3><p>上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。</p>\n<p>我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。</p>\n<h4 id=\"模型演化过程\"><a href=\"#模型演化过程\" class=\"headerlink\" title=\"模型演化过程\"></a>模型演化过程</h4><p>在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit\" target=\"_blank\" rel=\"noopener\"><strong>《Scalable Go Scheduler Design Doc》</strong></a>中指出了该模型在并发伸缩性方面的问题：</p>\n<blockquote>\n<ol>\n<li>所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。</li>\n<li>当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；</li>\n<li>M 用到的 <code>mCache</code> 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；</li>\n<li>由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。</li>\n</ol>\n</blockquote>\n<p>并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg\" alt=\"gpm-nino\"></p>\n<h4 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h4><p>那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：</p>\n<ul>\n<li>G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。</li>\n<li>P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 &gt;= P的数量），由用户设置的 GOMAXPROCS 决定。</li>\n<li>M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。</li>\n</ul>\n<p>接下来了解这套模型的基本调度，在调度过程中还有一个 <a href=\"http://supertech.csail.mit.edu/papers/steal.pdf\" target=\"_blank\" rel=\"noopener\"><em>work-stealing</em></a> 的算法：</p>\n<ul>\n<li>每个 P 维护一个本地队列；</li>\n<li>当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；</li>\n<li>当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；</li>\n<li>如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。</li>\n</ul>\n<p>Go 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。</p>\n<h3 id=\"Goroutine-调度器的深入\"><a href=\"#Goroutine-调度器的深入\" class=\"headerlink\" title=\"Goroutine 调度器的深入\"></a>Goroutine 调度器的深入</h3><p>让我们深入的了解一下 goroutine 调度器。</p>\n<h4 id=\"调度器解决了什么问题？\"><a href=\"#调度器解决了什么问题？\" class=\"headerlink\" title=\"调度器解决了什么问题？\"></a>调度器解决了什么问题？</h4><h5 id=\"阻塞问题\"><a href=\"#阻塞问题\" class=\"headerlink\" title=\"阻塞问题\"></a>阻塞问题</h5><blockquote>\n<p>如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。</p>\n</blockquote>\n<p>Go 在执行阻塞的系统调用时会调用 <code>entersyscallblock</code> ，然后通过 <code>handoffp</code> 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 <code>pidle</code> 链表，等待有需要时被取出。</p>\n<p>如果是调用的 <code>entersyscall</code>，会将 P 的状态置为 <code>_Psyscall</code>。监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现是 <code>_Psyscall</code> 状态，就会调用 <code>handoffp</code> 来释放。</p>\n<h5 id=\"抢占调度\"><a href=\"#抢占调度\" class=\"headerlink\" title=\"抢占调度\"></a>抢占调度</h5><p>在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。</p>\n<p>于是 Dmitry Vyukov 提出了<a href=\"https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit\" target=\"_blank\" rel=\"noopener\">《Go Preemptive Scheduler Design Doc》</a>, 并在1.2版本中引入了初级的抢占。</p>\n<p>监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现运行时间超出 <code>forcePreemptNS</code> 限制（10ms）的 P，就会通过 <code>preemptone</code> 发起抢占。</p>\n<h5 id=\"Goroutine-的负载均衡\"><a href=\"#Goroutine-的负载均衡\" class=\"headerlink\" title=\"Goroutine 的负载均衡\"></a>Goroutine 的负载均衡</h5><blockquote>\n<p>内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。</p>\n</blockquote>\n<p>这部分的实现是在 M 的启动函数 <code>mstart</code> 中 <code>schedule</code> 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。</p>\n<h4 id=\"调度器相关源码\"><a href=\"#调度器相关源码\" class=\"headerlink\" title=\"调度器相关源码\"></a>调度器相关源码</h4><p>调度器部分的代码主要集中在 <code>src/runtime/runtime2.go</code> 与 <code>src/runtime/proc.go</code> 这两个文件中。</p>\n<p>调度器的4个基本结构：g、m、p、schedt，都在 <code>runtime2.go</code> 中，<code>schedt</code> 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 <code>pidle</code>，空闲的 M 链表 <code>midle</code> 等等。</p>\n<p>调度器的具体实现函数都在 <code>proc.go</code> 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 <code>main</code> 中的代码放入 <code>main goroutine</code> 中运行，这时还会启动监控系统 <code>sysmon</code>。</p>\n<p>更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://talks.golang.org/2012/concurrency.slide#1\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a></p>\n<p><a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a></p>\n<p><a href=\"https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md\" target=\"_blank\" rel=\"noopener\">《go-under-the-hood》</a></p>\n<p><a href=\"https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/\" target=\"_blank\" rel=\"noopener\">《也谈goroutine调度器》</a></p>\n<p><a href=\"https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">《Goroutine浅析》</a></p>"},{"title":"Kubernetes 的 Dynamic Provisioning 实现","date":"2020-03-10T16:00:00.000Z","_content":"\n存储一直是容器运行的关键部分，Kubernetes 为此做了很多努力，从一开始的 Pod Volumes、PV(Persistent Volumes) 与 PVC(Persistent Volume Claim)，到 StorageClass 与 Dynamic Provisioning，再到现在 “out-of-tree” 的 CSI(Container Storage Interface)，Kubernetes 社区一直在演进存储的实现。\n\n前面基础的就不讲了，我们从 StorageClass 与 Dynamic Provisioning 开始了解。  \n\n<!--more-->  \n\n\n\n## 关于 StorageClass 与 Dynamic Provisioning\n\nStorageClass 为存储提供了“类”的概念，使得 PVC 可以申请不同类别的 PV，以满足用户不同质量、不同策略要求的存储需求。但仅仅是这样还不够，我们还需要手动去创建存储，创建 PV 并与之绑定。所以 StorageClass 还有一个功能就是**动态卷供应（Dynamic Provisioning）**，通过它，Kubernetes 可以根据用户的需求，自动创建其需要的存储。\n\n### 如何使用\n\n我们需要创建 StorageClass 对象，通过 `provisioner` 属性指定所用的动态供应的种类：\n\n```yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: standard\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\n```\n\n创建好以后，所有指定这个 StorageClass 的 PVC 都会动态分配 PV：\n\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: example\n  namespace: default\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: standard\n```\n\n当然，也需要些其他的配置，比如 aws-ebs 需要在启动参数中加入 `--cloud-provider=aws`。Glusterfs 需要在集群节点中预先安装好分布式存储等。具体请参考官方手册或 Google，这里不赘述了。\n\n### External provisioner\n\n官方提供了许多 Provisioner 的实现：AWSElasticBlockStore、AzureFile、Glusterfs [等等](https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner)，这些都是 “in-tree” 的，所以官方也在实验一些 external provisioner 的实现方式。在 **[kubernetes-incubator/external-storage](https://github.com/kubernetes-incubator/external-storage)** 这个仓库中，就有一些孵化中的项目，不过随着 CSI 的出现，应该已经孵死了。官方也正在将 “in-tree” 的存储实现迁移到 CSI 上。\n\n\n\n## 如何实现\n\n我们根据 external-storage 仓库中的项目，简单的分析一下如何自定义一个 Dynamic Provisioner。\n\n其实这个仓库中的项目都很简单，文件没有几个，代码也没有几行。这是因为它们都是基于官方社区的 [library](https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner#sig-storage-lib-external-provisioner) 实现的，它实现了 `Provisioner Controller` 的整个流程，包括监听、创建 PV 资源等，我们只需要实现 `Provisioner` 接口的两个方法就可以：\n\n```Go\n// Provisioner is an interface that creates templates for PersistentVolumes\n// and can create the volume as a new resource in the infrastructure provider.\n// It can also remove the volume it created from the underlying storage\n// provider.\ntype Provisioner interface {\n\t// Provision creates a volume i.e. the storage asset and returns a PV object\n\t// for the volume\n\tProvision(ProvisionOptions) (*v1.PersistentVolume, error)\n\t// Delete removes the storage asset that was created by Provision backing the\n\t// given PV. Does not delete the PV object itself.\n\t//\n\t// May return IgnoredError to indicate that the call has been ignored and no\n\t// action taken.\n\tDelete(*v1.PersistentVolume) error\n}\n```\n\n`Provision` 方法需要根据给定的数据，分配存储，响应 PV 对象。`Delete` 方法需要在 PV 删除时，也删除对应存储中的数据。\n\n我们选择仓库中的 nfs 项目来进行详细的分析，它不同于其他 client 类项目，它还维护了一份 nfs server，使得它可以不基于其他外部存储服务。可以在 `main` 函数中看到，通过 `runServer flag` 判断是否需要启动服务，默认为 `true`：\n\n```go\n\tif *runServer {\n\t\t......\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t// This blocks until server exits (presumably due to an error)\n\t\t\t\terr = server.Run(ganeshaLog, ganeshaPid, ganeshaConfig)\n\t\t\t\tif err != nil {\n\t\t\t\t\tglog.Errorf(\"NFS server Exited Unexpectedly with err: %v\", err)\n\t\t\t\t}\n\n\t\t\t\t// take a moment before trying to restart\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t}\n\t\t}()\n\t\t// Wait for NFS server to come up before continuing provisioner process\n\t\ttime.Sleep(5 * time.Second)\n\t}\n```\n\n随后通过 `Provisioner Controller` 的 `Run` 方法启动 Provisioner 服务：\n\n```go\n\t// Create the provisioner: it implements the Provisioner interface expected by\n\t// the controller\n\tnfsProvisioner := vol.NewNFSProvisioner(exportDir, clientset, outOfCluster, *useGanesha, ganeshaConfig, *enableXfsQuota, *serverHostname, *maxExports, *exportSubnet)\n\n\t// Start the provision controller which will dynamically provision NFS PVs\n\tpc := controller.NewProvisionController(\n\t\tclientset,\n\t\t*provisioner,\n\t\tnfsProvisioner,\n\t\tserverVersion.GitVersion,\n\t)\n\n\tpc.Run(wait.NeverStop)\n```\n\n`NewNFSProvisioner` 返回的是实现了 `Provisioner` 接口的结构体：\n\n```go\ntype nfsProvisioner struct {\n  ......\n}\n\nvar _ controller.Provisioner = &nfsProvisioner{}\n```\n\n接下来就看下如何实现的 `Provision` 方法：\n\n```go\n// options 里包含创建 pv 的数据，pvName、pvc、sc、selectedNode 等\nfunc (p *nfsProvisioner) Provision(options controller.ProvisionOptions) (*v1.PersistentVolume, error) {\n  // 在这里进行验证，创建目录等操作\n\tvolume, err := p.createVolume(options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tannotations := make(map[string]string)\n  ......\n\n\tpv := &v1.PersistentVolume{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        options.PVName,\n\t\t\tLabels:      map[string]string{},\n\t\t\tAnnotations: annotations,\n\t\t},\n\t\tSpec: v1.PersistentVolumeSpec{\n\t\t\tPersistentVolumeReclaimPolicy: *options.StorageClass.ReclaimPolicy,\n\t\t\tAccessModes:                   options.PVC.Spec.AccessModes,\n\t\t\tCapacity: v1.ResourceList{\n\t\t\t\tv1.ResourceName(v1.ResourceStorage): options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)],\n\t\t\t},\n\t\t\tPersistentVolumeSource: v1.PersistentVolumeSource{\n\t\t\t\tNFS: &v1.NFSVolumeSource{\n\t\t\t\t\tServer:   volume.server,\n\t\t\t\t\tPath:     volume.path,\n\t\t\t\t\tReadOnly: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tMountOptions: options.StorageClass.MountOptions,\n\t\t},\n\t}\n\n\treturn pv, nil\n}\n\nfunc (p *nfsProvisioner) createVolume(options controller.ProvisionOptions) (volume, error) {\n\t// 在这里验证剩余磁盘空间是否超出请求大小，只计算当前剩余\n  gid, rootSquash, mountOptions, err := p.validateOptions(options)\n\tif err != nil {\n\t\treturn volume{}, fmt.Errorf(\"error validating options for volume: %v\", err)\n\t}\n  ......\n  // 根据 pvc 创建目录\n\tpath := path.Join(p.exportDir, options.PVName)\n\n\terr = p.createDirectory(options.PVName, gid)\n\tif err != nil {\n\t\treturn volume{}, fmt.Errorf(\"error creating directory for volume: %v\", err)\n\t}\n  ......\n}\n\n\nfunc (p *nfsProvisioner) validateOptions(options controller.ProvisionOptions) (string, bool, string, error) {\n  ......\n\tvar stat syscall.Statfs_t\n\tif err := syscall.Statfs(p.exportDir, &stat); err != nil {\n\t\treturn \"\", false, \"\", fmt.Errorf(\"error calling statfs on %v: %v\", p.exportDir, err)\n\t}\n\tcapacity := options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]\n\trequestBytes := capacity.Value()\n\tavailable := int64(stat.Bavail) * int64(stat.Bsize)\n\tif requestBytes > available {\n\t\treturn \"\", false, \"\", fmt.Errorf(\"insufficient available space %v bytes to satisfy claim for %v bytes\", available, requestBytes)\n\t}\n\n\treturn gid, rootSquash, mountOptions, nil\n}\n```\n\n然后是 `Delete` 方法的实现：\n\n```go\nfunc (p *nfsProvisioner) Delete(volume *v1.PersistentVolume) error {\n  ......\n  // pv 删除后，删除对应的目录\n\terr = p.deleteDirectory(volume)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error deleting volume's backing path: %v\", err)\n\t}\n  ......\n\treturn nil\n}\n```\n\n这里只是简单的讲解下 `Provisioner` 的实现，省略了其他一些比如 `xfs quota` 等操作，有兴趣的可以去项目中看一下。顺便提一下，这个项目虽然部署了 nfs server，但没有部署成分布式存储，局限性很大，毕竟只是实验中的项目，生产环境慎用。\n\n\n\n## 后记\n\n碰巧在项目中接触到了 nfs 这个 Provisioner，并且经过测试及源码分析验证了这个项目不可用。经过查阅学习之后写下了这篇文章，算是为以后学习 CSI 作准备吧。\n\n","source":"_posts/Dynamic-Provisioning.md","raw":"---\ntitle: Kubernetes 的 Dynamic Provisioning 实现\ndate: 2020/3/11 00:00:00\n---\n\n存储一直是容器运行的关键部分，Kubernetes 为此做了很多努力，从一开始的 Pod Volumes、PV(Persistent Volumes) 与 PVC(Persistent Volume Claim)，到 StorageClass 与 Dynamic Provisioning，再到现在 “out-of-tree” 的 CSI(Container Storage Interface)，Kubernetes 社区一直在演进存储的实现。\n\n前面基础的就不讲了，我们从 StorageClass 与 Dynamic Provisioning 开始了解。  \n\n<!--more-->  \n\n\n\n## 关于 StorageClass 与 Dynamic Provisioning\n\nStorageClass 为存储提供了“类”的概念，使得 PVC 可以申请不同类别的 PV，以满足用户不同质量、不同策略要求的存储需求。但仅仅是这样还不够，我们还需要手动去创建存储，创建 PV 并与之绑定。所以 StorageClass 还有一个功能就是**动态卷供应（Dynamic Provisioning）**，通过它，Kubernetes 可以根据用户的需求，自动创建其需要的存储。\n\n### 如何使用\n\n我们需要创建 StorageClass 对象，通过 `provisioner` 属性指定所用的动态供应的种类：\n\n```yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: standard\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\n```\n\n创建好以后，所有指定这个 StorageClass 的 PVC 都会动态分配 PV：\n\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: example\n  namespace: default\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: standard\n```\n\n当然，也需要些其他的配置，比如 aws-ebs 需要在启动参数中加入 `--cloud-provider=aws`。Glusterfs 需要在集群节点中预先安装好分布式存储等。具体请参考官方手册或 Google，这里不赘述了。\n\n### External provisioner\n\n官方提供了许多 Provisioner 的实现：AWSElasticBlockStore、AzureFile、Glusterfs [等等](https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner)，这些都是 “in-tree” 的，所以官方也在实验一些 external provisioner 的实现方式。在 **[kubernetes-incubator/external-storage](https://github.com/kubernetes-incubator/external-storage)** 这个仓库中，就有一些孵化中的项目，不过随着 CSI 的出现，应该已经孵死了。官方也正在将 “in-tree” 的存储实现迁移到 CSI 上。\n\n\n\n## 如何实现\n\n我们根据 external-storage 仓库中的项目，简单的分析一下如何自定义一个 Dynamic Provisioner。\n\n其实这个仓库中的项目都很简单，文件没有几个，代码也没有几行。这是因为它们都是基于官方社区的 [library](https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner#sig-storage-lib-external-provisioner) 实现的，它实现了 `Provisioner Controller` 的整个流程，包括监听、创建 PV 资源等，我们只需要实现 `Provisioner` 接口的两个方法就可以：\n\n```Go\n// Provisioner is an interface that creates templates for PersistentVolumes\n// and can create the volume as a new resource in the infrastructure provider.\n// It can also remove the volume it created from the underlying storage\n// provider.\ntype Provisioner interface {\n\t// Provision creates a volume i.e. the storage asset and returns a PV object\n\t// for the volume\n\tProvision(ProvisionOptions) (*v1.PersistentVolume, error)\n\t// Delete removes the storage asset that was created by Provision backing the\n\t// given PV. Does not delete the PV object itself.\n\t//\n\t// May return IgnoredError to indicate that the call has been ignored and no\n\t// action taken.\n\tDelete(*v1.PersistentVolume) error\n}\n```\n\n`Provision` 方法需要根据给定的数据，分配存储，响应 PV 对象。`Delete` 方法需要在 PV 删除时，也删除对应存储中的数据。\n\n我们选择仓库中的 nfs 项目来进行详细的分析，它不同于其他 client 类项目，它还维护了一份 nfs server，使得它可以不基于其他外部存储服务。可以在 `main` 函数中看到，通过 `runServer flag` 判断是否需要启动服务，默认为 `true`：\n\n```go\n\tif *runServer {\n\t\t......\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t// This blocks until server exits (presumably due to an error)\n\t\t\t\terr = server.Run(ganeshaLog, ganeshaPid, ganeshaConfig)\n\t\t\t\tif err != nil {\n\t\t\t\t\tglog.Errorf(\"NFS server Exited Unexpectedly with err: %v\", err)\n\t\t\t\t}\n\n\t\t\t\t// take a moment before trying to restart\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t}\n\t\t}()\n\t\t// Wait for NFS server to come up before continuing provisioner process\n\t\ttime.Sleep(5 * time.Second)\n\t}\n```\n\n随后通过 `Provisioner Controller` 的 `Run` 方法启动 Provisioner 服务：\n\n```go\n\t// Create the provisioner: it implements the Provisioner interface expected by\n\t// the controller\n\tnfsProvisioner := vol.NewNFSProvisioner(exportDir, clientset, outOfCluster, *useGanesha, ganeshaConfig, *enableXfsQuota, *serverHostname, *maxExports, *exportSubnet)\n\n\t// Start the provision controller which will dynamically provision NFS PVs\n\tpc := controller.NewProvisionController(\n\t\tclientset,\n\t\t*provisioner,\n\t\tnfsProvisioner,\n\t\tserverVersion.GitVersion,\n\t)\n\n\tpc.Run(wait.NeverStop)\n```\n\n`NewNFSProvisioner` 返回的是实现了 `Provisioner` 接口的结构体：\n\n```go\ntype nfsProvisioner struct {\n  ......\n}\n\nvar _ controller.Provisioner = &nfsProvisioner{}\n```\n\n接下来就看下如何实现的 `Provision` 方法：\n\n```go\n// options 里包含创建 pv 的数据，pvName、pvc、sc、selectedNode 等\nfunc (p *nfsProvisioner) Provision(options controller.ProvisionOptions) (*v1.PersistentVolume, error) {\n  // 在这里进行验证，创建目录等操作\n\tvolume, err := p.createVolume(options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tannotations := make(map[string]string)\n  ......\n\n\tpv := &v1.PersistentVolume{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        options.PVName,\n\t\t\tLabels:      map[string]string{},\n\t\t\tAnnotations: annotations,\n\t\t},\n\t\tSpec: v1.PersistentVolumeSpec{\n\t\t\tPersistentVolumeReclaimPolicy: *options.StorageClass.ReclaimPolicy,\n\t\t\tAccessModes:                   options.PVC.Spec.AccessModes,\n\t\t\tCapacity: v1.ResourceList{\n\t\t\t\tv1.ResourceName(v1.ResourceStorage): options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)],\n\t\t\t},\n\t\t\tPersistentVolumeSource: v1.PersistentVolumeSource{\n\t\t\t\tNFS: &v1.NFSVolumeSource{\n\t\t\t\t\tServer:   volume.server,\n\t\t\t\t\tPath:     volume.path,\n\t\t\t\t\tReadOnly: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tMountOptions: options.StorageClass.MountOptions,\n\t\t},\n\t}\n\n\treturn pv, nil\n}\n\nfunc (p *nfsProvisioner) createVolume(options controller.ProvisionOptions) (volume, error) {\n\t// 在这里验证剩余磁盘空间是否超出请求大小，只计算当前剩余\n  gid, rootSquash, mountOptions, err := p.validateOptions(options)\n\tif err != nil {\n\t\treturn volume{}, fmt.Errorf(\"error validating options for volume: %v\", err)\n\t}\n  ......\n  // 根据 pvc 创建目录\n\tpath := path.Join(p.exportDir, options.PVName)\n\n\terr = p.createDirectory(options.PVName, gid)\n\tif err != nil {\n\t\treturn volume{}, fmt.Errorf(\"error creating directory for volume: %v\", err)\n\t}\n  ......\n}\n\n\nfunc (p *nfsProvisioner) validateOptions(options controller.ProvisionOptions) (string, bool, string, error) {\n  ......\n\tvar stat syscall.Statfs_t\n\tif err := syscall.Statfs(p.exportDir, &stat); err != nil {\n\t\treturn \"\", false, \"\", fmt.Errorf(\"error calling statfs on %v: %v\", p.exportDir, err)\n\t}\n\tcapacity := options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]\n\trequestBytes := capacity.Value()\n\tavailable := int64(stat.Bavail) * int64(stat.Bsize)\n\tif requestBytes > available {\n\t\treturn \"\", false, \"\", fmt.Errorf(\"insufficient available space %v bytes to satisfy claim for %v bytes\", available, requestBytes)\n\t}\n\n\treturn gid, rootSquash, mountOptions, nil\n}\n```\n\n然后是 `Delete` 方法的实现：\n\n```go\nfunc (p *nfsProvisioner) Delete(volume *v1.PersistentVolume) error {\n  ......\n  // pv 删除后，删除对应的目录\n\terr = p.deleteDirectory(volume)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error deleting volume's backing path: %v\", err)\n\t}\n  ......\n\treturn nil\n}\n```\n\n这里只是简单的讲解下 `Provisioner` 的实现，省略了其他一些比如 `xfs quota` 等操作，有兴趣的可以去项目中看一下。顺便提一下，这个项目虽然部署了 nfs server，但没有部署成分布式存储，局限性很大，毕竟只是实验中的项目，生产环境慎用。\n\n\n\n## 后记\n\n碰巧在项目中接触到了 nfs 这个 Provisioner，并且经过测试及源码分析验证了这个项目不可用。经过查阅学习之后写下了这篇文章，算是为以后学习 CSI 作准备吧。\n\n","slug":"Dynamic-Provisioning","published":1,"updated":"2020-07-23T00:39:51.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34e9x0006cyzeegy3wkei","content":"<p>存储一直是容器运行的关键部分，Kubernetes 为此做了很多努力，从一开始的 Pod Volumes、PV(Persistent Volumes) 与 PVC(Persistent Volume Claim)，到 StorageClass 与 Dynamic Provisioning，再到现在 “out-of-tree” 的 CSI(Container Storage Interface)，Kubernetes 社区一直在演进存储的实现。</p>\n<p>前面基础的就不讲了，我们从 StorageClass 与 Dynamic Provisioning 开始了解。  </p>\n<a id=\"more\"></a>  \n<h2 id=\"关于-StorageClass-与-Dynamic-Provisioning\"><a href=\"#关于-StorageClass-与-Dynamic-Provisioning\" class=\"headerlink\" title=\"关于 StorageClass 与 Dynamic Provisioning\"></a>关于 StorageClass 与 Dynamic Provisioning</h2><p>StorageClass 为存储提供了“类”的概念，使得 PVC 可以申请不同类别的 PV，以满足用户不同质量、不同策略要求的存储需求。但仅仅是这样还不够，我们还需要手动去创建存储，创建 PV 并与之绑定。所以 StorageClass 还有一个功能就是<strong>动态卷供应（Dynamic Provisioning）</strong>，通过它，Kubernetes 可以根据用户的需求，自动创建其需要的存储。</p>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><p>我们需要创建 StorageClass 对象，通过 <code>provisioner</code> 属性指定所用的动态供应的种类：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> storage.k8s.io/v1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> StorageClass</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> standard</span><br><span class=\"line\"><span class=\"attr\">provisioner:</span> kubernetes.io/aws-ebs</span><br><span class=\"line\"><span class=\"attr\">parameters:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> gp2</span><br></pre></td></tr></table></figure>\n<p>创建好以后，所有指定这个 StorageClass 的 PVC 都会动态分配 PV：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> v1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> PersistentVolumeClaim</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> example</span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> default</span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  accessModes:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> ReadWriteOnce</span><br><span class=\"line\"><span class=\"attr\">  resources:</span></span><br><span class=\"line\"><span class=\"attr\">    requests:</span></span><br><span class=\"line\"><span class=\"attr\">      storage:</span> <span class=\"number\">1</span>Gi</span><br><span class=\"line\"><span class=\"attr\">  storageClassName:</span> standard</span><br></pre></td></tr></table></figure>\n<p>当然，也需要些其他的配置，比如 aws-ebs 需要在启动参数中加入 <code>--cloud-provider=aws</code>。Glusterfs 需要在集群节点中预先安装好分布式存储等。具体请参考官方手册或 Google，这里不赘述了。</p>\n<h3 id=\"External-provisioner\"><a href=\"#External-provisioner\" class=\"headerlink\" title=\"External provisioner\"></a>External provisioner</h3><p>官方提供了许多 Provisioner 的实现：AWSElasticBlockStore、AzureFile、Glusterfs <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner\" target=\"_blank\" rel=\"noopener\">等等</a>，这些都是 “in-tree” 的，所以官方也在实验一些 external provisioner 的实现方式。在 <strong><a href=\"https://github.com/kubernetes-incubator/external-storage\" target=\"_blank\" rel=\"noopener\">kubernetes-incubator/external-storage</a></strong> 这个仓库中，就有一些孵化中的项目，不过随着 CSI 的出现，应该已经孵死了。官方也正在将 “in-tree” 的存储实现迁移到 CSI 上。</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>我们根据 external-storage 仓库中的项目，简单的分析一下如何自定义一个 Dynamic Provisioner。</p>\n<p>其实这个仓库中的项目都很简单，文件没有几个，代码也没有几行。这是因为它们都是基于官方社区的 <a href=\"https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner#sig-storage-lib-external-provisioner\" target=\"_blank\" rel=\"noopener\">library</a> 实现的，它实现了 <code>Provisioner Controller</code> 的整个流程，包括监听、创建 PV 资源等，我们只需要实现 <code>Provisioner</code> 接口的两个方法就可以：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Provisioner is an interface that creates templates for PersistentVolumes</span></span><br><span class=\"line\"><span class=\"comment\">// and can create the volume as a new resource in the infrastructure provider.</span></span><br><span class=\"line\"><span class=\"comment\">// It can also remove the volume it created from the underlying storage</span></span><br><span class=\"line\"><span class=\"comment\">// provider.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Provisioner <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Provision creates a volume i.e. the storage asset and returns a PV object</span></span><br><span class=\"line\">\t<span class=\"comment\">// for the volume</span></span><br><span class=\"line\">\tProvision(ProvisionOptions) (*v1.PersistentVolume, error)</span><br><span class=\"line\">\t<span class=\"comment\">// Delete removes the storage asset that was created by Provision backing the</span></span><br><span class=\"line\">\t<span class=\"comment\">// given PV. Does not delete the PV object itself.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// May return IgnoredError to indicate that the call has been ignored and no</span></span><br><span class=\"line\">\t<span class=\"comment\">// action taken.</span></span><br><span class=\"line\">\tDelete(*v1.PersistentVolume) error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Provision</code> 方法需要根据给定的数据，分配存储，响应 PV 对象。<code>Delete</code> 方法需要在 PV 删除时，也删除对应存储中的数据。</p>\n<p>我们选择仓库中的 nfs 项目来进行详细的分析，它不同于其他 client 类项目，它还维护了一份 nfs server，使得它可以不基于其他外部存储服务。可以在 <code>main</code> 函数中看到，通过 <code>runServer flag</code> 判断是否需要启动服务，默认为 <code>true</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> *runServer &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// This blocks until server exits (presumably due to an error)</span></span><br><span class=\"line\">\t\t\terr = server.Run(ganeshaLog, ganeshaPid, ganeshaConfig)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tglog.Errorf(<span class=\"string\">\"NFS server Exited Unexpectedly with err: %v\"</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// take a moment before trying to restart</span></span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// Wait for NFS server to come up before continuing provisioner process</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>随后通过 <code>Provisioner Controller</code> 的 <code>Run</code> 方法启动 Provisioner 服务：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create the provisioner: it implements the Provisioner interface expected by</span></span><br><span class=\"line\"><span class=\"comment\">// the controller</span></span><br><span class=\"line\">nfsProvisioner := vol.NewNFSProvisioner(exportDir, clientset, outOfCluster, *useGanesha, ganeshaConfig, *enableXfsQuota, *serverHostname, *maxExports, *exportSubnet)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Start the provision controller which will dynamically provision NFS PVs</span></span><br><span class=\"line\">pc := controller.NewProvisionController(</span><br><span class=\"line\">\tclientset,</span><br><span class=\"line\">\t*provisioner,</span><br><span class=\"line\">\tnfsProvisioner,</span><br><span class=\"line\">\tserverVersion.GitVersion,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">pc.Run(wait.NeverStop)</span><br></pre></td></tr></table></figure>\n<p><code>NewNFSProvisioner</code> 返回的是实现了 <code>Provisioner</code> 接口的结构体：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> nfsProvisioner <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ controller.Provisioner = &amp;nfsProvisioner&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就看下如何实现的 <code>Provision</code> 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// options 里包含创建 pv 的数据，pvName、pvc、sc、selectedNode 等</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">Provision</span><span class=\"params\">(options controller.ProvisionOptions)</span> <span class=\"params\">(*v1.PersistentVolume, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在这里进行验证，创建目录等操作</span></span><br><span class=\"line\">\tvolume, err := p.createVolume(options)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tannotations := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">\tpv := &amp;v1.PersistentVolume&#123;</span><br><span class=\"line\">\t\tObjectMeta: metav1.ObjectMeta&#123;</span><br><span class=\"line\">\t\t\tName:        options.PVName,</span><br><span class=\"line\">\t\t\tLabels:      <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;&#125;,</span><br><span class=\"line\">\t\t\tAnnotations: annotations,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tSpec: v1.PersistentVolumeSpec&#123;</span><br><span class=\"line\">\t\t\tPersistentVolumeReclaimPolicy: *options.StorageClass.ReclaimPolicy,</span><br><span class=\"line\">\t\t\tAccessModes:                   options.PVC.Spec.AccessModes,</span><br><span class=\"line\">\t\t\tCapacity: v1.ResourceList&#123;</span><br><span class=\"line\">\t\t\t\tv1.ResourceName(v1.ResourceStorage): options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)],</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tPersistentVolumeSource: v1.PersistentVolumeSource&#123;</span><br><span class=\"line\">\t\t\t\tNFS: &amp;v1.NFSVolumeSource&#123;</span><br><span class=\"line\">\t\t\t\t\tServer:   volume.server,</span><br><span class=\"line\">\t\t\t\t\tPath:     volume.path,</span><br><span class=\"line\">\t\t\t\t\tReadOnly: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tMountOptions: options.StorageClass.MountOptions,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pv, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">createVolume</span><span class=\"params\">(options controller.ProvisionOptions)</span> <span class=\"params\">(volume, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 在这里验证剩余磁盘空间是否超出请求大小，只计算当前剩余</span></span><br><span class=\"line\">  gid, rootSquash, mountOptions, err := p.validateOptions(options)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> volume&#123;&#125;, fmt.Errorf(<span class=\"string\">\"error validating options for volume: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"comment\">// 根据 pvc 创建目录</span></span><br><span class=\"line\">\tpath := path.Join(p.exportDir, options.PVName)</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = p.createDirectory(options.PVName, gid)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> volume&#123;&#125;, fmt.Errorf(<span class=\"string\">\"error creating directory for volume: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">validateOptions</span><span class=\"params\">(options controller.ProvisionOptions)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">bool</span>, <span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> stat syscall.Statfs_t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := syscall.Statfs(p.exportDir, &amp;stat); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>, <span class=\"literal\">false</span>, <span class=\"string\">\"\"</span>, fmt.Errorf(<span class=\"string\">\"error calling statfs on %v: %v\"</span>, p.exportDir, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcapacity := options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]</span><br><span class=\"line\">\trequestBytes := capacity.Value()</span><br><span class=\"line\">\tavailable := <span class=\"keyword\">int64</span>(stat.Bavail) * <span class=\"keyword\">int64</span>(stat.Bsize)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> requestBytes &gt; available &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>, <span class=\"literal\">false</span>, <span class=\"string\">\"\"</span>, fmt.Errorf(<span class=\"string\">\"insufficient available space %v bytes to satisfy claim for %v bytes\"</span>, available, requestBytes)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gid, rootSquash, mountOptions, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是 <code>Delete</code> 方法的实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">Delete</span><span class=\"params\">(volume *v1.PersistentVolume)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"comment\">// pv 删除后，删除对应的目录</span></span><br><span class=\"line\">\terr = p.deleteDirectory(volume)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"error deleting volume's backing path: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只是简单的讲解下 <code>Provisioner</code> 的实现，省略了其他一些比如 <code>xfs quota</code> 等操作，有兴趣的可以去项目中看一下。顺便提一下，这个项目虽然部署了 nfs server，但没有部署成分布式存储，局限性很大，毕竟只是实验中的项目，生产环境慎用。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>碰巧在项目中接触到了 nfs 这个 Provisioner，并且经过测试及源码分析验证了这个项目不可用。经过查阅学习之后写下了这篇文章，算是为以后学习 CSI 作准备吧。</p>\n","site":{"data":{}},"excerpt":"<p>存储一直是容器运行的关键部分，Kubernetes 为此做了很多努力，从一开始的 Pod Volumes、PV(Persistent Volumes) 与 PVC(Persistent Volume Claim)，到 StorageClass 与 Dynamic Provisioning，再到现在 “out-of-tree” 的 CSI(Container Storage Interface)，Kubernetes 社区一直在演进存储的实现。</p>\n<p>前面基础的就不讲了，我们从 StorageClass 与 Dynamic Provisioning 开始了解。  </p>","more":"<h2 id=\"关于-StorageClass-与-Dynamic-Provisioning\"><a href=\"#关于-StorageClass-与-Dynamic-Provisioning\" class=\"headerlink\" title=\"关于 StorageClass 与 Dynamic Provisioning\"></a>关于 StorageClass 与 Dynamic Provisioning</h2><p>StorageClass 为存储提供了“类”的概念，使得 PVC 可以申请不同类别的 PV，以满足用户不同质量、不同策略要求的存储需求。但仅仅是这样还不够，我们还需要手动去创建存储，创建 PV 并与之绑定。所以 StorageClass 还有一个功能就是<strong>动态卷供应（Dynamic Provisioning）</strong>，通过它，Kubernetes 可以根据用户的需求，自动创建其需要的存储。</p>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><p>我们需要创建 StorageClass 对象，通过 <code>provisioner</code> 属性指定所用的动态供应的种类：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> storage.k8s.io/v1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> StorageClass</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> standard</span><br><span class=\"line\"><span class=\"attr\">provisioner:</span> kubernetes.io/aws-ebs</span><br><span class=\"line\"><span class=\"attr\">parameters:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> gp2</span><br></pre></td></tr></table></figure>\n<p>创建好以后，所有指定这个 StorageClass 的 PVC 都会动态分配 PV：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> v1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> PersistentVolumeClaim</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> example</span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> default</span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  accessModes:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> ReadWriteOnce</span><br><span class=\"line\"><span class=\"attr\">  resources:</span></span><br><span class=\"line\"><span class=\"attr\">    requests:</span></span><br><span class=\"line\"><span class=\"attr\">      storage:</span> <span class=\"number\">1</span>Gi</span><br><span class=\"line\"><span class=\"attr\">  storageClassName:</span> standard</span><br></pre></td></tr></table></figure>\n<p>当然，也需要些其他的配置，比如 aws-ebs 需要在启动参数中加入 <code>--cloud-provider=aws</code>。Glusterfs 需要在集群节点中预先安装好分布式存储等。具体请参考官方手册或 Google，这里不赘述了。</p>\n<h3 id=\"External-provisioner\"><a href=\"#External-provisioner\" class=\"headerlink\" title=\"External provisioner\"></a>External provisioner</h3><p>官方提供了许多 Provisioner 的实现：AWSElasticBlockStore、AzureFile、Glusterfs <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner\" target=\"_blank\" rel=\"noopener\">等等</a>，这些都是 “in-tree” 的，所以官方也在实验一些 external provisioner 的实现方式。在 <strong><a href=\"https://github.com/kubernetes-incubator/external-storage\" target=\"_blank\" rel=\"noopener\">kubernetes-incubator/external-storage</a></strong> 这个仓库中，就有一些孵化中的项目，不过随着 CSI 的出现，应该已经孵死了。官方也正在将 “in-tree” 的存储实现迁移到 CSI 上。</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>我们根据 external-storage 仓库中的项目，简单的分析一下如何自定义一个 Dynamic Provisioner。</p>\n<p>其实这个仓库中的项目都很简单，文件没有几个，代码也没有几行。这是因为它们都是基于官方社区的 <a href=\"https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner#sig-storage-lib-external-provisioner\" target=\"_blank\" rel=\"noopener\">library</a> 实现的，它实现了 <code>Provisioner Controller</code> 的整个流程，包括监听、创建 PV 资源等，我们只需要实现 <code>Provisioner</code> 接口的两个方法就可以：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Provisioner is an interface that creates templates for PersistentVolumes</span></span><br><span class=\"line\"><span class=\"comment\">// and can create the volume as a new resource in the infrastructure provider.</span></span><br><span class=\"line\"><span class=\"comment\">// It can also remove the volume it created from the underlying storage</span></span><br><span class=\"line\"><span class=\"comment\">// provider.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Provisioner <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Provision creates a volume i.e. the storage asset and returns a PV object</span></span><br><span class=\"line\">\t<span class=\"comment\">// for the volume</span></span><br><span class=\"line\">\tProvision(ProvisionOptions) (*v1.PersistentVolume, error)</span><br><span class=\"line\">\t<span class=\"comment\">// Delete removes the storage asset that was created by Provision backing the</span></span><br><span class=\"line\">\t<span class=\"comment\">// given PV. Does not delete the PV object itself.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// May return IgnoredError to indicate that the call has been ignored and no</span></span><br><span class=\"line\">\t<span class=\"comment\">// action taken.</span></span><br><span class=\"line\">\tDelete(*v1.PersistentVolume) error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Provision</code> 方法需要根据给定的数据，分配存储，响应 PV 对象。<code>Delete</code> 方法需要在 PV 删除时，也删除对应存储中的数据。</p>\n<p>我们选择仓库中的 nfs 项目来进行详细的分析，它不同于其他 client 类项目，它还维护了一份 nfs server，使得它可以不基于其他外部存储服务。可以在 <code>main</code> 函数中看到，通过 <code>runServer flag</code> 判断是否需要启动服务，默认为 <code>true</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> *runServer &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// This blocks until server exits (presumably due to an error)</span></span><br><span class=\"line\">\t\t\terr = server.Run(ganeshaLog, ganeshaPid, ganeshaConfig)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tglog.Errorf(<span class=\"string\">\"NFS server Exited Unexpectedly with err: %v\"</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// take a moment before trying to restart</span></span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// Wait for NFS server to come up before continuing provisioner process</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>随后通过 <code>Provisioner Controller</code> 的 <code>Run</code> 方法启动 Provisioner 服务：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create the provisioner: it implements the Provisioner interface expected by</span></span><br><span class=\"line\"><span class=\"comment\">// the controller</span></span><br><span class=\"line\">nfsProvisioner := vol.NewNFSProvisioner(exportDir, clientset, outOfCluster, *useGanesha, ganeshaConfig, *enableXfsQuota, *serverHostname, *maxExports, *exportSubnet)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Start the provision controller which will dynamically provision NFS PVs</span></span><br><span class=\"line\">pc := controller.NewProvisionController(</span><br><span class=\"line\">\tclientset,</span><br><span class=\"line\">\t*provisioner,</span><br><span class=\"line\">\tnfsProvisioner,</span><br><span class=\"line\">\tserverVersion.GitVersion,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">pc.Run(wait.NeverStop)</span><br></pre></td></tr></table></figure>\n<p><code>NewNFSProvisioner</code> 返回的是实现了 <code>Provisioner</code> 接口的结构体：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> nfsProvisioner <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ controller.Provisioner = &amp;nfsProvisioner&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就看下如何实现的 <code>Provision</code> 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// options 里包含创建 pv 的数据，pvName、pvc、sc、selectedNode 等</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">Provision</span><span class=\"params\">(options controller.ProvisionOptions)</span> <span class=\"params\">(*v1.PersistentVolume, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在这里进行验证，创建目录等操作</span></span><br><span class=\"line\">\tvolume, err := p.createVolume(options)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tannotations := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">\tpv := &amp;v1.PersistentVolume&#123;</span><br><span class=\"line\">\t\tObjectMeta: metav1.ObjectMeta&#123;</span><br><span class=\"line\">\t\t\tName:        options.PVName,</span><br><span class=\"line\">\t\t\tLabels:      <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;&#125;,</span><br><span class=\"line\">\t\t\tAnnotations: annotations,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tSpec: v1.PersistentVolumeSpec&#123;</span><br><span class=\"line\">\t\t\tPersistentVolumeReclaimPolicy: *options.StorageClass.ReclaimPolicy,</span><br><span class=\"line\">\t\t\tAccessModes:                   options.PVC.Spec.AccessModes,</span><br><span class=\"line\">\t\t\tCapacity: v1.ResourceList&#123;</span><br><span class=\"line\">\t\t\t\tv1.ResourceName(v1.ResourceStorage): options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)],</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tPersistentVolumeSource: v1.PersistentVolumeSource&#123;</span><br><span class=\"line\">\t\t\t\tNFS: &amp;v1.NFSVolumeSource&#123;</span><br><span class=\"line\">\t\t\t\t\tServer:   volume.server,</span><br><span class=\"line\">\t\t\t\t\tPath:     volume.path,</span><br><span class=\"line\">\t\t\t\t\tReadOnly: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tMountOptions: options.StorageClass.MountOptions,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pv, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">createVolume</span><span class=\"params\">(options controller.ProvisionOptions)</span> <span class=\"params\">(volume, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 在这里验证剩余磁盘空间是否超出请求大小，只计算当前剩余</span></span><br><span class=\"line\">  gid, rootSquash, mountOptions, err := p.validateOptions(options)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> volume&#123;&#125;, fmt.Errorf(<span class=\"string\">\"error validating options for volume: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"comment\">// 根据 pvc 创建目录</span></span><br><span class=\"line\">\tpath := path.Join(p.exportDir, options.PVName)</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = p.createDirectory(options.PVName, gid)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> volume&#123;&#125;, fmt.Errorf(<span class=\"string\">\"error creating directory for volume: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">validateOptions</span><span class=\"params\">(options controller.ProvisionOptions)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">bool</span>, <span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> stat syscall.Statfs_t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := syscall.Statfs(p.exportDir, &amp;stat); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>, <span class=\"literal\">false</span>, <span class=\"string\">\"\"</span>, fmt.Errorf(<span class=\"string\">\"error calling statfs on %v: %v\"</span>, p.exportDir, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcapacity := options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]</span><br><span class=\"line\">\trequestBytes := capacity.Value()</span><br><span class=\"line\">\tavailable := <span class=\"keyword\">int64</span>(stat.Bavail) * <span class=\"keyword\">int64</span>(stat.Bsize)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> requestBytes &gt; available &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>, <span class=\"literal\">false</span>, <span class=\"string\">\"\"</span>, fmt.Errorf(<span class=\"string\">\"insufficient available space %v bytes to satisfy claim for %v bytes\"</span>, available, requestBytes)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gid, rootSquash, mountOptions, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是 <code>Delete</code> 方法的实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *nfsProvisioner)</span> <span class=\"title\">Delete</span><span class=\"params\">(volume *v1.PersistentVolume)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"comment\">// pv 删除后，删除对应的目录</span></span><br><span class=\"line\">\terr = p.deleteDirectory(volume)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"error deleting volume's backing path: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只是简单的讲解下 <code>Provisioner</code> 的实现，省略了其他一些比如 <code>xfs quota</code> 等操作，有兴趣的可以去项目中看一下。顺便提一下，这个项目虽然部署了 nfs server，但没有部署成分布式存储，局限性很大，毕竟只是实验中的项目，生产环境慎用。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>碰巧在项目中接触到了 nfs 这个 Provisioner，并且经过测试及源码分析验证了这个项目不可用。经过查阅学习之后写下了这篇文章，算是为以后学习 CSI 作准备吧。</p>"},{"title":"JSON Schema","date":"2018-12-01T11:18:17.000Z","_content":"\n**JSON Schema 详解：未完待续**\n\n<!--more-->  \n\n## 第一篇：了解 JSON\n\n#### 介绍\n\nJSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《[Standard ECMA-262 3rd Edition - December 1999](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)》的一个子集，而后成为写入 RFC 文档：[RFC 4627](https://tools.ietf.org/html/rfc4627)，最新的 RFC 标准为：[RFC 8259](https://tools.ietf.org/html/rfc8259)。\n\nJSON 的官方 MIME 类型是 `application/json`，文件扩展名是 `.json`。\n\n#### 类型\n\n**两种结构化类型**：\n\n* Object：`名称/值`的集合（A collection of name/value pairs），在不同的语言中，被理解为 `object`，`record`，`struct`，`dictionary`，`hash table` 等等。\n    * 使用大括号`{`，`}`包裹`名称/值`的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用`:`分隔。`名称/值`之间使用`,`分隔。\n    * 格式示例：`{\"example\":\"string\"}`。\n* Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 `array`。\n    * 使用中括号`[`，`]`包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。\n    * 格式示例：`[0,\"1\",null,false,true,{},[]]`。\n\n**四种基本类型**：\n\n* 字符串（string）\n    * 字符串是 Unicode 字符组成的集合，使用双引号包裹（`\"`），反斜杠转义（`\\`）。\n    * 与 C 或 Java 的字符串相似。\n* 数值（number）\n    * 使用十进制，可以为负数或者小数。还可以用`e`或者`E`表示为指数形式。\n    * 数值也与 C 或 Java 的数值相似。\n* 布尔（boolean）\n    * `true` 或 `false`。\n* 空（null）\n    * `null`。\n\n**Tips**：\n\n* 值的是可以嵌套的。\n* 名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。\n* 符号中间允许空白字符。\n* JSON 没有限制必须以 `object` 或结构类型作为顶层类型。\n* 但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 `object` 作为顶层类型。\n* 上述的集合或列表（string，object，array）可以是空集或空列。\n\n#### 示例\n\n```\n# Object\n{\n    \"Image\": {\n        \"Width\":  800,\n        \"Height\": 600,\n        \"Title\":  \"View from 15th Floor\",\n        \"Thumbnail\": {\n            \"Url\":    \"http://www.example.com/image/481989943\",\n            \"Height\": 125,\n            \"Width\":  100\n        },\n        \"Animated\" : false,\n        \"IDs\": [116, 943, 234, 38793]\n    }\n}\n\n# Array\n[\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.7668,\n        \"Longitude\": -122.3959,\n        \"Address\":   \"\",\n        \"City\":      \"SAN FRANCISCO\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94107\",\n        \"Country\":   \"US\"\n    },\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.371991,\n        \"Longitude\": -122.026020,\n        \"Address\":   \"\",\n        \"City\":      \"SUNNYVALE\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94085\",\n        \"Country\":   \"US\"\n    }\n]\n\n# Only values\n\n\"Hello world!\"\n\n42\n\ntrue\n\nnull\n```\n\n## 第二篇：介绍\n\n#### 版本\n\n当前版本：[draft-07](http://json-schema.org/specification.html)。\n\n#### 简介\n\nJSON Schema 是一个用于**注释**和**验证** JSON documents 的词汇表。\n\nJSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。\n\n#### 用途\n\n* 对数据结构进行描述\n* 构建人机可读的文档\n* 校验数据\n\n#### 项目状态\n\n共有三个规范：\n\n* [JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n* [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/)\n* [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/)\n\n项目组正在努力使它们成为正式的 RFC 标准。\n\n*[draft-08](https://github.com/json-schema-org/json-schema-spec/milestone/6)*\n\n#### 如何应用\n\n可以用于生成模拟数据，确保接近真实数据。\n\n用于校验数据，实现自动化测试。\n\n多端共用同一份验证。\n\n## 第三篇：Core 规范\n\n#### 简介\n\n[JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n\n此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。\n\n#### 状态\n\n草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：[https://datatracker.ietf.org/doc/draft-handrews-json-schema/](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)。\n\n#### 概述\n\n**媒体类型**\n\nJSON 的媒体类型：[application/json](https://tools.ietf.org/html/rfc8259#section-1.2) 。\n\nJSON Schema 的媒体类型为 `application/schema+json`，它还有另外一种可选媒体类型用于提供额外的扩展功能：`application/schema-instance+json`。\n\n**验证**\n\nJSON Schema 描述了 `JSON 文档(JSON document)` 的结构，例如属性、长度限制等，程序可以以此判断 `实例(Instance)` 是否符合规范。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**注释**\n\nJSON Schema 可以对 `实例(Instance)` 添加注释。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**超媒体与链接**\n\nJSON Hyper-Schema 描述了  `JSON 文档(JSON document)` 的超文本结构，包括 `实例(Instance)` 中的资源链接关系等。\n\n规范与关键字在 [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/) 中定义。\n\n#### 定义\n\n**JSON Document**\n\n`JSON 文档(JSON document)` 是使用 `application/json` 媒体类型描述的资源。\n\n简言之就是 JSON 值。\n\n*JSON Schema 中， `JSON 值(JSON value)`、`JSON 文本(JSON text)`、`JSON 文档(JSON document)`是等义词。*\n\n*JSON Schema 也是 `JSON 文档(JSON document)`。*\n\n**Instance**\n\n`实例(Instance)` 是使用 JSON Schema 描述的 `JSON 文档(JSON document)`。\n\n**JSON Schema document**\n\n使用 `application/schema+json` 媒体类型描述的 `JSON 文档(JSON document)`，简称 schema。\n\n#### 关键字\n\n**$schema**\n\n`$schema` 关键字用于声明当前 `JSON 文档(JSON document)` 是 `JSON Schema document`。\n\n值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$id**\n\n`$id` 关键字用于定义 schema 基本的 URI，可用于 `$ref` 的引用标识，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$ref**\n\n`$ref` 关键字用于定义引用 schema，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\nURI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。\n\n如果有两个 schema 互相使用 `$ref` 进行引用，不应该陷入无限循环。\n\n**$comment**\n\n`$comment` 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。","source":"_posts/JSON Schema.md","raw":"---\ntitle: JSON Schema\ndate: 2018/12/1 19:18:17\n---\n\n**JSON Schema 详解：未完待续**\n\n<!--more-->  \n\n## 第一篇：了解 JSON\n\n#### 介绍\n\nJSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《[Standard ECMA-262 3rd Edition - December 1999](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)》的一个子集，而后成为写入 RFC 文档：[RFC 4627](https://tools.ietf.org/html/rfc4627)，最新的 RFC 标准为：[RFC 8259](https://tools.ietf.org/html/rfc8259)。\n\nJSON 的官方 MIME 类型是 `application/json`，文件扩展名是 `.json`。\n\n#### 类型\n\n**两种结构化类型**：\n\n* Object：`名称/值`的集合（A collection of name/value pairs），在不同的语言中，被理解为 `object`，`record`，`struct`，`dictionary`，`hash table` 等等。\n    * 使用大括号`{`，`}`包裹`名称/值`的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用`:`分隔。`名称/值`之间使用`,`分隔。\n    * 格式示例：`{\"example\":\"string\"}`。\n* Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 `array`。\n    * 使用中括号`[`，`]`包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。\n    * 格式示例：`[0,\"1\",null,false,true,{},[]]`。\n\n**四种基本类型**：\n\n* 字符串（string）\n    * 字符串是 Unicode 字符组成的集合，使用双引号包裹（`\"`），反斜杠转义（`\\`）。\n    * 与 C 或 Java 的字符串相似。\n* 数值（number）\n    * 使用十进制，可以为负数或者小数。还可以用`e`或者`E`表示为指数形式。\n    * 数值也与 C 或 Java 的数值相似。\n* 布尔（boolean）\n    * `true` 或 `false`。\n* 空（null）\n    * `null`。\n\n**Tips**：\n\n* 值的是可以嵌套的。\n* 名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。\n* 符号中间允许空白字符。\n* JSON 没有限制必须以 `object` 或结构类型作为顶层类型。\n* 但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 `object` 作为顶层类型。\n* 上述的集合或列表（string，object，array）可以是空集或空列。\n\n#### 示例\n\n```\n# Object\n{\n    \"Image\": {\n        \"Width\":  800,\n        \"Height\": 600,\n        \"Title\":  \"View from 15th Floor\",\n        \"Thumbnail\": {\n            \"Url\":    \"http://www.example.com/image/481989943\",\n            \"Height\": 125,\n            \"Width\":  100\n        },\n        \"Animated\" : false,\n        \"IDs\": [116, 943, 234, 38793]\n    }\n}\n\n# Array\n[\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.7668,\n        \"Longitude\": -122.3959,\n        \"Address\":   \"\",\n        \"City\":      \"SAN FRANCISCO\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94107\",\n        \"Country\":   \"US\"\n    },\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.371991,\n        \"Longitude\": -122.026020,\n        \"Address\":   \"\",\n        \"City\":      \"SUNNYVALE\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94085\",\n        \"Country\":   \"US\"\n    }\n]\n\n# Only values\n\n\"Hello world!\"\n\n42\n\ntrue\n\nnull\n```\n\n## 第二篇：介绍\n\n#### 版本\n\n当前版本：[draft-07](http://json-schema.org/specification.html)。\n\n#### 简介\n\nJSON Schema 是一个用于**注释**和**验证** JSON documents 的词汇表。\n\nJSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。\n\n#### 用途\n\n* 对数据结构进行描述\n* 构建人机可读的文档\n* 校验数据\n\n#### 项目状态\n\n共有三个规范：\n\n* [JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n* [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/)\n* [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/)\n\n项目组正在努力使它们成为正式的 RFC 标准。\n\n*[draft-08](https://github.com/json-schema-org/json-schema-spec/milestone/6)*\n\n#### 如何应用\n\n可以用于生成模拟数据，确保接近真实数据。\n\n用于校验数据，实现自动化测试。\n\n多端共用同一份验证。\n\n## 第三篇：Core 规范\n\n#### 简介\n\n[JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n\n此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。\n\n#### 状态\n\n草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：[https://datatracker.ietf.org/doc/draft-handrews-json-schema/](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)。\n\n#### 概述\n\n**媒体类型**\n\nJSON 的媒体类型：[application/json](https://tools.ietf.org/html/rfc8259#section-1.2) 。\n\nJSON Schema 的媒体类型为 `application/schema+json`，它还有另外一种可选媒体类型用于提供额外的扩展功能：`application/schema-instance+json`。\n\n**验证**\n\nJSON Schema 描述了 `JSON 文档(JSON document)` 的结构，例如属性、长度限制等，程序可以以此判断 `实例(Instance)` 是否符合规范。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**注释**\n\nJSON Schema 可以对 `实例(Instance)` 添加注释。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**超媒体与链接**\n\nJSON Hyper-Schema 描述了  `JSON 文档(JSON document)` 的超文本结构，包括 `实例(Instance)` 中的资源链接关系等。\n\n规范与关键字在 [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/) 中定义。\n\n#### 定义\n\n**JSON Document**\n\n`JSON 文档(JSON document)` 是使用 `application/json` 媒体类型描述的资源。\n\n简言之就是 JSON 值。\n\n*JSON Schema 中， `JSON 值(JSON value)`、`JSON 文本(JSON text)`、`JSON 文档(JSON document)`是等义词。*\n\n*JSON Schema 也是 `JSON 文档(JSON document)`。*\n\n**Instance**\n\n`实例(Instance)` 是使用 JSON Schema 描述的 `JSON 文档(JSON document)`。\n\n**JSON Schema document**\n\n使用 `application/schema+json` 媒体类型描述的 `JSON 文档(JSON document)`，简称 schema。\n\n#### 关键字\n\n**$schema**\n\n`$schema` 关键字用于声明当前 `JSON 文档(JSON document)` 是 `JSON Schema document`。\n\n值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$id**\n\n`$id` 关键字用于定义 schema 基本的 URI，可用于 `$ref` 的引用标识，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$ref**\n\n`$ref` 关键字用于定义引用 schema，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\nURI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。\n\n如果有两个 schema 互相使用 `$ref` 进行引用，不应该陷入无限循环。\n\n**$comment**\n\n`$comment` 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。","slug":"JSON Schema","published":1,"updated":"2020-07-23T00:29:18.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34e9z0008cyzeniqtojd4","content":"<p><strong>JSON Schema 详解：未完待续</strong></p>\n<a id=\"more\"></a>  \n<h2 id=\"第一篇：了解-JSON\"><a href=\"#第一篇：了解-JSON\" class=\"headerlink\" title=\"第一篇：了解 JSON\"></a>第一篇：了解 JSON</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>JSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"noopener\">Standard ECMA-262 3rd Edition - December 1999</a>》的一个子集，而后成为写入 RFC 文档：<a href=\"https://tools.ietf.org/html/rfc4627\" target=\"_blank\" rel=\"noopener\">RFC 4627</a>，最新的 RFC 标准为：<a href=\"https://tools.ietf.org/html/rfc8259\" target=\"_blank\" rel=\"noopener\">RFC 8259</a>。</p>\n<p>JSON 的官方 MIME 类型是 <code>application/json</code>，文件扩展名是 <code>.json</code>。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><strong>两种结构化类型</strong>：</p>\n<ul>\n<li>Object：<code>名称/值</code>的集合（A collection of name/value pairs），在不同的语言中，被理解为 <code>object</code>，<code>record</code>，<code>struct</code>，<code>dictionary</code>，<code>hash table</code> 等等。<ul>\n<li>使用大括号<code>{</code>，<code>}</code>包裹<code>名称/值</code>的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用<code>:</code>分隔。<code>名称/值</code>之间使用<code>,</code>分隔。</li>\n<li>格式示例：<code>{&quot;example&quot;:&quot;string&quot;}</code>。</li>\n</ul>\n</li>\n<li>Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 <code>array</code>。<ul>\n<li>使用中括号<code>[</code>，<code>]</code>包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。</li>\n<li>格式示例：<code>[0,&quot;1&quot;,null,false,true,{},[]]</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>四种基本类型</strong>：</p>\n<ul>\n<li>字符串（string）<ul>\n<li>字符串是 Unicode 字符组成的集合，使用双引号包裹（<code>&quot;</code>），反斜杠转义（<code>\\</code>）。</li>\n<li>与 C 或 Java 的字符串相似。</li>\n</ul>\n</li>\n<li>数值（number）<ul>\n<li>使用十进制，可以为负数或者小数。还可以用<code>e</code>或者<code>E</code>表示为指数形式。</li>\n<li>数值也与 C 或 Java 的数值相似。</li>\n</ul>\n</li>\n<li>布尔（boolean）<ul>\n<li><code>true</code> 或 <code>false</code>。</li>\n</ul>\n</li>\n<li>空（null）<ul>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Tips</strong>：</p>\n<ul>\n<li>值的是可以嵌套的。</li>\n<li>名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。</li>\n<li>符号中间允许空白字符。</li>\n<li>JSON 没有限制必须以 <code>object</code> 或结构类型作为顶层类型。</li>\n<li>但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 <code>object</code> 作为顶层类型。</li>\n<li>上述的集合或列表（string，object，array）可以是空集或空列。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;Image&quot;: &#123;</span><br><span class=\"line\">        &quot;Width&quot;:  800,</span><br><span class=\"line\">        &quot;Height&quot;: 600,</span><br><span class=\"line\">        &quot;Title&quot;:  &quot;View from 15th Floor&quot;,</span><br><span class=\"line\">        &quot;Thumbnail&quot;: &#123;</span><br><span class=\"line\">            &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,</span><br><span class=\"line\">            &quot;Height&quot;: 125,</span><br><span class=\"line\">            &quot;Width&quot;:  100</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;Animated&quot; : false,</span><br><span class=\"line\">        &quot;IDs&quot;: [116, 943, 234, 38793]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># Array</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.7668,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.3959,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94107&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.371991,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.026020,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SUNNYVALE&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94085&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"># Only values</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;Hello world!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">42</span><br><span class=\"line\"></span><br><span class=\"line\">true</span><br><span class=\"line\"></span><br><span class=\"line\">null</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二篇：介绍\"><a href=\"#第二篇：介绍\" class=\"headerlink\" title=\"第二篇：介绍\"></a>第二篇：介绍</h2><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><p>当前版本：<a href=\"http://json-schema.org/specification.html\" target=\"_blank\" rel=\"noopener\">draft-07</a>。</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>JSON Schema 是一个用于<strong>注释</strong>和<strong>验证</strong> JSON documents 的词汇表。</p>\n<p>JSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>对数据结构进行描述</li>\n<li>构建人机可读的文档</li>\n<li>校验数据</li>\n</ul>\n<h4 id=\"项目状态\"><a href=\"#项目状态\" class=\"headerlink\" title=\"项目状态\"></a>项目状态</h4><p>共有三个规范：</p>\n<ul>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a></li>\n</ul>\n<p>项目组正在努力使它们成为正式的 RFC 标准。</p>\n<p><em><a href=\"https://github.com/json-schema-org/json-schema-spec/milestone/6\" target=\"_blank\" rel=\"noopener\">draft-08</a></em></p>\n<h4 id=\"如何应用\"><a href=\"#如何应用\" class=\"headerlink\" title=\"如何应用\"></a>如何应用</h4><p>可以用于生成模拟数据，确保接近真实数据。</p>\n<p>用于校验数据，实现自动化测试。</p>\n<p>多端共用同一份验证。</p>\n<h2 id=\"第三篇：Core-规范\"><a href=\"#第三篇：Core-规范\" class=\"headerlink\" title=\"第三篇：Core 规范\"></a>第三篇：Core 规范</h2><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></p>\n<p>此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：<a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">https://datatracker.ietf.org/doc/draft-handrews-json-schema/</a>。</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><strong>媒体类型</strong></p>\n<p>JSON 的媒体类型：<a href=\"https://tools.ietf.org/html/rfc8259#section-1.2\" target=\"_blank\" rel=\"noopener\">application/json</a> 。</p>\n<p>JSON Schema 的媒体类型为 <code>application/schema+json</code>，它还有另外一种可选媒体类型用于提供额外的扩展功能：<code>application/schema-instance+json</code>。</p>\n<p><strong>验证</strong></p>\n<p>JSON Schema 描述了 <code>JSON 文档(JSON document)</code> 的结构，例如属性、长度限制等，程序可以以此判断 <code>实例(Instance)</code> 是否符合规范。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>注释</strong></p>\n<p>JSON Schema 可以对 <code>实例(Instance)</code> 添加注释。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>超媒体与链接</strong></p>\n<p>JSON Hyper-Schema 描述了  <code>JSON 文档(JSON document)</code> 的超文本结构，包括 <code>实例(Instance)</code> 中的资源链接关系等。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a> 中定义。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>JSON Document</strong></p>\n<p><code>JSON 文档(JSON document)</code> 是使用 <code>application/json</code> 媒体类型描述的资源。</p>\n<p>简言之就是 JSON 值。</p>\n<p><em>JSON Schema 中， <code>JSON 值(JSON value)</code>、<code>JSON 文本(JSON text)</code>、<code>JSON 文档(JSON document)</code>是等义词。</em></p>\n<p><em>JSON Schema 也是 <code>JSON 文档(JSON document)</code>。</em></p>\n<p><strong>Instance</strong></p>\n<p><code>实例(Instance)</code> 是使用 JSON Schema 描述的 <code>JSON 文档(JSON document)</code>。</p>\n<p><strong>JSON Schema document</strong></p>\n<p>使用 <code>application/schema+json</code> 媒体类型描述的 <code>JSON 文档(JSON document)</code>，简称 schema。</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p><strong>$schema</strong></p>\n<p><code>$schema</code> 关键字用于声明当前 <code>JSON 文档(JSON document)</code> 是 <code>JSON Schema document</code>。</p>\n<p>值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$id</strong></p>\n<p><code>$id</code> 关键字用于定义 schema 基本的 URI，可用于 <code>$ref</code> 的引用标识，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$ref</strong></p>\n<p><code>$ref</code> 关键字用于定义引用 schema，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p>URI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。</p>\n<p>如果有两个 schema 互相使用 <code>$ref</code> 进行引用，不应该陷入无限循环。</p>\n<p><strong>$comment</strong></p>\n<p><code>$comment</code> 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。</p>\n","site":{"data":{}},"excerpt":"<p><strong>JSON Schema 详解：未完待续</strong></p>","more":"<h2 id=\"第一篇：了解-JSON\"><a href=\"#第一篇：了解-JSON\" class=\"headerlink\" title=\"第一篇：了解 JSON\"></a>第一篇：了解 JSON</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>JSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"noopener\">Standard ECMA-262 3rd Edition - December 1999</a>》的一个子集，而后成为写入 RFC 文档：<a href=\"https://tools.ietf.org/html/rfc4627\" target=\"_blank\" rel=\"noopener\">RFC 4627</a>，最新的 RFC 标准为：<a href=\"https://tools.ietf.org/html/rfc8259\" target=\"_blank\" rel=\"noopener\">RFC 8259</a>。</p>\n<p>JSON 的官方 MIME 类型是 <code>application/json</code>，文件扩展名是 <code>.json</code>。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><strong>两种结构化类型</strong>：</p>\n<ul>\n<li>Object：<code>名称/值</code>的集合（A collection of name/value pairs），在不同的语言中，被理解为 <code>object</code>，<code>record</code>，<code>struct</code>，<code>dictionary</code>，<code>hash table</code> 等等。<ul>\n<li>使用大括号<code>{</code>，<code>}</code>包裹<code>名称/值</code>的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用<code>:</code>分隔。<code>名称/值</code>之间使用<code>,</code>分隔。</li>\n<li>格式示例：<code>{&quot;example&quot;:&quot;string&quot;}</code>。</li>\n</ul>\n</li>\n<li>Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 <code>array</code>。<ul>\n<li>使用中括号<code>[</code>，<code>]</code>包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。</li>\n<li>格式示例：<code>[0,&quot;1&quot;,null,false,true,{},[]]</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>四种基本类型</strong>：</p>\n<ul>\n<li>字符串（string）<ul>\n<li>字符串是 Unicode 字符组成的集合，使用双引号包裹（<code>&quot;</code>），反斜杠转义（<code>\\</code>）。</li>\n<li>与 C 或 Java 的字符串相似。</li>\n</ul>\n</li>\n<li>数值（number）<ul>\n<li>使用十进制，可以为负数或者小数。还可以用<code>e</code>或者<code>E</code>表示为指数形式。</li>\n<li>数值也与 C 或 Java 的数值相似。</li>\n</ul>\n</li>\n<li>布尔（boolean）<ul>\n<li><code>true</code> 或 <code>false</code>。</li>\n</ul>\n</li>\n<li>空（null）<ul>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Tips</strong>：</p>\n<ul>\n<li>值的是可以嵌套的。</li>\n<li>名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。</li>\n<li>符号中间允许空白字符。</li>\n<li>JSON 没有限制必须以 <code>object</code> 或结构类型作为顶层类型。</li>\n<li>但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 <code>object</code> 作为顶层类型。</li>\n<li>上述的集合或列表（string，object，array）可以是空集或空列。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;Image&quot;: &#123;</span><br><span class=\"line\">        &quot;Width&quot;:  800,</span><br><span class=\"line\">        &quot;Height&quot;: 600,</span><br><span class=\"line\">        &quot;Title&quot;:  &quot;View from 15th Floor&quot;,</span><br><span class=\"line\">        &quot;Thumbnail&quot;: &#123;</span><br><span class=\"line\">            &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,</span><br><span class=\"line\">            &quot;Height&quot;: 125,</span><br><span class=\"line\">            &quot;Width&quot;:  100</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;Animated&quot; : false,</span><br><span class=\"line\">        &quot;IDs&quot;: [116, 943, 234, 38793]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># Array</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.7668,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.3959,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94107&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.371991,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.026020,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SUNNYVALE&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94085&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"># Only values</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;Hello world!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">42</span><br><span class=\"line\"></span><br><span class=\"line\">true</span><br><span class=\"line\"></span><br><span class=\"line\">null</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二篇：介绍\"><a href=\"#第二篇：介绍\" class=\"headerlink\" title=\"第二篇：介绍\"></a>第二篇：介绍</h2><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><p>当前版本：<a href=\"http://json-schema.org/specification.html\" target=\"_blank\" rel=\"noopener\">draft-07</a>。</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>JSON Schema 是一个用于<strong>注释</strong>和<strong>验证</strong> JSON documents 的词汇表。</p>\n<p>JSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>对数据结构进行描述</li>\n<li>构建人机可读的文档</li>\n<li>校验数据</li>\n</ul>\n<h4 id=\"项目状态\"><a href=\"#项目状态\" class=\"headerlink\" title=\"项目状态\"></a>项目状态</h4><p>共有三个规范：</p>\n<ul>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a></li>\n</ul>\n<p>项目组正在努力使它们成为正式的 RFC 标准。</p>\n<p><em><a href=\"https://github.com/json-schema-org/json-schema-spec/milestone/6\" target=\"_blank\" rel=\"noopener\">draft-08</a></em></p>\n<h4 id=\"如何应用\"><a href=\"#如何应用\" class=\"headerlink\" title=\"如何应用\"></a>如何应用</h4><p>可以用于生成模拟数据，确保接近真实数据。</p>\n<p>用于校验数据，实现自动化测试。</p>\n<p>多端共用同一份验证。</p>\n<h2 id=\"第三篇：Core-规范\"><a href=\"#第三篇：Core-规范\" class=\"headerlink\" title=\"第三篇：Core 规范\"></a>第三篇：Core 规范</h2><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></p>\n<p>此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：<a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">https://datatracker.ietf.org/doc/draft-handrews-json-schema/</a>。</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><strong>媒体类型</strong></p>\n<p>JSON 的媒体类型：<a href=\"https://tools.ietf.org/html/rfc8259#section-1.2\" target=\"_blank\" rel=\"noopener\">application/json</a> 。</p>\n<p>JSON Schema 的媒体类型为 <code>application/schema+json</code>，它还有另外一种可选媒体类型用于提供额外的扩展功能：<code>application/schema-instance+json</code>。</p>\n<p><strong>验证</strong></p>\n<p>JSON Schema 描述了 <code>JSON 文档(JSON document)</code> 的结构，例如属性、长度限制等，程序可以以此判断 <code>实例(Instance)</code> 是否符合规范。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>注释</strong></p>\n<p>JSON Schema 可以对 <code>实例(Instance)</code> 添加注释。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>超媒体与链接</strong></p>\n<p>JSON Hyper-Schema 描述了  <code>JSON 文档(JSON document)</code> 的超文本结构，包括 <code>实例(Instance)</code> 中的资源链接关系等。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a> 中定义。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>JSON Document</strong></p>\n<p><code>JSON 文档(JSON document)</code> 是使用 <code>application/json</code> 媒体类型描述的资源。</p>\n<p>简言之就是 JSON 值。</p>\n<p><em>JSON Schema 中， <code>JSON 值(JSON value)</code>、<code>JSON 文本(JSON text)</code>、<code>JSON 文档(JSON document)</code>是等义词。</em></p>\n<p><em>JSON Schema 也是 <code>JSON 文档(JSON document)</code>。</em></p>\n<p><strong>Instance</strong></p>\n<p><code>实例(Instance)</code> 是使用 JSON Schema 描述的 <code>JSON 文档(JSON document)</code>。</p>\n<p><strong>JSON Schema document</strong></p>\n<p>使用 <code>application/schema+json</code> 媒体类型描述的 <code>JSON 文档(JSON document)</code>，简称 schema。</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p><strong>$schema</strong></p>\n<p><code>$schema</code> 关键字用于声明当前 <code>JSON 文档(JSON document)</code> 是 <code>JSON Schema document</code>。</p>\n<p>值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$id</strong></p>\n<p><code>$id</code> 关键字用于定义 schema 基本的 URI，可用于 <code>$ref</code> 的引用标识，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$ref</strong></p>\n<p><code>$ref</code> 关键字用于定义引用 schema，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p>URI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。</p>\n<p>如果有两个 schema 互相使用 <code>$ref</code> 进行引用，不应该陷入无限循环。</p>\n<p><strong>$comment</strong></p>\n<p><code>$comment</code> 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。</p>"},{"title":"JWT 与 OAuth 2.0","date":"2016-09-01T13:30:18.000Z","_content":"**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","source":"_posts/JWT-and-OAuth2.0.md","raw":"---\ntitle: JWT 与 OAuth 2.0\ndate: 2016/9/1 21:30:18\n---\n**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","slug":"JWT-and-OAuth2.0","published":1,"updated":"2020-07-23T00:29:18.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea1000acyzeeex76gq7","content":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>\n<a id=\"more\"></a>  \n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>\n","site":{"data":{}},"excerpt":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>"},{"title":"Kubernetes Cluster Autoscaler","date":"2020-03-30T16:00:00.000Z","_content":"\n当我们使用 Kubernetes 部署应用后，会发现如果用户增长速度超过预期，以至于计算资源不够时，你会怎么做呢？Kubernetes 给出的解决方案就是：自动伸缩（auto-scaling），通过自动伸缩组件之间的配合，可以 7*24 小时的监控着你的集群，动态变化负载，以适应你的用户需求。\n\n<!--more-->\t\n\n\n## 自动伸缩组件\n\n**水平自动伸缩（Horizontal Pod Autoscaler，HPA）**\n\nHPA 可以基于实时的 CPU 利用率自动伸缩 Replication Controller、Deployment 和 Replica Set 中的 Pod 数量。也可以通过搭配 Metrics Server 基于其他的度量指标。\n\n**垂直自动伸缩（Vertical Pod Autoscaler，VPA）**\n\nVPA 可以基于 Pod 的使用资源来自动设置 Pod 所需资源并且能够在运行时自动调整资源。\n\n**集群自动伸缩（Cluster Autoscaler，CA）**\n\nCA 是一个可以自动伸缩集群 Node 的组件。如果集群中有未被调度的 Pod，它将会自动扩展 Node 来使 Pod 可用，或是在发现集群中的 Node 资源使用率过低时，删除 Node 来节约资源。\n\n**插件伸缩（Addon Resizer）**\n\n这是一个小插件，它以 Sidecar 的形式来垂直伸缩与自己同一个部署中的另一个容器，目前唯一的策略就是根据集群中节点的数量来进行线性扩展。通常与 [Metrics Server](https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/metrics-server/metrics-server-deployment.yaml#L66) 配合使用，以保证其可以负担不断扩大的整个集群的 metrics API 服务。\n\n通过 HPA 伸缩无状态应用，VPA 伸缩有状态应用，CA 保证计算资源，它们的配合使用，构成了一个完整的自动伸缩解决方案。\n\n\n\n## Cluster Autoscaler 详细介绍\n\n上面介绍的四个组件中，HPA 是在 kubernetes 代码仓库中的，随着 kubernetes 的版本进行更新发布，不需要部署，可以直接使用。其他的三个组件都在官方社区维护的[仓库](https://github.com/kubernetes/autoscaler)中，Cluster Autoscaler 的 v1.0(GA) 版本已经随着 kubernetes 1.8 一起发布，剩下两个则还是 beta 版本。\n\n\n\n### 部署\n\nCluster Autoscaler 通常需要搭配云厂商使用，它提供了 `Cloud Provider` 接口供各个云厂商接入，云厂商通过伸缩组（Scaling Group）或节点池（Node Pool）的功能对 ECS 类产品节点进行增加删除等操作。\n\n目前（v1.18.1）已接入的云厂商：\n\n**Alicloud：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md\n\n**Aws：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md\n\n**Azure：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md\n\n**Baiducloud：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/baiducloud/README.md\n\n**Digitalocean：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/digitalocean/README.md\n\n**GoogleCloud GCE：**https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#upgrading-google-compute-engine-clusters\n\n**GoogleCloud GKE：**https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler\n\n**OpenStack Magnum：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/magnum/README.md\n\n**Packet：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/packet/README.md\n\n\n启动参数列表：https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca\n\n\n\n### 工作原理\n\nCluster Autoscaler 抽象出了一个 `NodeGroup` 的概念，与之对应的是云厂商的伸缩组服务。Cluster Autoscaler 通过 `CloudProvider` 提供的 `NodeGroup` 计算集群内节点资源，以此来进行伸缩。\n\n在启动后，Cluster Autoscaler 会定期（默认 10s）检查未调度的 Pod 和 Node 的资源使用情况，并进行相应的 `Scale UP` 和 `Scale Down` 操作。\n\n#### Scale UP\n\n当 Cluster Autoscaler 发现有 Pod 由于资源不足而无法调度时，就会通过调用 `Scale UP` 执行扩容操作。\n\n在 `Scale UP` 中会只会计算在 `NodeGroup` 中存在的 Node，我们可以将 Worker Node 统一交由伸缩组进行管理。并且由于伸缩组非同步加入的特性，也会考虑到 Upcoming Node。\n\n为了业务需要，集群中可能会有不同规格的 Node，我们可以创建多个 `NodeGroup`，在扩容时会根据 `--expander` 选项配置指定的策略，选择一个扩容的节点组，支持如下[五种策略](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)：\n\n* **random：**随机选择一个 `NodeGroup`。如果未指定，则默认为此策略。\n* **most-pods：**选择能够调度最多 Pod 的 `NodeGroup`，比如有的 Pod 未调度是因为 `nodeSelector`，此策略会优先选择能满足的 `NodeGroup` 来保证大多数的 Pod 可以被调度。\n* **least-waste：**为避免浪费，此策略会优先选择能满足 Pod 需求资源的最小资源类型的 `NodeGroup`。\n* **price：**根据 `CloudProvider` 提供的价格模型，选择最省钱的 `NodeGroup`。\n* **priority：**通过配置优先级来进行选择，用起来比较麻烦，需要额外的配置，可以看[文档](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md)。\n\n如果有需要，也可以平衡相似 `NodeGroup` 中的\tNode 数量，避免 `NodeGroup` 达到 `MaxSize` 而导致无法加入新 Node。通过 `--balance-similar-node-groups` 选项配置，默认为 `false`。\n\n再经过一系列的操作后，最终计算出要扩容的 Node 数量及 `NodeGroup`，使用 `CloudProvider` 执行 `IncreaseSize` 操作，增加云厂商的伸缩组大小，从而完成扩容操作。\n\n*文字表达能力不足，如果有不清晰的地方，可以参考下面的 [ScaleUP 源码解析](#ScaleUP源码解析)。*\n\n#### Scale Down\n\n缩容是一个可选的功能，通过 `--scale-down-enabled` 选项配置，默认为 `true`。\n\n在 Cluster Autoscaler 监控 Node 资源时，如果发现有 Node 满足以下三个条件时，就会标记这个 Node 为 `unneeded`：\n\n* Node 上运行的所有的 Pod 的 Cpu 和内存之和小于该 Node 可分配容量的 50%。可通过 `--scale-down-utilization-threshold` 选项改变这个配置。\n* Node 上所有的 Pod 都可以被调度到其他节点。\n* Node 没有表示不可缩容的 annotaition。\n\n如果一个 Node 被标记为 `unneeded` 超过 10 分钟（可通过 `--scale-down-unneeded-time` 选项配置），则使用 `CloudProvider` 执行 `DeleteNodes` 操作将其删除。一次最多删除一个 `unneeded Node`，但空 Node 可以批量删除，每次最多删除 10 个（通过 `----max-empty-bulk-delete` 选项配置）。\n\n实际上并不是只有这一个判定条件，还会有其他的条件来阻止删除这个 Node，比如 `NodeGroup` 已达到 `MinSize`，或在过去的 10 分钟内有过一次 `Scale UP` 操作（通过 `--scale-down-delay-after-add` 选项配置）等等，更详细可查看[文档](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-down-work)。\n\n\n\nCluster Autoscaler 的工作机制很复杂，但其中大部分都能通过 flags 进行配置，如果有需要，请详细阅读文档：https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md\n\n\n\n## 如何实现 CloudProvider\n\n如果使用上述中已实现接入的云厂商，只需要通过 `--cloud-provider` 选项指定来自哪个云厂商就可以，如果想要对接自己的 IaaS 或有特定的业务逻辑，就需要自己实现 `CloudProvider Interface` 与 `NodeGroupInterface`。并将其注册到 `builder` 中，用于通过 `--cloud-provider` 参数指定。\n\n`builder` 在 `cloudprovider/builder` 中的 [builder_all.go](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/builder/builder_all.go) 中注册，也可以在其中新建一个自己的 `build`，通过 go 文件的 `+build` 编译参数来指定使用的 `CloudProvider`。\n\n`CloudProvider` 接口与 `NodeGroup` 接口在 [cloud_provider.go](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/cloud_provider.go) 中定义，其中需要注意的是 `Refresh` 方法，它会在每一次循环（默认 10 秒）的开始时调用，可在此时请求接口并刷新 `NodeGroup` 状态，通常的做法是增加一个 `manager` 用于管理状态。有不理解的部分可参考其他 `CloudProvider` 的实现。\n\n```go\ntype CloudProvider interface {\n\t// Name returns name of the cloud provider.\n\tName() string\n\n\t// NodeGroups returns all node groups configured for this cloud provider.\n\t// 会在一此循环中多次调用此方法，所以不适合每次都请求云厂商服务，可以在 Refresh 时存储状态\n\tNodeGroups() []NodeGroup\n\n\t// NodeGroupForNode returns the node group for the given node, nil if the node\n\t// should not be processed by cluster autoscaler, or non-nil error if such\n\t// occurred. Must be implemented.\n\t// 同上\n\tNodeGroupForNode(*apiv1.Node) (NodeGroup, error)\n\n\t// Pricing returns pricing model for this cloud provider or error if not available.\n\t// Implementation optional.\n\t// 如果不使用 price expander 就可以不实现此方法\n\tPricing() (PricingModel, errors.AutoscalerError)\n\n\t// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.\n\t// Implementation optional.\n\t// 没用，不需要实现\n\tGetAvailableMachineTypes() ([]string, error)\n\n\t// NewNodeGroup builds a theoretical node group based on the node definition provided. The node group is not automatically\n\t// created on the cloud provider side. The node group is not returned by NodeGroups() until it is created.\n\t// Implementation optional.\n\t// 通常情况下，不需要实现此方法，但如果你需要 ClusterAutoscaler 创建一个默认的 NodeGroup 的话，也可以实现。\n\t// 但其实更好的做法是将默认 NodeGroup 写入云端的伸缩组\n\tNewNodeGroup(machineType string, labels map[string]string, systemLabels map[string]string,\n\t\ttaints []apiv1.Taint, extraResources map[string]resource.Quantity) (NodeGroup, error)\n\n\t// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).\n\t// 资源限制对象，会在 build 时传入，通常情况下不需要更改，除非在云端有显示的提示用户更改的地方，否则使用时会迷惑用户\n\tGetResourceLimiter() (*ResourceLimiter, error)\n\n\t// GPULabel returns the label added to nodes with GPU resource.\n\t// GPU 相关，如果集群中有使用 GPU 资源，需要返回对应内容。 hack: we assume anything which is not cpu/memory to be a gpu.\n\tGPULabel() string\n\n\t// GetAvailableGPUTypes return all available GPU types cloud provider supports.\n\t// 同上\n\tGetAvailableGPUTypes() map[string]struct{}\n\n\t// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.\n\t// CloudProvider 只会在启动时被初始化一次，如果每次循环后有需要清除的内容，在这里处理\n\tCleanup() error\n\n\t// Refresh is called before every main loop and can be used to dynamically update cloud provider state.\n\t// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().\n\t// 会在 StaticAutoscaler RunOnce 中被调用\n\tRefresh() error\n}\n// NodeGroup contains configuration info and functions to control a set\n// of nodes that have the same capacity and set of labels.\ntype NodeGroup interface {\n\t// MaxSize returns maximum size of the node group.\n\tMaxSize() int\n\n\t// MinSize returns minimum size of the node group.\n\tMinSize() int\n\n\t// TargetSize returns the current target size of the node group. It is possible that the\n\t// number of nodes in Kubernetes is different at the moment but should be equal\n\t// to Size() once everything stabilizes (new nodes finish startup and registration or\n\t// removed nodes are deleted completely). Implementation required.\n\t// 响应的是伸缩组的节点数，并不一定与 kubernetes 中的节点数保持一致\n\tTargetSize() (int, error)\n\n\t// IncreaseSize increases the size of the node group. To delete a node you need\n\t// to explicitly name it and use DeleteNode. This function should wait until\n\t// node group size is updated. Implementation required.\n\t// 扩容的方法，增加伸缩组的节点数\n\tIncreaseSize(delta int) error\n\n\t// DeleteNodes deletes nodes from this node group. Error is returned either on\n\t// failure or if the given node doesn't belong to this node group. This function\n\t// should wait until node group size is updated. Implementation required.\n\t// 删除的节点一定要在该节点组中\n\tDeleteNodes([]*apiv1.Node) error\n\n\t// DecreaseTargetSize decreases the target size of the node group. This function\n\t// doesn't permit to delete any existing node and can be used only to reduce the\n\t// request for new nodes that have not been yet fulfilled. Delta should be negative.\n\t// It is assumed that cloud provider will not delete the existing nodes when there\n\t// is an option to just decrease the target. Implementation required.\n\t// 当 ClusterAutoscaler 发现 kubernetes 节点数与伸缩组的节点数长时间不一致，会调用此方法来调整\n\tDecreaseTargetSize(delta int) error\n\n\t// Id returns an unique identifier of the node group.\n\tId() string\n\n\t// Debug returns a string containing all information regarding this node group.\n\tDebug() string\n\n\t// Nodes returns a list of all nodes that belong to this node group.\n\t// It is required that Instance objects returned by this method have Id field set.\n\t// Other fields are optional.\n\t// This list should include also instances that might have not become a kubernetes node yet.\n\t// 返回伸缩组中的所有节点，哪怕它还没有成为 kubernetes 的节点\n\tNodes() ([]Instance, error)\n\n\t// TemplateNodeInfo returns a schedulernodeinfo.NodeInfo structure of an empty\n\t// (as if just started) node. This will be used in scale-up simulations to\n\t// predict what would a new node look like if a node group was expanded. The returned\n\t// NodeInfo is expected to have a fully populated Node object, with all of the labels,\n\t// capacity and allocatable information as well as all pods that are started on\n\t// the node by default, using manifest (most likely only kube-proxy). Implementation optional.\n\t// ClusterAutoscaler 会将节点信息与节点组对应，来判断资源条件，如果是一个空的节点组，那么就会通过此方法来虚拟一个节点信息。\n\tTemplateNodeInfo() (*schedulernodeinfo.NodeInfo, error)\n\n\t// Exist checks if the node group really exists on the cloud provider side. Allows to tell the\n\t// theoretical node group from the real one. Implementation required.\n\tExist() bool\n\n\t// Create creates the node group on the cloud provider side. Implementation optional.\n\t// 与 CloudProvider.NewNodeGroup 配合使用\n\tCreate() (NodeGroup, error)\n\n\t// Delete deletes the node group on the cloud provider side.\n\t// This will be executed only for autoprovisioned node groups, once their size drops to 0.\n\t// Implementation optional.\n\tDelete() error\n\n\t// Autoprovisioned returns true if the node group is autoprovisioned. An autoprovisioned group\n\t// was created by CA and can be deleted when scaled to 0.\n\tAutoprovisioned() bool\n}\n```\n\n\n\n## ScaleUP 源码解析\n\n```go\nfunc ScaleUp(context *context.AutoscalingContext, processors *ca_processors.AutoscalingProcessors, clusterStateRegistry *clusterstate.ClusterStateRegistry, unschedulablePods []*apiv1.Pod, nodes []*apiv1.Node, daemonSets []*appsv1.DaemonSet, nodeInfos map[string]*schedulernodeinfo.NodeInfo, ignoredTaints taints.TaintKeySet) (*status.ScaleUpStatus, errors.AutoscalerError) {\n\t\n\t......\n\t// 验证当前集群中所有 ready node 是否来自于 nodeGroups，取得所有非组内的 node\n\tnodesFromNotAutoscaledGroups, err := utils.FilterOutNodesFromNotAutoscaledGroups(nodes, context.CloudProvider)\n\tif err != nil {\n\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, err.AddPrefix(\"failed to filter out nodes which are from not autoscaled groups: \")\n\t}\n\n\tnodeGroups := context.CloudProvider.NodeGroups()\n\tgpuLabel := context.CloudProvider.GPULabel()\n\tavailableGPUTypes := context.CloudProvider.GetAvailableGPUTypes()\n\n\t// 资源限制对象，会在 build cloud provider 时传入\n\t// 如果有需要可在 CloudProvider 中自行更改，但不建议改动，会对用户造成迷惑\n\tresourceLimiter, errCP := context.CloudProvider.GetResourceLimiter()\n\tif errCP != nil {\n\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, errors.ToAutoscalerError(\n\t\t\terrors.CloudProviderError,\n\t\t\terrCP)\n\t}\n\n\t// 计算资源限制\n\t// nodeInfos 是所有拥有节点组的节点与示例节点的映射\n\t// 示例节点会优先考虑真实节点的数据，如果 NodeGroup 中还没有真实节点的部署，则使用 Template 的节点数据\n\tscaleUpResourcesLeft, errLimits := computeScaleUpResourcesLeftLimits(context.CloudProvider, nodeGroups, nodeInfos, nodesFromNotAutoscaledGroups, resourceLimiter)\n\tif errLimits != nil {\n\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, errLimits.AddPrefix(\"Could not compute total resources: \")\n\t}\n\n\t// 根据当前节点与 NodeGroups 中的节点来计算会有多少节点即将加入集群中\n\t// 由于云服务商的伸缩组 increase size 操作并不是同步加入 node，所以将其统计，以便于后面计算节点资源\n\tupcomingNodes := make([]*schedulernodeinfo.NodeInfo, 0)\n\tfor nodeGroup, numberOfNodes := range clusterStateRegistry.GetUpcomingNodes() {\n\t\t......\n\t}\n\tklog.V(4).Infof(\"Upcoming %d nodes\", len(upcomingNodes))\n\n\t// 最终会进入选择的节点组\n\texpansionOptions := make(map[string]expander.Option, 0)\n\t......\n\t// 出于某些限制或错误导致不能加入新节点的节点组，例如节点组已达到 MaxSize\n\tskippedNodeGroups := map[string]status.Reasons{}\n\t// 综合各种情况，筛选出节点组\n\tfor _, nodeGroup := range nodeGroups {\n\t......\n\t}\n\tif len(expansionOptions) == 0 {\n\t\tklog.V(1).Info(\"No expansion options\")\n\t\treturn &status.ScaleUpStatus{\n\t\t\tResult:\t\t\t\t\tstatus.ScaleUpNoOptionsAvailable,\n\t\t\tPodsRemainUnschedulable: getRemainingPods(podEquivalenceGroups, skippedNodeGroups),\n\t\t\tConsideredNodeGroups:\tnodeGroups,\n\t\t}, nil\n\t}\n\n\t......\n\t// 选择一个最佳的节点组进行扩容，expander 用于选择一个合适的节点组进行扩容，默认为 RandomExpander，flag: expander\n\t// random 随机选一个，适合只有一个节点组\n\t// most-pods 选择能够调度最多 pod 的节点组，比如有 noSchedulerPods 是有 nodeSelector 的，它会优先选择此类节点组以满足大多数 pod 的需求\n\t// least-waste 优先选择能满足 pod 需求资源的最小资源类型的节点组\n\t// price 根据价格模型，选择最省钱的\n\t// priority 根据优先级选择\n\tbestOption := context.ExpanderStrategy.BestOption(options, nodeInfos)\n\tif bestOption != nil && bestOption.NodeCount > 0 {\n\t......\n\t\tnewNodes := bestOption.NodeCount\n\n\t\t// 考虑到 upcomingNodes, 重新计算本次新加入节点\n\t\tif context.MaxNodesTotal > 0 && len(nodes)+newNodes+len(upcomingNodes) > context.MaxNodesTotal {\n\t\t\tklog.V(1).Infof(\"Capping size to max cluster total size (%d)\", context.MaxNodesTotal)\n\t\t\tnewNodes = context.MaxNodesTotal - len(nodes) - len(upcomingNodes)\n\t\t\tif newNodes < 1 {\n\t\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, errors.NewAutoscalerError(\n\t\t\t\t\terrors.TransientError,\n\t\t\t\t\t\"max node total count already reached\")\n\t\t\t}\n\t\t}\n\n\t\tcreateNodeGroupResults := make([]nodegroups.CreateNodeGroupResult, 0)\n\t\n\t\t// 如果节点组在云服务商端处不存在，会尝试创建根据现有信息重新创建一个云端节点组\n\t\t// 但是目前所有的 CloudProvider 实现都没有允许这种操作，这好像是个多余的方法\n\t\t// 云服务商不想，也不应该将云端节点组的创建权限交给 ClusterAutoscaler\n\t\tif !bestOption.NodeGroup.Exist() {\n\t\t\toldId := bestOption.NodeGroup.Id()\n\t\t\tcreateNodeGroupResult, err := processors.NodeGroupManager.CreateNodeGroup(context, bestOption.NodeGroup)\n\t\t......\n\t\t}\n\n\t\t// 得到最佳节点组的示例节点\n\t\tnodeInfo, found := nodeInfos[bestOption.NodeGroup.Id()]\n\t\tif !found {\n\t\t\t// This should never happen, as we already should have retrieved\n\t\t\t// nodeInfo for any considered nodegroup.\n\t\t\tklog.Errorf(\"No node info for: %s\", bestOption.NodeGroup.Id())\n\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, errors.NewAutoscalerError(\n\t\t\t\terrors.CloudProviderError,\n\t\t\t\t\"No node info for best expansion option!\")\n\t\t}\n\n\t\t// 根据 CPU、Memory及可能存在的 GPU 资源（hack: we assume anything which is not cpu/memory to be a gpu.），计算出需要多少个 Nodes\n\t\tnewNodes, err = applyScaleUpResourcesLimits(context.CloudProvider, newNodes, scaleUpResourcesLeft, nodeInfo, bestOption.NodeGroup, resourceLimiter)\n\t\tif err != nil {\n\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, err\n\t\t}\n\n\t\t// 需要平衡的节点组\n\t\ttargetNodeGroups := []cloudprovider.NodeGroup{bestOption.NodeGroup}\n\t\t// 如果需要平衡节点组，根据 balance-similar-node-groups flag 设置。\n\t\t// 检测相似的节点组，并平衡它们之间的节点数量\n\t\tif context.BalanceSimilarNodeGroups {\n\t\t......\n\t\t}\n\t\t// 具体平衡策略可以看 (b *BalancingNodeGroupSetProcessor) BalanceScaleUpBetweenGroups 方法\n\t\tscaleUpInfos, typedErr := processors.NodeGroupSetProcessor.BalanceScaleUpBetweenGroups(context, targetNodeGroups, newNodes)\n\t\tif typedErr != nil {\n\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, typedErr\n\t\t}\n\t\tklog.V(1).Infof(\"Final scale-up plan: %v\", scaleUpInfos)\n\t\t// 开始扩容，通过 IncreaseSize 扩容\n\t\tfor _, info := range scaleUpInfos {\n\t\t\ttypedErr := executeScaleUp(context, clusterStateRegistry, info, gpu.GetGpuTypeForMetrics(gpuLabel, availableGPUTypes, nodeInfo.Node(), nil), now)\n\t\t\tif typedErr != nil {\n\t\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, typedErr\n\t\t\t}\n\t\t}\n\t\t......\n\t}\n\t......\n}\n\n\n```","source":"_posts/KubernetesClusterAutoscaler.md","raw":"---\ntitle: Kubernetes Cluster Autoscaler\ndate: 2020/3/31 00:00:00\n---\n\n当我们使用 Kubernetes 部署应用后，会发现如果用户增长速度超过预期，以至于计算资源不够时，你会怎么做呢？Kubernetes 给出的解决方案就是：自动伸缩（auto-scaling），通过自动伸缩组件之间的配合，可以 7*24 小时的监控着你的集群，动态变化负载，以适应你的用户需求。\n\n<!--more-->\t\n\n\n## 自动伸缩组件\n\n**水平自动伸缩（Horizontal Pod Autoscaler，HPA）**\n\nHPA 可以基于实时的 CPU 利用率自动伸缩 Replication Controller、Deployment 和 Replica Set 中的 Pod 数量。也可以通过搭配 Metrics Server 基于其他的度量指标。\n\n**垂直自动伸缩（Vertical Pod Autoscaler，VPA）**\n\nVPA 可以基于 Pod 的使用资源来自动设置 Pod 所需资源并且能够在运行时自动调整资源。\n\n**集群自动伸缩（Cluster Autoscaler，CA）**\n\nCA 是一个可以自动伸缩集群 Node 的组件。如果集群中有未被调度的 Pod，它将会自动扩展 Node 来使 Pod 可用，或是在发现集群中的 Node 资源使用率过低时，删除 Node 来节约资源。\n\n**插件伸缩（Addon Resizer）**\n\n这是一个小插件，它以 Sidecar 的形式来垂直伸缩与自己同一个部署中的另一个容器，目前唯一的策略就是根据集群中节点的数量来进行线性扩展。通常与 [Metrics Server](https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/metrics-server/metrics-server-deployment.yaml#L66) 配合使用，以保证其可以负担不断扩大的整个集群的 metrics API 服务。\n\n通过 HPA 伸缩无状态应用，VPA 伸缩有状态应用，CA 保证计算资源，它们的配合使用，构成了一个完整的自动伸缩解决方案。\n\n\n\n## Cluster Autoscaler 详细介绍\n\n上面介绍的四个组件中，HPA 是在 kubernetes 代码仓库中的，随着 kubernetes 的版本进行更新发布，不需要部署，可以直接使用。其他的三个组件都在官方社区维护的[仓库](https://github.com/kubernetes/autoscaler)中，Cluster Autoscaler 的 v1.0(GA) 版本已经随着 kubernetes 1.8 一起发布，剩下两个则还是 beta 版本。\n\n\n\n### 部署\n\nCluster Autoscaler 通常需要搭配云厂商使用，它提供了 `Cloud Provider` 接口供各个云厂商接入，云厂商通过伸缩组（Scaling Group）或节点池（Node Pool）的功能对 ECS 类产品节点进行增加删除等操作。\n\n目前（v1.18.1）已接入的云厂商：\n\n**Alicloud：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md\n\n**Aws：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md\n\n**Azure：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md\n\n**Baiducloud：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/baiducloud/README.md\n\n**Digitalocean：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/digitalocean/README.md\n\n**GoogleCloud GCE：**https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#upgrading-google-compute-engine-clusters\n\n**GoogleCloud GKE：**https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler\n\n**OpenStack Magnum：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/magnum/README.md\n\n**Packet：**https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/packet/README.md\n\n\n启动参数列表：https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca\n\n\n\n### 工作原理\n\nCluster Autoscaler 抽象出了一个 `NodeGroup` 的概念，与之对应的是云厂商的伸缩组服务。Cluster Autoscaler 通过 `CloudProvider` 提供的 `NodeGroup` 计算集群内节点资源，以此来进行伸缩。\n\n在启动后，Cluster Autoscaler 会定期（默认 10s）检查未调度的 Pod 和 Node 的资源使用情况，并进行相应的 `Scale UP` 和 `Scale Down` 操作。\n\n#### Scale UP\n\n当 Cluster Autoscaler 发现有 Pod 由于资源不足而无法调度时，就会通过调用 `Scale UP` 执行扩容操作。\n\n在 `Scale UP` 中会只会计算在 `NodeGroup` 中存在的 Node，我们可以将 Worker Node 统一交由伸缩组进行管理。并且由于伸缩组非同步加入的特性，也会考虑到 Upcoming Node。\n\n为了业务需要，集群中可能会有不同规格的 Node，我们可以创建多个 `NodeGroup`，在扩容时会根据 `--expander` 选项配置指定的策略，选择一个扩容的节点组，支持如下[五种策略](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)：\n\n* **random：**随机选择一个 `NodeGroup`。如果未指定，则默认为此策略。\n* **most-pods：**选择能够调度最多 Pod 的 `NodeGroup`，比如有的 Pod 未调度是因为 `nodeSelector`，此策略会优先选择能满足的 `NodeGroup` 来保证大多数的 Pod 可以被调度。\n* **least-waste：**为避免浪费，此策略会优先选择能满足 Pod 需求资源的最小资源类型的 `NodeGroup`。\n* **price：**根据 `CloudProvider` 提供的价格模型，选择最省钱的 `NodeGroup`。\n* **priority：**通过配置优先级来进行选择，用起来比较麻烦，需要额外的配置，可以看[文档](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md)。\n\n如果有需要，也可以平衡相似 `NodeGroup` 中的\tNode 数量，避免 `NodeGroup` 达到 `MaxSize` 而导致无法加入新 Node。通过 `--balance-similar-node-groups` 选项配置，默认为 `false`。\n\n再经过一系列的操作后，最终计算出要扩容的 Node 数量及 `NodeGroup`，使用 `CloudProvider` 执行 `IncreaseSize` 操作，增加云厂商的伸缩组大小，从而完成扩容操作。\n\n*文字表达能力不足，如果有不清晰的地方，可以参考下面的 [ScaleUP 源码解析](#ScaleUP源码解析)。*\n\n#### Scale Down\n\n缩容是一个可选的功能，通过 `--scale-down-enabled` 选项配置，默认为 `true`。\n\n在 Cluster Autoscaler 监控 Node 资源时，如果发现有 Node 满足以下三个条件时，就会标记这个 Node 为 `unneeded`：\n\n* Node 上运行的所有的 Pod 的 Cpu 和内存之和小于该 Node 可分配容量的 50%。可通过 `--scale-down-utilization-threshold` 选项改变这个配置。\n* Node 上所有的 Pod 都可以被调度到其他节点。\n* Node 没有表示不可缩容的 annotaition。\n\n如果一个 Node 被标记为 `unneeded` 超过 10 分钟（可通过 `--scale-down-unneeded-time` 选项配置），则使用 `CloudProvider` 执行 `DeleteNodes` 操作将其删除。一次最多删除一个 `unneeded Node`，但空 Node 可以批量删除，每次最多删除 10 个（通过 `----max-empty-bulk-delete` 选项配置）。\n\n实际上并不是只有这一个判定条件，还会有其他的条件来阻止删除这个 Node，比如 `NodeGroup` 已达到 `MinSize`，或在过去的 10 分钟内有过一次 `Scale UP` 操作（通过 `--scale-down-delay-after-add` 选项配置）等等，更详细可查看[文档](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-down-work)。\n\n\n\nCluster Autoscaler 的工作机制很复杂，但其中大部分都能通过 flags 进行配置，如果有需要，请详细阅读文档：https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md\n\n\n\n## 如何实现 CloudProvider\n\n如果使用上述中已实现接入的云厂商，只需要通过 `--cloud-provider` 选项指定来自哪个云厂商就可以，如果想要对接自己的 IaaS 或有特定的业务逻辑，就需要自己实现 `CloudProvider Interface` 与 `NodeGroupInterface`。并将其注册到 `builder` 中，用于通过 `--cloud-provider` 参数指定。\n\n`builder` 在 `cloudprovider/builder` 中的 [builder_all.go](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/builder/builder_all.go) 中注册，也可以在其中新建一个自己的 `build`，通过 go 文件的 `+build` 编译参数来指定使用的 `CloudProvider`。\n\n`CloudProvider` 接口与 `NodeGroup` 接口在 [cloud_provider.go](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/cloud_provider.go) 中定义，其中需要注意的是 `Refresh` 方法，它会在每一次循环（默认 10 秒）的开始时调用，可在此时请求接口并刷新 `NodeGroup` 状态，通常的做法是增加一个 `manager` 用于管理状态。有不理解的部分可参考其他 `CloudProvider` 的实现。\n\n```go\ntype CloudProvider interface {\n\t// Name returns name of the cloud provider.\n\tName() string\n\n\t// NodeGroups returns all node groups configured for this cloud provider.\n\t// 会在一此循环中多次调用此方法，所以不适合每次都请求云厂商服务，可以在 Refresh 时存储状态\n\tNodeGroups() []NodeGroup\n\n\t// NodeGroupForNode returns the node group for the given node, nil if the node\n\t// should not be processed by cluster autoscaler, or non-nil error if such\n\t// occurred. Must be implemented.\n\t// 同上\n\tNodeGroupForNode(*apiv1.Node) (NodeGroup, error)\n\n\t// Pricing returns pricing model for this cloud provider or error if not available.\n\t// Implementation optional.\n\t// 如果不使用 price expander 就可以不实现此方法\n\tPricing() (PricingModel, errors.AutoscalerError)\n\n\t// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.\n\t// Implementation optional.\n\t// 没用，不需要实现\n\tGetAvailableMachineTypes() ([]string, error)\n\n\t// NewNodeGroup builds a theoretical node group based on the node definition provided. The node group is not automatically\n\t// created on the cloud provider side. The node group is not returned by NodeGroups() until it is created.\n\t// Implementation optional.\n\t// 通常情况下，不需要实现此方法，但如果你需要 ClusterAutoscaler 创建一个默认的 NodeGroup 的话，也可以实现。\n\t// 但其实更好的做法是将默认 NodeGroup 写入云端的伸缩组\n\tNewNodeGroup(machineType string, labels map[string]string, systemLabels map[string]string,\n\t\ttaints []apiv1.Taint, extraResources map[string]resource.Quantity) (NodeGroup, error)\n\n\t// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).\n\t// 资源限制对象，会在 build 时传入，通常情况下不需要更改，除非在云端有显示的提示用户更改的地方，否则使用时会迷惑用户\n\tGetResourceLimiter() (*ResourceLimiter, error)\n\n\t// GPULabel returns the label added to nodes with GPU resource.\n\t// GPU 相关，如果集群中有使用 GPU 资源，需要返回对应内容。 hack: we assume anything which is not cpu/memory to be a gpu.\n\tGPULabel() string\n\n\t// GetAvailableGPUTypes return all available GPU types cloud provider supports.\n\t// 同上\n\tGetAvailableGPUTypes() map[string]struct{}\n\n\t// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.\n\t// CloudProvider 只会在启动时被初始化一次，如果每次循环后有需要清除的内容，在这里处理\n\tCleanup() error\n\n\t// Refresh is called before every main loop and can be used to dynamically update cloud provider state.\n\t// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().\n\t// 会在 StaticAutoscaler RunOnce 中被调用\n\tRefresh() error\n}\n// NodeGroup contains configuration info and functions to control a set\n// of nodes that have the same capacity and set of labels.\ntype NodeGroup interface {\n\t// MaxSize returns maximum size of the node group.\n\tMaxSize() int\n\n\t// MinSize returns minimum size of the node group.\n\tMinSize() int\n\n\t// TargetSize returns the current target size of the node group. It is possible that the\n\t// number of nodes in Kubernetes is different at the moment but should be equal\n\t// to Size() once everything stabilizes (new nodes finish startup and registration or\n\t// removed nodes are deleted completely). Implementation required.\n\t// 响应的是伸缩组的节点数，并不一定与 kubernetes 中的节点数保持一致\n\tTargetSize() (int, error)\n\n\t// IncreaseSize increases the size of the node group. To delete a node you need\n\t// to explicitly name it and use DeleteNode. This function should wait until\n\t// node group size is updated. Implementation required.\n\t// 扩容的方法，增加伸缩组的节点数\n\tIncreaseSize(delta int) error\n\n\t// DeleteNodes deletes nodes from this node group. Error is returned either on\n\t// failure or if the given node doesn't belong to this node group. This function\n\t// should wait until node group size is updated. Implementation required.\n\t// 删除的节点一定要在该节点组中\n\tDeleteNodes([]*apiv1.Node) error\n\n\t// DecreaseTargetSize decreases the target size of the node group. This function\n\t// doesn't permit to delete any existing node and can be used only to reduce the\n\t// request for new nodes that have not been yet fulfilled. Delta should be negative.\n\t// It is assumed that cloud provider will not delete the existing nodes when there\n\t// is an option to just decrease the target. Implementation required.\n\t// 当 ClusterAutoscaler 发现 kubernetes 节点数与伸缩组的节点数长时间不一致，会调用此方法来调整\n\tDecreaseTargetSize(delta int) error\n\n\t// Id returns an unique identifier of the node group.\n\tId() string\n\n\t// Debug returns a string containing all information regarding this node group.\n\tDebug() string\n\n\t// Nodes returns a list of all nodes that belong to this node group.\n\t// It is required that Instance objects returned by this method have Id field set.\n\t// Other fields are optional.\n\t// This list should include also instances that might have not become a kubernetes node yet.\n\t// 返回伸缩组中的所有节点，哪怕它还没有成为 kubernetes 的节点\n\tNodes() ([]Instance, error)\n\n\t// TemplateNodeInfo returns a schedulernodeinfo.NodeInfo structure of an empty\n\t// (as if just started) node. This will be used in scale-up simulations to\n\t// predict what would a new node look like if a node group was expanded. The returned\n\t// NodeInfo is expected to have a fully populated Node object, with all of the labels,\n\t// capacity and allocatable information as well as all pods that are started on\n\t// the node by default, using manifest (most likely only kube-proxy). Implementation optional.\n\t// ClusterAutoscaler 会将节点信息与节点组对应，来判断资源条件，如果是一个空的节点组，那么就会通过此方法来虚拟一个节点信息。\n\tTemplateNodeInfo() (*schedulernodeinfo.NodeInfo, error)\n\n\t// Exist checks if the node group really exists on the cloud provider side. Allows to tell the\n\t// theoretical node group from the real one. Implementation required.\n\tExist() bool\n\n\t// Create creates the node group on the cloud provider side. Implementation optional.\n\t// 与 CloudProvider.NewNodeGroup 配合使用\n\tCreate() (NodeGroup, error)\n\n\t// Delete deletes the node group on the cloud provider side.\n\t// This will be executed only for autoprovisioned node groups, once their size drops to 0.\n\t// Implementation optional.\n\tDelete() error\n\n\t// Autoprovisioned returns true if the node group is autoprovisioned. An autoprovisioned group\n\t// was created by CA and can be deleted when scaled to 0.\n\tAutoprovisioned() bool\n}\n```\n\n\n\n## ScaleUP 源码解析\n\n```go\nfunc ScaleUp(context *context.AutoscalingContext, processors *ca_processors.AutoscalingProcessors, clusterStateRegistry *clusterstate.ClusterStateRegistry, unschedulablePods []*apiv1.Pod, nodes []*apiv1.Node, daemonSets []*appsv1.DaemonSet, nodeInfos map[string]*schedulernodeinfo.NodeInfo, ignoredTaints taints.TaintKeySet) (*status.ScaleUpStatus, errors.AutoscalerError) {\n\t\n\t......\n\t// 验证当前集群中所有 ready node 是否来自于 nodeGroups，取得所有非组内的 node\n\tnodesFromNotAutoscaledGroups, err := utils.FilterOutNodesFromNotAutoscaledGroups(nodes, context.CloudProvider)\n\tif err != nil {\n\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, err.AddPrefix(\"failed to filter out nodes which are from not autoscaled groups: \")\n\t}\n\n\tnodeGroups := context.CloudProvider.NodeGroups()\n\tgpuLabel := context.CloudProvider.GPULabel()\n\tavailableGPUTypes := context.CloudProvider.GetAvailableGPUTypes()\n\n\t// 资源限制对象，会在 build cloud provider 时传入\n\t// 如果有需要可在 CloudProvider 中自行更改，但不建议改动，会对用户造成迷惑\n\tresourceLimiter, errCP := context.CloudProvider.GetResourceLimiter()\n\tif errCP != nil {\n\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, errors.ToAutoscalerError(\n\t\t\terrors.CloudProviderError,\n\t\t\terrCP)\n\t}\n\n\t// 计算资源限制\n\t// nodeInfos 是所有拥有节点组的节点与示例节点的映射\n\t// 示例节点会优先考虑真实节点的数据，如果 NodeGroup 中还没有真实节点的部署，则使用 Template 的节点数据\n\tscaleUpResourcesLeft, errLimits := computeScaleUpResourcesLeftLimits(context.CloudProvider, nodeGroups, nodeInfos, nodesFromNotAutoscaledGroups, resourceLimiter)\n\tif errLimits != nil {\n\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, errLimits.AddPrefix(\"Could not compute total resources: \")\n\t}\n\n\t// 根据当前节点与 NodeGroups 中的节点来计算会有多少节点即将加入集群中\n\t// 由于云服务商的伸缩组 increase size 操作并不是同步加入 node，所以将其统计，以便于后面计算节点资源\n\tupcomingNodes := make([]*schedulernodeinfo.NodeInfo, 0)\n\tfor nodeGroup, numberOfNodes := range clusterStateRegistry.GetUpcomingNodes() {\n\t\t......\n\t}\n\tklog.V(4).Infof(\"Upcoming %d nodes\", len(upcomingNodes))\n\n\t// 最终会进入选择的节点组\n\texpansionOptions := make(map[string]expander.Option, 0)\n\t......\n\t// 出于某些限制或错误导致不能加入新节点的节点组，例如节点组已达到 MaxSize\n\tskippedNodeGroups := map[string]status.Reasons{}\n\t// 综合各种情况，筛选出节点组\n\tfor _, nodeGroup := range nodeGroups {\n\t......\n\t}\n\tif len(expansionOptions) == 0 {\n\t\tklog.V(1).Info(\"No expansion options\")\n\t\treturn &status.ScaleUpStatus{\n\t\t\tResult:\t\t\t\t\tstatus.ScaleUpNoOptionsAvailable,\n\t\t\tPodsRemainUnschedulable: getRemainingPods(podEquivalenceGroups, skippedNodeGroups),\n\t\t\tConsideredNodeGroups:\tnodeGroups,\n\t\t}, nil\n\t}\n\n\t......\n\t// 选择一个最佳的节点组进行扩容，expander 用于选择一个合适的节点组进行扩容，默认为 RandomExpander，flag: expander\n\t// random 随机选一个，适合只有一个节点组\n\t// most-pods 选择能够调度最多 pod 的节点组，比如有 noSchedulerPods 是有 nodeSelector 的，它会优先选择此类节点组以满足大多数 pod 的需求\n\t// least-waste 优先选择能满足 pod 需求资源的最小资源类型的节点组\n\t// price 根据价格模型，选择最省钱的\n\t// priority 根据优先级选择\n\tbestOption := context.ExpanderStrategy.BestOption(options, nodeInfos)\n\tif bestOption != nil && bestOption.NodeCount > 0 {\n\t......\n\t\tnewNodes := bestOption.NodeCount\n\n\t\t// 考虑到 upcomingNodes, 重新计算本次新加入节点\n\t\tif context.MaxNodesTotal > 0 && len(nodes)+newNodes+len(upcomingNodes) > context.MaxNodesTotal {\n\t\t\tklog.V(1).Infof(\"Capping size to max cluster total size (%d)\", context.MaxNodesTotal)\n\t\t\tnewNodes = context.MaxNodesTotal - len(nodes) - len(upcomingNodes)\n\t\t\tif newNodes < 1 {\n\t\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError}, errors.NewAutoscalerError(\n\t\t\t\t\terrors.TransientError,\n\t\t\t\t\t\"max node total count already reached\")\n\t\t\t}\n\t\t}\n\n\t\tcreateNodeGroupResults := make([]nodegroups.CreateNodeGroupResult, 0)\n\t\n\t\t// 如果节点组在云服务商端处不存在，会尝试创建根据现有信息重新创建一个云端节点组\n\t\t// 但是目前所有的 CloudProvider 实现都没有允许这种操作，这好像是个多余的方法\n\t\t// 云服务商不想，也不应该将云端节点组的创建权限交给 ClusterAutoscaler\n\t\tif !bestOption.NodeGroup.Exist() {\n\t\t\toldId := bestOption.NodeGroup.Id()\n\t\t\tcreateNodeGroupResult, err := processors.NodeGroupManager.CreateNodeGroup(context, bestOption.NodeGroup)\n\t\t......\n\t\t}\n\n\t\t// 得到最佳节点组的示例节点\n\t\tnodeInfo, found := nodeInfos[bestOption.NodeGroup.Id()]\n\t\tif !found {\n\t\t\t// This should never happen, as we already should have retrieved\n\t\t\t// nodeInfo for any considered nodegroup.\n\t\t\tklog.Errorf(\"No node info for: %s\", bestOption.NodeGroup.Id())\n\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, errors.NewAutoscalerError(\n\t\t\t\terrors.CloudProviderError,\n\t\t\t\t\"No node info for best expansion option!\")\n\t\t}\n\n\t\t// 根据 CPU、Memory及可能存在的 GPU 资源（hack: we assume anything which is not cpu/memory to be a gpu.），计算出需要多少个 Nodes\n\t\tnewNodes, err = applyScaleUpResourcesLimits(context.CloudProvider, newNodes, scaleUpResourcesLeft, nodeInfo, bestOption.NodeGroup, resourceLimiter)\n\t\tif err != nil {\n\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, err\n\t\t}\n\n\t\t// 需要平衡的节点组\n\t\ttargetNodeGroups := []cloudprovider.NodeGroup{bestOption.NodeGroup}\n\t\t// 如果需要平衡节点组，根据 balance-similar-node-groups flag 设置。\n\t\t// 检测相似的节点组，并平衡它们之间的节点数量\n\t\tif context.BalanceSimilarNodeGroups {\n\t\t......\n\t\t}\n\t\t// 具体平衡策略可以看 (b *BalancingNodeGroupSetProcessor) BalanceScaleUpBetweenGroups 方法\n\t\tscaleUpInfos, typedErr := processors.NodeGroupSetProcessor.BalanceScaleUpBetweenGroups(context, targetNodeGroups, newNodes)\n\t\tif typedErr != nil {\n\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, typedErr\n\t\t}\n\t\tklog.V(1).Infof(\"Final scale-up plan: %v\", scaleUpInfos)\n\t\t// 开始扩容，通过 IncreaseSize 扩容\n\t\tfor _, info := range scaleUpInfos {\n\t\t\ttypedErr := executeScaleUp(context, clusterStateRegistry, info, gpu.GetGpuTypeForMetrics(gpuLabel, availableGPUTypes, nodeInfo.Node(), nil), now)\n\t\t\tif typedErr != nil {\n\t\t\t\treturn &status.ScaleUpStatus{Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults}, typedErr\n\t\t\t}\n\t\t}\n\t\t......\n\t}\n\t......\n}\n\n\n```","slug":"KubernetesClusterAutoscaler","published":1,"updated":"2020-07-23T00:39:53.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea2000bcyze79d9ho6v","content":"<p>当我们使用 Kubernetes 部署应用后，会发现如果用户增长速度超过预期，以至于计算资源不够时，你会怎么做呢？Kubernetes 给出的解决方案就是：自动伸缩（auto-scaling），通过自动伸缩组件之间的配合，可以 7*24 小时的监控着你的集群，动态变化负载，以适应你的用户需求。</p>\n<a id=\"more\"></a>    \n<h2 id=\"自动伸缩组件\"><a href=\"#自动伸缩组件\" class=\"headerlink\" title=\"自动伸缩组件\"></a>自动伸缩组件</h2><p><strong>水平自动伸缩（Horizontal Pod Autoscaler，HPA）</strong></p>\n<p>HPA 可以基于实时的 CPU 利用率自动伸缩 Replication Controller、Deployment 和 Replica Set 中的 Pod 数量。也可以通过搭配 Metrics Server 基于其他的度量指标。</p>\n<p><strong>垂直自动伸缩（Vertical Pod Autoscaler，VPA）</strong></p>\n<p>VPA 可以基于 Pod 的使用资源来自动设置 Pod 所需资源并且能够在运行时自动调整资源。</p>\n<p><strong>集群自动伸缩（Cluster Autoscaler，CA）</strong></p>\n<p>CA 是一个可以自动伸缩集群 Node 的组件。如果集群中有未被调度的 Pod，它将会自动扩展 Node 来使 Pod 可用，或是在发现集群中的 Node 资源使用率过低时，删除 Node 来节约资源。</p>\n<p><strong>插件伸缩（Addon Resizer）</strong></p>\n<p>这是一个小插件，它以 Sidecar 的形式来垂直伸缩与自己同一个部署中的另一个容器，目前唯一的策略就是根据集群中节点的数量来进行线性扩展。通常与 <a href=\"https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/metrics-server/metrics-server-deployment.yaml#L66\" target=\"_blank\" rel=\"noopener\">Metrics Server</a> 配合使用，以保证其可以负担不断扩大的整个集群的 metrics API 服务。</p>\n<p>通过 HPA 伸缩无状态应用，VPA 伸缩有状态应用，CA 保证计算资源，它们的配合使用，构成了一个完整的自动伸缩解决方案。</p>\n<h2 id=\"Cluster-Autoscaler-详细介绍\"><a href=\"#Cluster-Autoscaler-详细介绍\" class=\"headerlink\" title=\"Cluster Autoscaler 详细介绍\"></a>Cluster Autoscaler 详细介绍</h2><p>上面介绍的四个组件中，HPA 是在 kubernetes 代码仓库中的，随着 kubernetes 的版本进行更新发布，不需要部署，可以直接使用。其他的三个组件都在官方社区维护的<a href=\"https://github.com/kubernetes/autoscaler\" target=\"_blank\" rel=\"noopener\">仓库</a>中，Cluster Autoscaler 的 v1.0(GA) 版本已经随着 kubernetes 1.8 一起发布，剩下两个则还是 beta 版本。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>Cluster Autoscaler 通常需要搭配云厂商使用，它提供了 <code>Cloud Provider</code> 接口供各个云厂商接入，云厂商通过伸缩组（Scaling Group）或节点池（Node Pool）的功能对 ECS 类产品节点进行增加删除等操作。</p>\n<p>目前（v1.18.1）已接入的云厂商：</p>\n<p><strong>Alicloud：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md</a></p>\n<p><strong>Aws：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md</a></p>\n<p><strong>Azure：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md</a></p>\n<p><strong>Baiducloud：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/baiducloud/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/baiducloud/README.md</a></p>\n<p><strong>Digitalocean：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/digitalocean/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/digitalocean/README.md</a></p>\n<p><strong>GoogleCloud GCE：</strong><a href=\"https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#upgrading-google-compute-engine-clusters\" target=\"_blank\" rel=\"noopener\">https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#upgrading-google-compute-engine-clusters</a></p>\n<p><strong>GoogleCloud GKE：</strong><a href=\"https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler\" target=\"_blank\" rel=\"noopener\">https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler</a></p>\n<p><strong>OpenStack Magnum：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/magnum/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/magnum/README.md</a></p>\n<p><strong>Packet：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/packet/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/packet/README.md</a></p>\n<p>启动参数列表：<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca</a></p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>Cluster Autoscaler 抽象出了一个 <code>NodeGroup</code> 的概念，与之对应的是云厂商的伸缩组服务。Cluster Autoscaler 通过 <code>CloudProvider</code> 提供的 <code>NodeGroup</code> 计算集群内节点资源，以此来进行伸缩。</p>\n<p>在启动后，Cluster Autoscaler 会定期（默认 10s）检查未调度的 Pod 和 Node 的资源使用情况，并进行相应的 <code>Scale UP</code> 和 <code>Scale Down</code> 操作。</p>\n<h4 id=\"Scale-UP\"><a href=\"#Scale-UP\" class=\"headerlink\" title=\"Scale UP\"></a>Scale UP</h4><p>当 Cluster Autoscaler 发现有 Pod 由于资源不足而无法调度时，就会通过调用 <code>Scale UP</code> 执行扩容操作。</p>\n<p>在 <code>Scale UP</code> 中会只会计算在 <code>NodeGroup</code> 中存在的 Node，我们可以将 Worker Node 统一交由伸缩组进行管理。并且由于伸缩组非同步加入的特性，也会考虑到 Upcoming Node。</p>\n<p>为了业务需要，集群中可能会有不同规格的 Node，我们可以创建多个 <code>NodeGroup</code>，在扩容时会根据 <code>--expander</code> 选项配置指定的策略，选择一个扩容的节点组，支持如下<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders\" target=\"_blank\" rel=\"noopener\">五种策略</a>：</p>\n<ul>\n<li><strong>random：</strong>随机选择一个 <code>NodeGroup</code>。如果未指定，则默认为此策略。</li>\n<li><strong>most-pods：</strong>选择能够调度最多 Pod 的 <code>NodeGroup</code>，比如有的 Pod 未调度是因为 <code>nodeSelector</code>，此策略会优先选择能满足的 <code>NodeGroup</code> 来保证大多数的 Pod 可以被调度。</li>\n<li><strong>least-waste：</strong>为避免浪费，此策略会优先选择能满足 Pod 需求资源的最小资源类型的 <code>NodeGroup</code>。</li>\n<li><strong>price：</strong>根据 <code>CloudProvider</code> 提供的价格模型，选择最省钱的 <code>NodeGroup</code>。</li>\n<li><strong>priority：</strong>通过配置优先级来进行选择，用起来比较麻烦，需要额外的配置，可以看<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n</ul>\n<p>如果有需要，也可以平衡相似 <code>NodeGroup</code> 中的    Node 数量，避免 <code>NodeGroup</code> 达到 <code>MaxSize</code> 而导致无法加入新 Node。通过 <code>--balance-similar-node-groups</code> 选项配置，默认为 <code>false</code>。</p>\n<p>再经过一系列的操作后，最终计算出要扩容的 Node 数量及 <code>NodeGroup</code>，使用 <code>CloudProvider</code> 执行 <code>IncreaseSize</code> 操作，增加云厂商的伸缩组大小，从而完成扩容操作。</p>\n<p><em>文字表达能力不足，如果有不清晰的地方，可以参考下面的 <a href=\"#ScaleUP源码解析\">ScaleUP 源码解析</a>。</em></p>\n<h4 id=\"Scale-Down\"><a href=\"#Scale-Down\" class=\"headerlink\" title=\"Scale Down\"></a>Scale Down</h4><p>缩容是一个可选的功能，通过 <code>--scale-down-enabled</code> 选项配置，默认为 <code>true</code>。</p>\n<p>在 Cluster Autoscaler 监控 Node 资源时，如果发现有 Node 满足以下三个条件时，就会标记这个 Node 为 <code>unneeded</code>：</p>\n<ul>\n<li>Node 上运行的所有的 Pod 的 Cpu 和内存之和小于该 Node 可分配容量的 50%。可通过 <code>--scale-down-utilization-threshold</code> 选项改变这个配置。</li>\n<li>Node 上所有的 Pod 都可以被调度到其他节点。</li>\n<li>Node 没有表示不可缩容的 annotaition。</li>\n</ul>\n<p>如果一个 Node 被标记为 <code>unneeded</code> 超过 10 分钟（可通过 <code>--scale-down-unneeded-time</code> 选项配置），则使用 <code>CloudProvider</code> 执行 <code>DeleteNodes</code> 操作将其删除。一次最多删除一个 <code>unneeded Node</code>，但空 Node 可以批量删除，每次最多删除 10 个（通过 <code>----max-empty-bulk-delete</code> 选项配置）。</p>\n<p>实际上并不是只有这一个判定条件，还会有其他的条件来阻止删除这个 Node，比如 <code>NodeGroup</code> 已达到 <code>MinSize</code>，或在过去的 10 分钟内有过一次 <code>Scale UP</code> 操作（通过 <code>--scale-down-delay-after-add</code> 选项配置）等等，更详细可查看<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-down-work\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>Cluster Autoscaler 的工作机制很复杂，但其中大部分都能通过 flags 进行配置，如果有需要，请详细阅读文档：<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md</a></p>\n<h2 id=\"如何实现-CloudProvider\"><a href=\"#如何实现-CloudProvider\" class=\"headerlink\" title=\"如何实现 CloudProvider\"></a>如何实现 CloudProvider</h2><p>如果使用上述中已实现接入的云厂商，只需要通过 <code>--cloud-provider</code> 选项指定来自哪个云厂商就可以，如果想要对接自己的 IaaS 或有特定的业务逻辑，就需要自己实现 <code>CloudProvider Interface</code> 与 <code>NodeGroupInterface</code>。并将其注册到 <code>builder</code> 中，用于通过 <code>--cloud-provider</code> 参数指定。</p>\n<p><code>builder</code> 在 <code>cloudprovider/builder</code> 中的 <a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/builder/builder_all.go\" target=\"_blank\" rel=\"noopener\">builder_all.go</a> 中注册，也可以在其中新建一个自己的 <code>build</code>，通过 go 文件的 <code>+build</code> 编译参数来指定使用的 <code>CloudProvider</code>。</p>\n<p><code>CloudProvider</code> 接口与 <code>NodeGroup</code> 接口在 <a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/cloud_provider.go\" target=\"_blank\" rel=\"noopener\">cloud_provider.go</a> 中定义，其中需要注意的是 <code>Refresh</code> 方法，它会在每一次循环（默认 10 秒）的开始时调用，可在此时请求接口并刷新 <code>NodeGroup</code> 状态，通常的做法是增加一个 <code>manager</code> 用于管理状态。有不理解的部分可参考其他 <code>CloudProvider</code> 的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CloudProvider <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Name returns name of the cloud provider.</span></span><br><span class=\"line\">\tName() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// NodeGroups returns all node groups configured for this cloud provider.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 会在一此循环中多次调用此方法，所以不适合每次都请求云厂商服务，可以在 Refresh 时存储状态</span></span><br><span class=\"line\">\tNodeGroups() []NodeGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// NodeGroupForNode returns the node group for the given node, nil if the node</span></span><br><span class=\"line\">\t<span class=\"comment\">// should not be processed by cluster autoscaler, or non-nil error if such</span></span><br><span class=\"line\">\t<span class=\"comment\">// occurred. Must be implemented.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 同上</span></span><br><span class=\"line\">\tNodeGroupForNode(*apiv1.Node) (NodeGroup, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Pricing returns pricing model for this cloud provider or error if not available.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果不使用 price expander 就可以不实现此方法</span></span><br><span class=\"line\">\tPricing() (PricingModel, errors.AutoscalerError)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 没用，不需要实现</span></span><br><span class=\"line\">\tGetAvailableMachineTypes() ([]<span class=\"keyword\">string</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// NewNodeGroup builds a theoretical node group based on the node definition provided. The node group is not automatically</span></span><br><span class=\"line\">\t<span class=\"comment\">// created on the cloud provider side. The node group is not returned by NodeGroups() until it is created.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 通常情况下，不需要实现此方法，但如果你需要 ClusterAutoscaler 创建一个默认的 NodeGroup 的话，也可以实现。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 但其实更好的做法是将默认 NodeGroup 写入云端的伸缩组</span></span><br><span class=\"line\">\tNewNodeGroup(machineType <span class=\"keyword\">string</span>, labels <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>, systemLabels <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>,</span><br><span class=\"line\">\t\ttaints []apiv1.Taint, extraResources <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]resource.Quantity) (NodeGroup, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).</span></span><br><span class=\"line\">\t<span class=\"comment\">// 资源限制对象，会在 build 时传入，通常情况下不需要更改，除非在云端有显示的提示用户更改的地方，否则使用时会迷惑用户</span></span><br><span class=\"line\">\tGetResourceLimiter() (*ResourceLimiter, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GPULabel returns the label added to nodes with GPU resource.</span></span><br><span class=\"line\">\t<span class=\"comment\">// GPU 相关，如果集群中有使用 GPU 资源，需要返回对应内容。 hack: we assume anything which is not cpu/memory to be a gpu.</span></span><br><span class=\"line\">\tGPULabel() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GetAvailableGPUTypes return all available GPU types cloud provider supports.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 同上</span></span><br><span class=\"line\">\tGetAvailableGPUTypes() <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.</span></span><br><span class=\"line\">\t<span class=\"comment\">// CloudProvider 只会在启动时被初始化一次，如果每次循环后有需要清除的内容，在这里处理</span></span><br><span class=\"line\">\tCleanup() error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Refresh is called before every main loop and can be used to dynamically update cloud provider state.</span></span><br><span class=\"line\">\t<span class=\"comment\">// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().</span></span><br><span class=\"line\">\t<span class=\"comment\">// 会在 StaticAutoscaler RunOnce 中被调用</span></span><br><span class=\"line\">\tRefresh() error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// NodeGroup contains configuration info and functions to control a set</span></span><br><span class=\"line\"><span class=\"comment\">// of nodes that have the same capacity and set of labels.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NodeGroup <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// MaxSize returns maximum size of the node group.</span></span><br><span class=\"line\">\tMaxSize() <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// MinSize returns minimum size of the node group.</span></span><br><span class=\"line\">\tMinSize() <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// TargetSize returns the current target size of the node group. It is possible that the</span></span><br><span class=\"line\">\t<span class=\"comment\">// number of nodes in Kubernetes is different at the moment but should be equal</span></span><br><span class=\"line\">\t<span class=\"comment\">// to Size() once everything stabilizes (new nodes finish startup and registration or</span></span><br><span class=\"line\">\t<span class=\"comment\">// removed nodes are deleted completely). Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 响应的是伸缩组的节点数，并不一定与 kubernetes 中的节点数保持一致</span></span><br><span class=\"line\">\tTargetSize() (<span class=\"keyword\">int</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// IncreaseSize increases the size of the node group. To delete a node you need</span></span><br><span class=\"line\">\t<span class=\"comment\">// to explicitly name it and use DeleteNode. This function should wait until</span></span><br><span class=\"line\">\t<span class=\"comment\">// node group size is updated. Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 扩容的方法，增加伸缩组的节点数</span></span><br><span class=\"line\">\tIncreaseSize(delta <span class=\"keyword\">int</span>) error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// DeleteNodes deletes nodes from this node group. Error is returned either on</span></span><br><span class=\"line\">\t<span class=\"comment\">// failure or if the given node doesn't belong to this node group. This function</span></span><br><span class=\"line\">\t<span class=\"comment\">// should wait until node group size is updated. Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 删除的节点一定要在该节点组中</span></span><br><span class=\"line\">\tDeleteNodes([]*apiv1.Node) error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// DecreaseTargetSize decreases the target size of the node group. This function</span></span><br><span class=\"line\">\t<span class=\"comment\">// doesn't permit to delete any existing node and can be used only to reduce the</span></span><br><span class=\"line\">\t<span class=\"comment\">// request for new nodes that have not been yet fulfilled. Delta should be negative.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is assumed that cloud provider will not delete the existing nodes when there</span></span><br><span class=\"line\">\t<span class=\"comment\">// is an option to just decrease the target. Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当 ClusterAutoscaler 发现 kubernetes 节点数与伸缩组的节点数长时间不一致，会调用此方法来调整</span></span><br><span class=\"line\">\tDecreaseTargetSize(delta <span class=\"keyword\">int</span>) error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Id returns an unique identifier of the node group.</span></span><br><span class=\"line\">\tId() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Debug returns a string containing all information regarding this node group.</span></span><br><span class=\"line\">\tDebug() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Nodes returns a list of all nodes that belong to this node group.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is required that Instance objects returned by this method have Id field set.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Other fields are optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// This list should include also instances that might have not become a kubernetes node yet.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回伸缩组中的所有节点，哪怕它还没有成为 kubernetes 的节点</span></span><br><span class=\"line\">\tNodes() ([]Instance, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// TemplateNodeInfo returns a schedulernodeinfo.NodeInfo structure of an empty</span></span><br><span class=\"line\">\t<span class=\"comment\">// (as if just started) node. This will be used in scale-up simulations to</span></span><br><span class=\"line\">\t<span class=\"comment\">// predict what would a new node look like if a node group was expanded. The returned</span></span><br><span class=\"line\">\t<span class=\"comment\">// NodeInfo is expected to have a fully populated Node object, with all of the labels,</span></span><br><span class=\"line\">\t<span class=\"comment\">// capacity and allocatable information as well as all pods that are started on</span></span><br><span class=\"line\">\t<span class=\"comment\">// the node by default, using manifest (most likely only kube-proxy). Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// ClusterAutoscaler 会将节点信息与节点组对应，来判断资源条件，如果是一个空的节点组，那么就会通过此方法来虚拟一个节点信息。</span></span><br><span class=\"line\">\tTemplateNodeInfo() (*schedulernodeinfo.NodeInfo, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Exist checks if the node group really exists on the cloud provider side. Allows to tell the</span></span><br><span class=\"line\">\t<span class=\"comment\">// theoretical node group from the real one. Implementation required.</span></span><br><span class=\"line\">\tExist() <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Create creates the node group on the cloud provider side. Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 与 CloudProvider.NewNodeGroup 配合使用</span></span><br><span class=\"line\">\tCreate() (NodeGroup, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Delete deletes the node group on the cloud provider side.</span></span><br><span class=\"line\">\t<span class=\"comment\">// This will be executed only for autoprovisioned node groups, once their size drops to 0.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\tDelete() error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Autoprovisioned returns true if the node group is autoprovisioned. An autoprovisioned group</span></span><br><span class=\"line\">\t<span class=\"comment\">// was created by CA and can be deleted when scaled to 0.</span></span><br><span class=\"line\">\tAutoprovisioned() <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ScaleUP-源码解析\"><a href=\"#ScaleUP-源码解析\" class=\"headerlink\" title=\"ScaleUP 源码解析\"></a>ScaleUP 源码解析</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ScaleUp</span><span class=\"params\">(context *context.AutoscalingContext, processors *ca_processors.AutoscalingProcessors, clusterStateRegistry *clusterstate.ClusterStateRegistry, unschedulablePods []*apiv1.Pod, nodes []*apiv1.Node, daemonSets []*appsv1.DaemonSet, nodeInfos <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*schedulernodeinfo.NodeInfo, ignoredTaints taints.TaintKeySet)</span> <span class=\"params\">(*status.ScaleUpStatus, errors.AutoscalerError)</span></span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"comment\">// 验证当前集群中所有 ready node 是否来自于 nodeGroups，取得所有非组内的 node</span></span><br><span class=\"line\">\tnodesFromNotAutoscaledGroups, err := utils.FilterOutNodesFromNotAutoscaledGroups(nodes, context.CloudProvider)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, err.AddPrefix(<span class=\"string\">\"failed to filter out nodes which are from not autoscaled groups: \"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnodeGroups := context.CloudProvider.NodeGroups()</span><br><span class=\"line\">\tgpuLabel := context.CloudProvider.GPULabel()</span><br><span class=\"line\">\tavailableGPUTypes := context.CloudProvider.GetAvailableGPUTypes()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 资源限制对象，会在 build cloud provider 时传入</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果有需要可在 CloudProvider 中自行更改，但不建议改动，会对用户造成迷惑</span></span><br><span class=\"line\">\tresourceLimiter, errCP := context.CloudProvider.GetResourceLimiter()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errCP != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, errors.ToAutoscalerError(</span><br><span class=\"line\">\t\t\terrors.CloudProviderError,</span><br><span class=\"line\">\t\t\terrCP)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 计算资源限制</span></span><br><span class=\"line\">\t<span class=\"comment\">// nodeInfos 是所有拥有节点组的节点与示例节点的映射</span></span><br><span class=\"line\">\t<span class=\"comment\">// 示例节点会优先考虑真实节点的数据，如果 NodeGroup 中还没有真实节点的部署，则使用 Template 的节点数据</span></span><br><span class=\"line\">\tscaleUpResourcesLeft, errLimits := computeScaleUpResourcesLeftLimits(context.CloudProvider, nodeGroups, nodeInfos, nodesFromNotAutoscaledGroups, resourceLimiter)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errLimits != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, errLimits.AddPrefix(<span class=\"string\">\"Could not compute total resources: \"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据当前节点与 NodeGroups 中的节点来计算会有多少节点即将加入集群中</span></span><br><span class=\"line\">\t<span class=\"comment\">// 由于云服务商的伸缩组 increase size 操作并不是同步加入 node，所以将其统计，以便于后面计算节点资源</span></span><br><span class=\"line\">\tupcomingNodes := <span class=\"built_in\">make</span>([]*schedulernodeinfo.NodeInfo, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> nodeGroup, numberOfNodes := <span class=\"keyword\">range</span> clusterStateRegistry.GetUpcomingNodes() &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">\"Upcoming %d nodes\"</span>, <span class=\"built_in\">len</span>(upcomingNodes))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 最终会进入选择的节点组</span></span><br><span class=\"line\">\texpansionOptions := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]expander.Option, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"comment\">// 出于某些限制或错误导致不能加入新节点的节点组，例如节点组已达到 MaxSize</span></span><br><span class=\"line\">\tskippedNodeGroups := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]status.Reasons&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 综合各种情况，筛选出节点组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, nodeGroup := <span class=\"keyword\">range</span> nodeGroups &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(expansionOptions) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">1</span>).Info(<span class=\"string\">\"No expansion options\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;</span><br><span class=\"line\">\t\t\tResult:\t\t\t\t\tstatus.ScaleUpNoOptionsAvailable,</span><br><span class=\"line\">\t\t\tPodsRemainUnschedulable: getRemainingPods(podEquivalenceGroups, skippedNodeGroups),</span><br><span class=\"line\">\t\t\tConsideredNodeGroups:\tnodeGroups,</span><br><span class=\"line\">\t\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"comment\">// 选择一个最佳的节点组进行扩容，expander 用于选择一个合适的节点组进行扩容，默认为 RandomExpander，flag: expander</span></span><br><span class=\"line\">\t<span class=\"comment\">// random 随机选一个，适合只有一个节点组</span></span><br><span class=\"line\">\t<span class=\"comment\">// most-pods 选择能够调度最多 pod 的节点组，比如有 noSchedulerPods 是有 nodeSelector 的，它会优先选择此类节点组以满足大多数 pod 的需求</span></span><br><span class=\"line\">\t<span class=\"comment\">// least-waste 优先选择能满足 pod 需求资源的最小资源类型的节点组</span></span><br><span class=\"line\">\t<span class=\"comment\">// price 根据价格模型，选择最省钱的</span></span><br><span class=\"line\">\t<span class=\"comment\">// priority 根据优先级选择</span></span><br><span class=\"line\">\tbestOption := context.ExpanderStrategy.BestOption(options, nodeInfos)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bestOption != <span class=\"literal\">nil</span> &amp;&amp; bestOption.NodeCount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t\tnewNodes := bestOption.NodeCount</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 考虑到 upcomingNodes, 重新计算本次新加入节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> context.MaxNodesTotal &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(nodes)+newNodes+<span class=\"built_in\">len</span>(upcomingNodes) &gt; context.MaxNodesTotal &#123;</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">1</span>).Infof(<span class=\"string\">\"Capping size to max cluster total size (%d)\"</span>, context.MaxNodesTotal)</span><br><span class=\"line\">\t\t\tnewNodes = context.MaxNodesTotal - <span class=\"built_in\">len</span>(nodes) - <span class=\"built_in\">len</span>(upcomingNodes)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> newNodes &lt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, errors.NewAutoscalerError(</span><br><span class=\"line\">\t\t\t\t\terrors.TransientError,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"max node total count already reached\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcreateNodeGroupResults := <span class=\"built_in\">make</span>([]nodegroups.CreateNodeGroupResult, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果节点组在云服务商端处不存在，会尝试创建根据现有信息重新创建一个云端节点组</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 但是目前所有的 CloudProvider 实现都没有允许这种操作，这好像是个多余的方法</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 云服务商不想，也不应该将云端节点组的创建权限交给 ClusterAutoscaler</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !bestOption.NodeGroup.Exist() &#123;</span><br><span class=\"line\">\t\t\toldId := bestOption.NodeGroup.Id()</span><br><span class=\"line\">\t\t\tcreateNodeGroupResult, err := processors.NodeGroupManager.CreateNodeGroup(context, bestOption.NodeGroup)</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 得到最佳节点组的示例节点</span></span><br><span class=\"line\">\t\tnodeInfo, found := nodeInfos[bestOption.NodeGroup.Id()]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !found &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// This should never happen, as we already should have retrieved</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// nodeInfo for any considered nodegroup.</span></span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">\"No node info for: %s\"</span>, bestOption.NodeGroup.Id())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, errors.NewAutoscalerError(</span><br><span class=\"line\">\t\t\t\terrors.CloudProviderError,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"No node info for best expansion option!\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 根据 CPU、Memory及可能存在的 GPU 资源（hack: we assume anything which is not cpu/memory to be a gpu.），计算出需要多少个 Nodes</span></span><br><span class=\"line\">\t\tnewNodes, err = applyScaleUpResourcesLimits(context.CloudProvider, newNodes, scaleUpResourcesLeft, nodeInfo, bestOption.NodeGroup, resourceLimiter)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 需要平衡的节点组</span></span><br><span class=\"line\">\t\ttargetNodeGroups := []cloudprovider.NodeGroup&#123;bestOption.NodeGroup&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果需要平衡节点组，根据 balance-similar-node-groups flag 设置。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 检测相似的节点组，并平衡它们之间的节点数量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> context.BalanceSimilarNodeGroups &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 具体平衡策略可以看 (b *BalancingNodeGroupSetProcessor) BalanceScaleUpBetweenGroups 方法</span></span><br><span class=\"line\">\t\tscaleUpInfos, typedErr := processors.NodeGroupSetProcessor.BalanceScaleUpBetweenGroups(context, targetNodeGroups, newNodes)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> typedErr != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, typedErr</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">1</span>).Infof(<span class=\"string\">\"Final scale-up plan: %v\"</span>, scaleUpInfos)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 开始扩容，通过 IncreaseSize 扩容</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, info := <span class=\"keyword\">range</span> scaleUpInfos &#123;</span><br><span class=\"line\">\t\t\ttypedErr := executeScaleUp(context, clusterStateRegistry, info, gpu.GetGpuTypeForMetrics(gpuLabel, availableGPUTypes, nodeInfo.Node(), <span class=\"literal\">nil</span>), now)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> typedErr != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, typedErr</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>当我们使用 Kubernetes 部署应用后，会发现如果用户增长速度超过预期，以至于计算资源不够时，你会怎么做呢？Kubernetes 给出的解决方案就是：自动伸缩（auto-scaling），通过自动伸缩组件之间的配合，可以 7*24 小时的监控着你的集群，动态变化负载，以适应你的用户需求。</p>","more":"<h2 id=\"自动伸缩组件\"><a href=\"#自动伸缩组件\" class=\"headerlink\" title=\"自动伸缩组件\"></a>自动伸缩组件</h2><p><strong>水平自动伸缩（Horizontal Pod Autoscaler，HPA）</strong></p>\n<p>HPA 可以基于实时的 CPU 利用率自动伸缩 Replication Controller、Deployment 和 Replica Set 中的 Pod 数量。也可以通过搭配 Metrics Server 基于其他的度量指标。</p>\n<p><strong>垂直自动伸缩（Vertical Pod Autoscaler，VPA）</strong></p>\n<p>VPA 可以基于 Pod 的使用资源来自动设置 Pod 所需资源并且能够在运行时自动调整资源。</p>\n<p><strong>集群自动伸缩（Cluster Autoscaler，CA）</strong></p>\n<p>CA 是一个可以自动伸缩集群 Node 的组件。如果集群中有未被调度的 Pod，它将会自动扩展 Node 来使 Pod 可用，或是在发现集群中的 Node 资源使用率过低时，删除 Node 来节约资源。</p>\n<p><strong>插件伸缩（Addon Resizer）</strong></p>\n<p>这是一个小插件，它以 Sidecar 的形式来垂直伸缩与自己同一个部署中的另一个容器，目前唯一的策略就是根据集群中节点的数量来进行线性扩展。通常与 <a href=\"https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/metrics-server/metrics-server-deployment.yaml#L66\" target=\"_blank\" rel=\"noopener\">Metrics Server</a> 配合使用，以保证其可以负担不断扩大的整个集群的 metrics API 服务。</p>\n<p>通过 HPA 伸缩无状态应用，VPA 伸缩有状态应用，CA 保证计算资源，它们的配合使用，构成了一个完整的自动伸缩解决方案。</p>\n<h2 id=\"Cluster-Autoscaler-详细介绍\"><a href=\"#Cluster-Autoscaler-详细介绍\" class=\"headerlink\" title=\"Cluster Autoscaler 详细介绍\"></a>Cluster Autoscaler 详细介绍</h2><p>上面介绍的四个组件中，HPA 是在 kubernetes 代码仓库中的，随着 kubernetes 的版本进行更新发布，不需要部署，可以直接使用。其他的三个组件都在官方社区维护的<a href=\"https://github.com/kubernetes/autoscaler\" target=\"_blank\" rel=\"noopener\">仓库</a>中，Cluster Autoscaler 的 v1.0(GA) 版本已经随着 kubernetes 1.8 一起发布，剩下两个则还是 beta 版本。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>Cluster Autoscaler 通常需要搭配云厂商使用，它提供了 <code>Cloud Provider</code> 接口供各个云厂商接入，云厂商通过伸缩组（Scaling Group）或节点池（Node Pool）的功能对 ECS 类产品节点进行增加删除等操作。</p>\n<p>目前（v1.18.1）已接入的云厂商：</p>\n<p><strong>Alicloud：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md</a></p>\n<p><strong>Aws：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md</a></p>\n<p><strong>Azure：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md</a></p>\n<p><strong>Baiducloud：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/baiducloud/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/baiducloud/README.md</a></p>\n<p><strong>Digitalocean：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/digitalocean/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/digitalocean/README.md</a></p>\n<p><strong>GoogleCloud GCE：</strong><a href=\"https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#upgrading-google-compute-engine-clusters\" target=\"_blank\" rel=\"noopener\">https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#upgrading-google-compute-engine-clusters</a></p>\n<p><strong>GoogleCloud GKE：</strong><a href=\"https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler\" target=\"_blank\" rel=\"noopener\">https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler</a></p>\n<p><strong>OpenStack Magnum：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/magnum/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/magnum/README.md</a></p>\n<p><strong>Packet：</strong><a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/packet/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/packet/README.md</a></p>\n<p>启动参数列表：<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca</a></p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>Cluster Autoscaler 抽象出了一个 <code>NodeGroup</code> 的概念，与之对应的是云厂商的伸缩组服务。Cluster Autoscaler 通过 <code>CloudProvider</code> 提供的 <code>NodeGroup</code> 计算集群内节点资源，以此来进行伸缩。</p>\n<p>在启动后，Cluster Autoscaler 会定期（默认 10s）检查未调度的 Pod 和 Node 的资源使用情况，并进行相应的 <code>Scale UP</code> 和 <code>Scale Down</code> 操作。</p>\n<h4 id=\"Scale-UP\"><a href=\"#Scale-UP\" class=\"headerlink\" title=\"Scale UP\"></a>Scale UP</h4><p>当 Cluster Autoscaler 发现有 Pod 由于资源不足而无法调度时，就会通过调用 <code>Scale UP</code> 执行扩容操作。</p>\n<p>在 <code>Scale UP</code> 中会只会计算在 <code>NodeGroup</code> 中存在的 Node，我们可以将 Worker Node 统一交由伸缩组进行管理。并且由于伸缩组非同步加入的特性，也会考虑到 Upcoming Node。</p>\n<p>为了业务需要，集群中可能会有不同规格的 Node，我们可以创建多个 <code>NodeGroup</code>，在扩容时会根据 <code>--expander</code> 选项配置指定的策略，选择一个扩容的节点组，支持如下<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders\" target=\"_blank\" rel=\"noopener\">五种策略</a>：</p>\n<ul>\n<li><strong>random：</strong>随机选择一个 <code>NodeGroup</code>。如果未指定，则默认为此策略。</li>\n<li><strong>most-pods：</strong>选择能够调度最多 Pod 的 <code>NodeGroup</code>，比如有的 Pod 未调度是因为 <code>nodeSelector</code>，此策略会优先选择能满足的 <code>NodeGroup</code> 来保证大多数的 Pod 可以被调度。</li>\n<li><strong>least-waste：</strong>为避免浪费，此策略会优先选择能满足 Pod 需求资源的最小资源类型的 <code>NodeGroup</code>。</li>\n<li><strong>price：</strong>根据 <code>CloudProvider</code> 提供的价格模型，选择最省钱的 <code>NodeGroup</code>。</li>\n<li><strong>priority：</strong>通过配置优先级来进行选择，用起来比较麻烦，需要额外的配置，可以看<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n</ul>\n<p>如果有需要，也可以平衡相似 <code>NodeGroup</code> 中的    Node 数量，避免 <code>NodeGroup</code> 达到 <code>MaxSize</code> 而导致无法加入新 Node。通过 <code>--balance-similar-node-groups</code> 选项配置，默认为 <code>false</code>。</p>\n<p>再经过一系列的操作后，最终计算出要扩容的 Node 数量及 <code>NodeGroup</code>，使用 <code>CloudProvider</code> 执行 <code>IncreaseSize</code> 操作，增加云厂商的伸缩组大小，从而完成扩容操作。</p>\n<p><em>文字表达能力不足，如果有不清晰的地方，可以参考下面的 <a href=\"#ScaleUP源码解析\">ScaleUP 源码解析</a>。</em></p>\n<h4 id=\"Scale-Down\"><a href=\"#Scale-Down\" class=\"headerlink\" title=\"Scale Down\"></a>Scale Down</h4><p>缩容是一个可选的功能，通过 <code>--scale-down-enabled</code> 选项配置，默认为 <code>true</code>。</p>\n<p>在 Cluster Autoscaler 监控 Node 资源时，如果发现有 Node 满足以下三个条件时，就会标记这个 Node 为 <code>unneeded</code>：</p>\n<ul>\n<li>Node 上运行的所有的 Pod 的 Cpu 和内存之和小于该 Node 可分配容量的 50%。可通过 <code>--scale-down-utilization-threshold</code> 选项改变这个配置。</li>\n<li>Node 上所有的 Pod 都可以被调度到其他节点。</li>\n<li>Node 没有表示不可缩容的 annotaition。</li>\n</ul>\n<p>如果一个 Node 被标记为 <code>unneeded</code> 超过 10 分钟（可通过 <code>--scale-down-unneeded-time</code> 选项配置），则使用 <code>CloudProvider</code> 执行 <code>DeleteNodes</code> 操作将其删除。一次最多删除一个 <code>unneeded Node</code>，但空 Node 可以批量删除，每次最多删除 10 个（通过 <code>----max-empty-bulk-delete</code> 选项配置）。</p>\n<p>实际上并不是只有这一个判定条件，还会有其他的条件来阻止删除这个 Node，比如 <code>NodeGroup</code> 已达到 <code>MinSize</code>，或在过去的 10 分钟内有过一次 <code>Scale UP</code> 操作（通过 <code>--scale-down-delay-after-add</code> 选项配置）等等，更详细可查看<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-down-work\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>Cluster Autoscaler 的工作机制很复杂，但其中大部分都能通过 flags 进行配置，如果有需要，请详细阅读文档：<a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md</a></p>\n<h2 id=\"如何实现-CloudProvider\"><a href=\"#如何实现-CloudProvider\" class=\"headerlink\" title=\"如何实现 CloudProvider\"></a>如何实现 CloudProvider</h2><p>如果使用上述中已实现接入的云厂商，只需要通过 <code>--cloud-provider</code> 选项指定来自哪个云厂商就可以，如果想要对接自己的 IaaS 或有特定的业务逻辑，就需要自己实现 <code>CloudProvider Interface</code> 与 <code>NodeGroupInterface</code>。并将其注册到 <code>builder</code> 中，用于通过 <code>--cloud-provider</code> 参数指定。</p>\n<p><code>builder</code> 在 <code>cloudprovider/builder</code> 中的 <a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/builder/builder_all.go\" target=\"_blank\" rel=\"noopener\">builder_all.go</a> 中注册，也可以在其中新建一个自己的 <code>build</code>，通过 go 文件的 <code>+build</code> 编译参数来指定使用的 <code>CloudProvider</code>。</p>\n<p><code>CloudProvider</code> 接口与 <code>NodeGroup</code> 接口在 <a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/cloud_provider.go\" target=\"_blank\" rel=\"noopener\">cloud_provider.go</a> 中定义，其中需要注意的是 <code>Refresh</code> 方法，它会在每一次循环（默认 10 秒）的开始时调用，可在此时请求接口并刷新 <code>NodeGroup</code> 状态，通常的做法是增加一个 <code>manager</code> 用于管理状态。有不理解的部分可参考其他 <code>CloudProvider</code> 的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CloudProvider <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Name returns name of the cloud provider.</span></span><br><span class=\"line\">\tName() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// NodeGroups returns all node groups configured for this cloud provider.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 会在一此循环中多次调用此方法，所以不适合每次都请求云厂商服务，可以在 Refresh 时存储状态</span></span><br><span class=\"line\">\tNodeGroups() []NodeGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// NodeGroupForNode returns the node group for the given node, nil if the node</span></span><br><span class=\"line\">\t<span class=\"comment\">// should not be processed by cluster autoscaler, or non-nil error if such</span></span><br><span class=\"line\">\t<span class=\"comment\">// occurred. Must be implemented.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 同上</span></span><br><span class=\"line\">\tNodeGroupForNode(*apiv1.Node) (NodeGroup, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Pricing returns pricing model for this cloud provider or error if not available.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果不使用 price expander 就可以不实现此方法</span></span><br><span class=\"line\">\tPricing() (PricingModel, errors.AutoscalerError)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 没用，不需要实现</span></span><br><span class=\"line\">\tGetAvailableMachineTypes() ([]<span class=\"keyword\">string</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// NewNodeGroup builds a theoretical node group based on the node definition provided. The node group is not automatically</span></span><br><span class=\"line\">\t<span class=\"comment\">// created on the cloud provider side. The node group is not returned by NodeGroups() until it is created.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 通常情况下，不需要实现此方法，但如果你需要 ClusterAutoscaler 创建一个默认的 NodeGroup 的话，也可以实现。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 但其实更好的做法是将默认 NodeGroup 写入云端的伸缩组</span></span><br><span class=\"line\">\tNewNodeGroup(machineType <span class=\"keyword\">string</span>, labels <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>, systemLabels <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>,</span><br><span class=\"line\">\t\ttaints []apiv1.Taint, extraResources <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]resource.Quantity) (NodeGroup, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).</span></span><br><span class=\"line\">\t<span class=\"comment\">// 资源限制对象，会在 build 时传入，通常情况下不需要更改，除非在云端有显示的提示用户更改的地方，否则使用时会迷惑用户</span></span><br><span class=\"line\">\tGetResourceLimiter() (*ResourceLimiter, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GPULabel returns the label added to nodes with GPU resource.</span></span><br><span class=\"line\">\t<span class=\"comment\">// GPU 相关，如果集群中有使用 GPU 资源，需要返回对应内容。 hack: we assume anything which is not cpu/memory to be a gpu.</span></span><br><span class=\"line\">\tGPULabel() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GetAvailableGPUTypes return all available GPU types cloud provider supports.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 同上</span></span><br><span class=\"line\">\tGetAvailableGPUTypes() <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.</span></span><br><span class=\"line\">\t<span class=\"comment\">// CloudProvider 只会在启动时被初始化一次，如果每次循环后有需要清除的内容，在这里处理</span></span><br><span class=\"line\">\tCleanup() error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Refresh is called before every main loop and can be used to dynamically update cloud provider state.</span></span><br><span class=\"line\">\t<span class=\"comment\">// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().</span></span><br><span class=\"line\">\t<span class=\"comment\">// 会在 StaticAutoscaler RunOnce 中被调用</span></span><br><span class=\"line\">\tRefresh() error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// NodeGroup contains configuration info and functions to control a set</span></span><br><span class=\"line\"><span class=\"comment\">// of nodes that have the same capacity and set of labels.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NodeGroup <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// MaxSize returns maximum size of the node group.</span></span><br><span class=\"line\">\tMaxSize() <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// MinSize returns minimum size of the node group.</span></span><br><span class=\"line\">\tMinSize() <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// TargetSize returns the current target size of the node group. It is possible that the</span></span><br><span class=\"line\">\t<span class=\"comment\">// number of nodes in Kubernetes is different at the moment but should be equal</span></span><br><span class=\"line\">\t<span class=\"comment\">// to Size() once everything stabilizes (new nodes finish startup and registration or</span></span><br><span class=\"line\">\t<span class=\"comment\">// removed nodes are deleted completely). Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 响应的是伸缩组的节点数，并不一定与 kubernetes 中的节点数保持一致</span></span><br><span class=\"line\">\tTargetSize() (<span class=\"keyword\">int</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// IncreaseSize increases the size of the node group. To delete a node you need</span></span><br><span class=\"line\">\t<span class=\"comment\">// to explicitly name it and use DeleteNode. This function should wait until</span></span><br><span class=\"line\">\t<span class=\"comment\">// node group size is updated. Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 扩容的方法，增加伸缩组的节点数</span></span><br><span class=\"line\">\tIncreaseSize(delta <span class=\"keyword\">int</span>) error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// DeleteNodes deletes nodes from this node group. Error is returned either on</span></span><br><span class=\"line\">\t<span class=\"comment\">// failure or if the given node doesn't belong to this node group. This function</span></span><br><span class=\"line\">\t<span class=\"comment\">// should wait until node group size is updated. Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 删除的节点一定要在该节点组中</span></span><br><span class=\"line\">\tDeleteNodes([]*apiv1.Node) error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// DecreaseTargetSize decreases the target size of the node group. This function</span></span><br><span class=\"line\">\t<span class=\"comment\">// doesn't permit to delete any existing node and can be used only to reduce the</span></span><br><span class=\"line\">\t<span class=\"comment\">// request for new nodes that have not been yet fulfilled. Delta should be negative.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is assumed that cloud provider will not delete the existing nodes when there</span></span><br><span class=\"line\">\t<span class=\"comment\">// is an option to just decrease the target. Implementation required.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当 ClusterAutoscaler 发现 kubernetes 节点数与伸缩组的节点数长时间不一致，会调用此方法来调整</span></span><br><span class=\"line\">\tDecreaseTargetSize(delta <span class=\"keyword\">int</span>) error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Id returns an unique identifier of the node group.</span></span><br><span class=\"line\">\tId() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Debug returns a string containing all information regarding this node group.</span></span><br><span class=\"line\">\tDebug() <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Nodes returns a list of all nodes that belong to this node group.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is required that Instance objects returned by this method have Id field set.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Other fields are optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// This list should include also instances that might have not become a kubernetes node yet.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回伸缩组中的所有节点，哪怕它还没有成为 kubernetes 的节点</span></span><br><span class=\"line\">\tNodes() ([]Instance, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// TemplateNodeInfo returns a schedulernodeinfo.NodeInfo structure of an empty</span></span><br><span class=\"line\">\t<span class=\"comment\">// (as if just started) node. This will be used in scale-up simulations to</span></span><br><span class=\"line\">\t<span class=\"comment\">// predict what would a new node look like if a node group was expanded. The returned</span></span><br><span class=\"line\">\t<span class=\"comment\">// NodeInfo is expected to have a fully populated Node object, with all of the labels,</span></span><br><span class=\"line\">\t<span class=\"comment\">// capacity and allocatable information as well as all pods that are started on</span></span><br><span class=\"line\">\t<span class=\"comment\">// the node by default, using manifest (most likely only kube-proxy). Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// ClusterAutoscaler 会将节点信息与节点组对应，来判断资源条件，如果是一个空的节点组，那么就会通过此方法来虚拟一个节点信息。</span></span><br><span class=\"line\">\tTemplateNodeInfo() (*schedulernodeinfo.NodeInfo, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Exist checks if the node group really exists on the cloud provider side. Allows to tell the</span></span><br><span class=\"line\">\t<span class=\"comment\">// theoretical node group from the real one. Implementation required.</span></span><br><span class=\"line\">\tExist() <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Create creates the node group on the cloud provider side. Implementation optional.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 与 CloudProvider.NewNodeGroup 配合使用</span></span><br><span class=\"line\">\tCreate() (NodeGroup, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Delete deletes the node group on the cloud provider side.</span></span><br><span class=\"line\">\t<span class=\"comment\">// This will be executed only for autoprovisioned node groups, once their size drops to 0.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Implementation optional.</span></span><br><span class=\"line\">\tDelete() error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Autoprovisioned returns true if the node group is autoprovisioned. An autoprovisioned group</span></span><br><span class=\"line\">\t<span class=\"comment\">// was created by CA and can be deleted when scaled to 0.</span></span><br><span class=\"line\">\tAutoprovisioned() <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ScaleUP-源码解析\"><a href=\"#ScaleUP-源码解析\" class=\"headerlink\" title=\"ScaleUP 源码解析\"></a>ScaleUP 源码解析</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ScaleUp</span><span class=\"params\">(context *context.AutoscalingContext, processors *ca_processors.AutoscalingProcessors, clusterStateRegistry *clusterstate.ClusterStateRegistry, unschedulablePods []*apiv1.Pod, nodes []*apiv1.Node, daemonSets []*appsv1.DaemonSet, nodeInfos <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*schedulernodeinfo.NodeInfo, ignoredTaints taints.TaintKeySet)</span> <span class=\"params\">(*status.ScaleUpStatus, errors.AutoscalerError)</span></span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"comment\">// 验证当前集群中所有 ready node 是否来自于 nodeGroups，取得所有非组内的 node</span></span><br><span class=\"line\">\tnodesFromNotAutoscaledGroups, err := utils.FilterOutNodesFromNotAutoscaledGroups(nodes, context.CloudProvider)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, err.AddPrefix(<span class=\"string\">\"failed to filter out nodes which are from not autoscaled groups: \"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnodeGroups := context.CloudProvider.NodeGroups()</span><br><span class=\"line\">\tgpuLabel := context.CloudProvider.GPULabel()</span><br><span class=\"line\">\tavailableGPUTypes := context.CloudProvider.GetAvailableGPUTypes()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 资源限制对象，会在 build cloud provider 时传入</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果有需要可在 CloudProvider 中自行更改，但不建议改动，会对用户造成迷惑</span></span><br><span class=\"line\">\tresourceLimiter, errCP := context.CloudProvider.GetResourceLimiter()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errCP != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, errors.ToAutoscalerError(</span><br><span class=\"line\">\t\t\terrors.CloudProviderError,</span><br><span class=\"line\">\t\t\terrCP)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 计算资源限制</span></span><br><span class=\"line\">\t<span class=\"comment\">// nodeInfos 是所有拥有节点组的节点与示例节点的映射</span></span><br><span class=\"line\">\t<span class=\"comment\">// 示例节点会优先考虑真实节点的数据，如果 NodeGroup 中还没有真实节点的部署，则使用 Template 的节点数据</span></span><br><span class=\"line\">\tscaleUpResourcesLeft, errLimits := computeScaleUpResourcesLeftLimits(context.CloudProvider, nodeGroups, nodeInfos, nodesFromNotAutoscaledGroups, resourceLimiter)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errLimits != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, errLimits.AddPrefix(<span class=\"string\">\"Could not compute total resources: \"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据当前节点与 NodeGroups 中的节点来计算会有多少节点即将加入集群中</span></span><br><span class=\"line\">\t<span class=\"comment\">// 由于云服务商的伸缩组 increase size 操作并不是同步加入 node，所以将其统计，以便于后面计算节点资源</span></span><br><span class=\"line\">\tupcomingNodes := <span class=\"built_in\">make</span>([]*schedulernodeinfo.NodeInfo, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> nodeGroup, numberOfNodes := <span class=\"keyword\">range</span> clusterStateRegistry.GetUpcomingNodes() &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">\"Upcoming %d nodes\"</span>, <span class=\"built_in\">len</span>(upcomingNodes))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 最终会进入选择的节点组</span></span><br><span class=\"line\">\texpansionOptions := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]expander.Option, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"comment\">// 出于某些限制或错误导致不能加入新节点的节点组，例如节点组已达到 MaxSize</span></span><br><span class=\"line\">\tskippedNodeGroups := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]status.Reasons&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 综合各种情况，筛选出节点组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, nodeGroup := <span class=\"keyword\">range</span> nodeGroups &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(expansionOptions) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">1</span>).Info(<span class=\"string\">\"No expansion options\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;</span><br><span class=\"line\">\t\t\tResult:\t\t\t\t\tstatus.ScaleUpNoOptionsAvailable,</span><br><span class=\"line\">\t\t\tPodsRemainUnschedulable: getRemainingPods(podEquivalenceGroups, skippedNodeGroups),</span><br><span class=\"line\">\t\t\tConsideredNodeGroups:\tnodeGroups,</span><br><span class=\"line\">\t\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"comment\">// 选择一个最佳的节点组进行扩容，expander 用于选择一个合适的节点组进行扩容，默认为 RandomExpander，flag: expander</span></span><br><span class=\"line\">\t<span class=\"comment\">// random 随机选一个，适合只有一个节点组</span></span><br><span class=\"line\">\t<span class=\"comment\">// most-pods 选择能够调度最多 pod 的节点组，比如有 noSchedulerPods 是有 nodeSelector 的，它会优先选择此类节点组以满足大多数 pod 的需求</span></span><br><span class=\"line\">\t<span class=\"comment\">// least-waste 优先选择能满足 pod 需求资源的最小资源类型的节点组</span></span><br><span class=\"line\">\t<span class=\"comment\">// price 根据价格模型，选择最省钱的</span></span><br><span class=\"line\">\t<span class=\"comment\">// priority 根据优先级选择</span></span><br><span class=\"line\">\tbestOption := context.ExpanderStrategy.BestOption(options, nodeInfos)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bestOption != <span class=\"literal\">nil</span> &amp;&amp; bestOption.NodeCount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t\tnewNodes := bestOption.NodeCount</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 考虑到 upcomingNodes, 重新计算本次新加入节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> context.MaxNodesTotal &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(nodes)+newNodes+<span class=\"built_in\">len</span>(upcomingNodes) &gt; context.MaxNodesTotal &#123;</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">1</span>).Infof(<span class=\"string\">\"Capping size to max cluster total size (%d)\"</span>, context.MaxNodesTotal)</span><br><span class=\"line\">\t\t\tnewNodes = context.MaxNodesTotal - <span class=\"built_in\">len</span>(nodes) - <span class=\"built_in\">len</span>(upcomingNodes)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> newNodes &lt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError&#125;, errors.NewAutoscalerError(</span><br><span class=\"line\">\t\t\t\t\terrors.TransientError,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"max node total count already reached\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcreateNodeGroupResults := <span class=\"built_in\">make</span>([]nodegroups.CreateNodeGroupResult, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果节点组在云服务商端处不存在，会尝试创建根据现有信息重新创建一个云端节点组</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 但是目前所有的 CloudProvider 实现都没有允许这种操作，这好像是个多余的方法</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 云服务商不想，也不应该将云端节点组的创建权限交给 ClusterAutoscaler</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !bestOption.NodeGroup.Exist() &#123;</span><br><span class=\"line\">\t\t\toldId := bestOption.NodeGroup.Id()</span><br><span class=\"line\">\t\t\tcreateNodeGroupResult, err := processors.NodeGroupManager.CreateNodeGroup(context, bestOption.NodeGroup)</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 得到最佳节点组的示例节点</span></span><br><span class=\"line\">\t\tnodeInfo, found := nodeInfos[bestOption.NodeGroup.Id()]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !found &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// This should never happen, as we already should have retrieved</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// nodeInfo for any considered nodegroup.</span></span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">\"No node info for: %s\"</span>, bestOption.NodeGroup.Id())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, errors.NewAutoscalerError(</span><br><span class=\"line\">\t\t\t\terrors.CloudProviderError,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"No node info for best expansion option!\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 根据 CPU、Memory及可能存在的 GPU 资源（hack: we assume anything which is not cpu/memory to be a gpu.），计算出需要多少个 Nodes</span></span><br><span class=\"line\">\t\tnewNodes, err = applyScaleUpResourcesLimits(context.CloudProvider, newNodes, scaleUpResourcesLeft, nodeInfo, bestOption.NodeGroup, resourceLimiter)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 需要平衡的节点组</span></span><br><span class=\"line\">\t\ttargetNodeGroups := []cloudprovider.NodeGroup&#123;bestOption.NodeGroup&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果需要平衡节点组，根据 balance-similar-node-groups flag 设置。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 检测相似的节点组，并平衡它们之间的节点数量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> context.BalanceSimilarNodeGroups &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 具体平衡策略可以看 (b *BalancingNodeGroupSetProcessor) BalanceScaleUpBetweenGroups 方法</span></span><br><span class=\"line\">\t\tscaleUpInfos, typedErr := processors.NodeGroupSetProcessor.BalanceScaleUpBetweenGroups(context, targetNodeGroups, newNodes)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> typedErr != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, typedErr</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">1</span>).Infof(<span class=\"string\">\"Final scale-up plan: %v\"</span>, scaleUpInfos)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 开始扩容，通过 IncreaseSize 扩容</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, info := <span class=\"keyword\">range</span> scaleUpInfos &#123;</span><br><span class=\"line\">\t\t\ttypedErr := executeScaleUp(context, clusterStateRegistry, info, gpu.GetGpuTypeForMetrics(gpuLabel, availableGPUTypes, nodeInfo.Node(), <span class=\"literal\">nil</span>), now)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> typedErr != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &amp;status.ScaleUpStatus&#123;Result: status.ScaleUpError, CreateNodeGroupResults: createNodeGroupResults&#125;, typedErr</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RESTful API 实践","date":"2016-10-11T11:18:17.000Z","_content":"\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n由于不符合超媒体，现在是 HTTP API。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ...\n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求)\n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在\n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n","source":"_posts/RESTful-API-Practice.md","raw":"---\ntitle: RESTful API 实践\ndate: 2016/10/11 19:18:17\n---\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n由于不符合超媒体，现在是 HTTP API。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ...\n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求)\n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在\n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n","slug":"RESTful-API-Practice","published":1,"updated":"2020-07-23T00:29:18.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea3000ccyze8zy2xxvv","content":"<p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<p>由于不符合超媒体，现在是 HTTP API。</p>\n<a id=\"more\"></a>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sortby=level&amp;order=asc</span><br></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sort=-type，created_at</span><br></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?offset=10 - 偏移量</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?embed=department.name，job</span><br></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</span><br><span class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</span><br><span class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</span><br></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'message': 'Invalid Token'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'code' : 10010，</span><br><span class=\"line\">\t'message': 'Insufficient balance'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback_function(&#123;</span><br><span class=\"line\">\tstatus_code: 200，</span><br><span class=\"line\">\tnext_page: &quot;https://..&quot;，</span><br><span class=\"line\">\tresponse: &#123;</span><br><span class=\"line\">\t\t... 正常的 JSON 实体 ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求)</p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在</p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"noopener\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"noopener\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</span><br><span class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</span><br><span class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</span><br><span class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</span><br><span class=\"line\">它成为了现代 Web 架构的基础。</span><br><span class=\"line\"></span><br><span class=\"line\">出自[中文译版] 结论</span><br></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"noopener\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"noopener\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"noopener\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"noopener\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"noopener\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"noopener\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">HTTP缓存 这里主要是讲的Etag</a></p>\n","site":{"data":{}},"excerpt":"<p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<p>由于不符合超媒体，现在是 HTTP API。</p>","more":"<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sortby=level&amp;order=asc</span><br></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sort=-type，created_at</span><br></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?offset=10 - 偏移量</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?embed=department.name，job</span><br></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</span><br><span class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</span><br><span class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</span><br></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'message': 'Invalid Token'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'code' : 10010，</span><br><span class=\"line\">\t'message': 'Insufficient balance'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback_function(&#123;</span><br><span class=\"line\">\tstatus_code: 200，</span><br><span class=\"line\">\tnext_page: &quot;https://..&quot;，</span><br><span class=\"line\">\tresponse: &#123;</span><br><span class=\"line\">\t\t... 正常的 JSON 实体 ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求)</p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在</p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"noopener\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"noopener\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</span><br><span class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</span><br><span class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</span><br><span class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</span><br><span class=\"line\">它成为了现代 Web 架构的基础。</span><br><span class=\"line\"></span><br><span class=\"line\">出自[中文译版] 结论</span><br></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"noopener\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"noopener\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"noopener\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"noopener\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"noopener\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"noopener\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">HTTP缓存 这里主要是讲的Etag</a></p>"},{"title":"OAuth2.0 与 oauth2-server 库的使用","date":"2018-11-22T12:08:09.000Z","_content":"\n[OAuth2.0](https://en.wikipedia.org/wiki/OAuth) 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。\n\n[league/oauth2-server](https://github.com/thephpleague/oauth2-server) 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。\n\n本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。\n\n<!--more-->  \n\n## 术语\n\n了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。\n\n**OAuth2.0 定义了四个角色**\n\n1. **Client**：客户端，第三方应用程序。\n2. **Resource Owner**：资源所有者，授权 Client 访问其帐户的用户。\n3. **Authorization server**：授权服务器，服务商专用于处理用户授权认证的服务器。\n4. **Resource server**：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。\n\n**oauth2-server**\n\n1. **Access token**：用于访问受保护资源的令牌。\n2. **Authorization code**：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。\n3. **Scope**：授予应用程序的权限范围。\n4. **JWT**：[Json Web Token](https://tools.ietf.org/html/rfc7519) 是一种用于安全传输的数据传输格式。\n\n\n## 运行流程\n![flowchart.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg)\n\n\n## 安装\n\n推荐使用 [Composer](https://getcomposer.org/) 进行安装：\n\n```string\ncomposer require league/oauth2-server\n```\n\n根据[授权模式](#授权模式)的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。\n\n*本文发布时，版本号为7.3.1。*\n\n\n\n**生成公钥与私钥**\n\n公钥与私钥用于签名和验证传输的 [JWT](https://tools.ietf.org/html/rfc7519)，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。\n\n*oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。*\n\n生成私钥，在终端中运行：\n\n```string\nopenssl genrsa -out private.key 2048\n```\n\n使用私钥提取私钥：\n\n```string\nopenssl rsa -in private.key -pubout -out public.key\n```\n\n私钥必须保密于授权服务器中，并将公钥分发给资源服务器。\n\n\n\n**生成加密密钥**\n\n加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，`string` 或 `defuse/php-encryption` 库的对象。\n\n*加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。*\n\n生成字符串密钥，在终端中输入：\n\n```string\nphp -r 'echo base64_encode(random_bytes(32)), PHP_EOL;'\n```\n\n生成对象，在项目根目录的终端中输入：\n\n```string\nvendor/bin/generate-defuse-key\n```\n\n将获得的内容，传入 AuthorizationServer：\n\n```php\nuse \\Defuse\\Crypto\\Key;\n$server = new AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKeyPath,\n    Key::loadFromAsciiSafeString($encryptionKey) //传入加密密钥\n);\n```\n\n\n\n**PHP版本支持**\n\n- PHP 7.0\n- PHP 7.1\n- PHP 7.2\n\n\n\n## 授权模式\n\nOAuth2.0 定义了四种授权模式，以应对不同情况时的授权。\n\n1. 授权码模式\n2. 隐式授权模式\n3. 密码模式\n4. 客户端模式\n\n\n\n## 客户端类型 \n\n* 保密的：\n\t* 客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）\n* 公开的：\n\t* 客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）\n\n\n\n## 选用哪种授权模式？\n\n如果客户端是保密的，应使用[授权码模式](#授权码模式)。\n\n如果客户端是公开的，应使用[隐式授权模式](#隐式授权模式)。\n\n如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用[密码模式](#密码模式)。\n\n如果客户端是以自己的名义，不与用户产生关系，应使用[客户端模式](#客户端模式)。\n\n\n## 预先注册\n\n客户端需要预先在授权服务器进行注册，用以获取 `client_id` 与 `client_secret`，也可以在注册是预先设定好 `redirect_uri`，以便于之后可以使用默认的 `redirect_uri`。\n\n\n## 授权码模式\n\n授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。\n\n#### 流程\n\n**第一部分（用户可见）**\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n *  `response_type`：授权类型，必选项，值固定为：`code`\n *   `client_id`：客户端ID，必选项\n *  `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n *  `scope`：权限范围，可选项，以空格分隔\n *  `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n* `code`：授权码(Authorization code)\n* `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序\n\n**第二部分（用户不可见）**\n\n客户端已得到授权，通过 `POST` 请求向授权服务器获取访问令牌(access token)：\n\n* `grant_type`：授权模式，值固定为：`authorization_code`\n* `client_id`：客户端ID\n* `client_secret`：客户端 secret\n* `redirect_uri`：使用与第一部分请求相同的 URI\n* `code`：第一部分所获的的授权码，要注意URL解码\n\n授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：\n\n* `token_type`：令牌类型，值固定为：`Bearer`\n\n* `expires_in`：访问令牌的存活时间\n\n* `access_token`：访问令牌\n\n* `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n\n#### 使用 oauth2-server 实现\n\n##### 初始化\n\nOAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 [Interfaces](#Interfaces) 与 [Traits](#Traits) 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 [Repositories](#Repositories) 与 [Entities](#Entities)。\n\n##### 初始化 server\n\n```php\n// 初始化存储库\n$clientRepository = new ClientRepository(); // Interface: ClientRepositoryInterface\n$scopeRepository = new ScopeRepository(); // Interface: ScopeRepositoryInterface\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n$authCodeRepository = new AuthCodeRepository(); // Interface: AuthCodeRepositoryInterface\n$refreshTokenRepository = new RefreshTokenRepository(); // Interface: RefreshTokenRepositoryInterface\n$userRepository = new UserRepository(); //Interface: UserRepositoryInterface\n\n// 私钥与加密密钥\n$privateKey = 'file://path/to/private.key';\n//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码\n$encryptionKey = 'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'; // 加密密钥字符串\n// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入\n\n// 初始化 server\n$server = new \\League\\OAuth2\\Server\\AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKey,\n    $encryptionKey\n);\n```\n\n##### 初始化授权码类型\n\n```php\n// 授权码授权类型初始化\n$grant = new \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(\n    $authCodeRepository,\n    $refreshTokenRepository,\n    new \\DateInterval('PT10M') // 设置授权码过期时间为10分钟\n);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将授权码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：https://example.com/authorize?response_type=code&client_id={client_id}&redirect_uri={redirect_uri}&scope{scope}&state={state})：\n\n```php\n$app->get('/authorize', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n        // 验证 HTTP 请求，并返回 authRequest 对象\n        $authRequest = $server->validateAuthorizationRequest($request);\n        // 此时应将 authRequest 对象序列化后存在当前会话(session)中\n        $_SESSION['authRequest'] = serialize($authRequest);\n        // 然后将用户重定向至登录入口或在当前地址直接响应登录页面\n        return $response->getBody()->write(file_get_contents(\"login.html\"));\n        \n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n        \n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n        \n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n客户端通过授权码请求访问令牌：\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 隐式授权模式\n\n隐式授权相当于是授权码模式的简化版本：\n\n#### 流程(用户可见)\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n* `response_type`：授权类型，必选项，值固定为：`token`\n* `client_id`：客户端ID，必选项\n* `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n* `scope`：权限范围，可选项，以空格分隔\n* `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序\n\n整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。\n\n*此模式下没有刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将隐式授权类型添加进 server\n$server->enableGrantType(\n    new ImplicitGrant(new \\DateInterval('PT1H')),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n\t      // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n\t\t\t\t// 设置用户实体(userEntity)\n\t\t    $authRequest->setUser(new UserEntity(1));\n\t\t\t\t// 设置权限范围\n\t\t\t\t$authRequest->setScopes(['basic'])\n\t\t\t\t// true = 批准，false = 拒绝\n\t\t    $authRequest->setAuthorizationApproved(true);\n\t\t\t\t// 完成后重定向至客户端请求重定向地址\n\t\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n## 密码模式\n\n密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。\n\n*OAuth2 协议规定此模式不需要传 `client_id` & `client_secret`，但 oauth-server 库需要*\n\n#### 流程\n\n客户端要求用户提供授权凭据，通常是账号密码\n\n然后，客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`password`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `username`：用户账号\n- `password`：用户密码\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\PasswordGrant(\n     $userRepository,\n     $refreshTokenRepository\n);\n\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将密码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 客户端模式\n\n客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`client_credentials`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n\n*此模式下无需刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将客户端授权类型添加进 server\n$server->enableGrantType(\n    new \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 刷新访问令牌(access token)\n\n访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`refresh_token`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `refresh_token`：刷新令牌\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 新的刷新令牌过期时间1个月\n\n// 将刷新访问令牌添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 新的访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 资源服务器验证访问令牌\n\noauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。\n\n客户端需要在 `HTTP Header` 中使用 `Authorization` 传入访问令牌，如果通过，中间件将会在 `request` 中加入对应数据：\n\n* `oauth_access_token_id`：访问令牌 id\n* `oauth_client_id`: 客户端id\n* `oauth_user_id`：用户id\n* `oauth_scopes`：权限范围\n\n授权不通过，则抛出 `OAuthServerException::accessDenied` 异常。\n\n```php\n// 初始化\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n\n// 授权服务器分发的公钥\n$publicKeyPath = 'file://path/to/public.key';\n        \n// 创建 ResourceServer\n$server = new \\League\\OAuth2\\Server\\ResourceServer(\n    $accessTokenRepository,\n    $publicKeyPath\n);\n\n// 中间件\nnew \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);\n```\n\n如果所用路由不支持中间件，可自行实现，符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可 ：\n\n```php\ntry {\n\t$request = $server->validateAuthenticatedRequest($request);\n} catch (OAuthServerException $exception) {\n\treturn $exception->generateHttpResponse($response);\n} catch (\\Exception $exception) {\n\treturn (new OAuthServerException($exception->getMessage(), 0, 'unknown_error', 500))->generateHttpResponse($response);\n}\n```\n\n\n\n## oauth2-server 实现\n\noauth2-server 的实现需要我们手动创建 [Repositories](#Repositories) 与 [Entities](#Entities)，下面展示一个项目目录示例：\n\n```\n- Entities\n\t- AccessTokenEntity.php\n\t- AuthCodeEntity.php\n\t- ClientEntity.php\n\t- RefreshTokenEntity.php\n\t- ScopeEntity.php\n\t- UserEntity.php\n- Repositories\n\t- AccessTokenRepository.php\n\t- AuthCodeRepository.php\n\t- ClientRepository.php\n\t- RefreshTokenRepository.php\n\t- ScopeRepository.php\n\t- UserRepository.php\n```\n\n### Repositories\n\nRepositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 [Interfaces](#Interfaces) 来定义所需要实现的方法。\n\n```php\nclass AccessTokenRepository implements AccessTokenRepositoryInterface\n{\n    /**\n     * @return AccessTokenEntityInterface\n     */\n    public function getNewToken(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)\n    {\n        // 创建新访问令牌时调用方法\n        // 需要返回 AccessTokenEntityInterface 对象\n        // 需要在返回前，向 AccessTokenEntity 传入参数中对应属性\n        // 示例代码：\n        $accessToken = new AccessTokenEntity();\n        $accessToken->setClient($clientEntity);\n        foreach ($scopes as $scope) {\n            $accessToken->addScope($scope);\n        }\n        $accessToken->setUserIdentifier($userIdentifier);\n\n        return $accessToken;\n    }\n\n    public function persistNewAccessToken(AccessTokenEntityInterface $accessTokenEntity)\n    {\n\t\t// 创建新访问令牌时调用此方法\n        // 可以用于持久化存储访问令牌，持久化数据库自行选择\n        // 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：\n        // $accessTokenEntity->getIdentifier(); // 获得令牌唯一标识符\n        // $accessTokenEntity->getExpiryDateTime(); // 获得令牌过期时间\n        // $accessTokenEntity->getUserIdentifier(); // 获得用户标识符\n        // $accessTokenEntity->getScopes(); // 获得权限范围\n        // $accessTokenEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAccessToken($tokenId)\n    {\n\t\t// 使用刷新令牌创建新的访问令牌时调用此方法\n        // 参数为原访问令牌的唯一标识符\n        // 可将其在持久化存储中过期\n    }\n\n    public function isAccessTokenRevoked($tokenId)\n    {\n        // 资源服务器验证访问令牌时将调用此方法\n        // 用于验证访问令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass AuthCodeRepository implements AuthCodeRepositoryInterface\n{\n    /**\n     * @return AuthCodeEntityInterface\n     */\n    public function getNewAuthCode()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 AuthCodeEntityInterface 对象\n        return new AuthCodeEntity();\n    }\n\n    public function persistNewAuthCode(AuthCodeEntityInterface $authCodeEntity)\n    {\n\t\t// 创建新授权码时调用此方法\n        // 可以用于持久化存储授权码，持久化数据库自行选择\n        // 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：\n        // $authCodeEntity->getIdentifier(); // 获得授权码唯一标识符\n        // $authCodeEntity->getExpiryDateTime(); // 获得授权码过期时间\n        // $authCodeEntity->getUserIdentifier(); // 获得用户标识符\n        // $authCodeEntity->getScopes(); // 获得权限范围\n        // $authCodeEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAuthCode($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 可以在此时将授权码从持久化数据库中删除\n        // 参数为授权码唯一标识符\n    }\n\n    public function isAuthCodeRevoked($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 用于验证授权码是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ClientRepository implements ClientRepositoryInterface\n{\n    /**\n     * @return ClientEntityInterface\n     */\n    public function getClientEntity($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)\n    {\n        // 获取客户端对象时调用方法，用于验证客户端\n        // 需要返回 ClientEntityInterface 对象\n        // $clientIdentifier 客户端唯一标识符\n        // $grantType 代表授权类型，根据类型不同，验证方式也不同\n        // $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的\n        // $mustValidateSecret 代表是否需要验证客户端密钥\n        $client = new ClientEntity();\n        $client->setIdentifier($clientIdentifier);\n\n        return $client;\n    }\n}\n```\n\n```php\nclass RefreshTokenRepository implements RefreshTokenRepositoryInterface\n{\n    /**\n     * @return RefreshTokenEntityInterface\n     */\n    public function getNewRefreshToken()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 RefreshTokenEntityInterface 对象\n        return new RefreshTokenEntity();\n    }\n\n    public function persistNewRefreshToken(RefreshTokenEntityInterface $refreshTokenEntity)\n    {\n\t\t// 创建新刷新令牌时调用此方法\n        // 用于持久化存储授刷新令牌\n        // 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：\n        // $refreshTokenEntity->getIdentifier(); // 获得刷新令牌唯一标识符\n        // $refreshTokenEntity->getExpiryDateTime(); // 获得刷新令牌过期时间\n        // $refreshTokenEntity->getAccessToken()->getIdentifier(); // 获得访问令牌标识符\n    }\n\n    public function revokeRefreshToken($tokenId)\n    {\n\t\t// 当使用刷新令牌获取访问令牌时调用此方法\n        // 原刷新令牌将删除，创建新的刷新令牌\n        // 参数为原刷新令牌唯一标识\n        // 可在此删除原刷新令牌\n    }\n\n    public function isRefreshTokenRevoked($tokenId)\n    {\n        // 当使用刷新令牌获取访问令牌时调用此方法\n        // 用于验证刷新令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ScopeRepository implements ScopeRepositoryInterface\n{\n    /**\n     * @return ScopeEntityInterface\n     */\n    public function getScopeEntityByIdentifier($identifier)\n    {\n        // 验证权限是否在权限范围中会调用此方法\n        // 参数为单个权限标识符\n        // ......\n        // 验证成功则返回 ScopeEntityInterface 对象\n        $scope = new ScopeEntity();\n        $scope->setIdentifier($identifier);\n\n        return $scope;\n    }\n\n    public function finalizeScopes(\n        array $scopes,\n        $grantType,\n        ClientEntityInterface $clientEntity,\n        $userIdentifier = null\n    ) {\n        // 在创建授权码与访问令牌前会调用此方法\n        // 用于验证权限范围、授权类型、客户端、用户是否匹配\n        // 可整合进项目自身的权限控制中\n        // 必须返回 ScopeEntityInterface 对象可用的 scope 数组\n        // 示例：\n        // $scope = new ScopeEntity();\n        // $scope->setIdentifier('example');\n        // $scopes[] = $scope;\n\n        return $scopes;\n    }\n}\n```\n\n```php\nclass UserRepository implements UserRepositoryInterface\n{\n    /**\n     * @return UserEntityInterface\n     */\n    public function getUserEntityByUserCredentials(\n        $username,\n        $password,\n        $grantType,\n        ClientEntityInterface $clientEntity\n    ) {\n        // 验证用户时调用此方法\n        // 用于验证用户信息是否符合\n        // 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)\n        // 验证成功返回 UserEntityInterface 对象\n        $user = new UserEntity();\n        $user->setIdentifier(1);\n\n        return $user;\n    }\n}\n```\n\n\n\n### Entities\n\nEntities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 [Interfaces](#Interfaces) 来定义需要实现的方法，同时提供了 [Traits](#Traits) 帮助我们实现，可以选择使用，有需要时也可以重写。\n\n```php\nclass AccessTokenEntity implements AccessTokenEntityInterface\n{\n    use AccessTokenTrait, TokenEntityTrait, EntityTrait;\n}\n```\n\n```php\nclass AuthCodeEntity implements AuthCodeEntityInterface\n{\n    use EntityTrait, TokenEntityTrait, AuthCodeTrait;\n}\n```\n\n```php\nclass ClientEntity implements ClientEntityInterface\n{\n    use EntityTrait, ClientTrait;\n}\n```\n\n```php\nclass RefreshTokenEntity implements RefreshTokenEntityInterface\n{\n    use RefreshTokenTrait, EntityTrait;\n}\n```\n\n```php\nclass ScopeEntity implements ScopeEntityInterface\n{\n    use EntityTrait;\n\t\n    // 没有 Trait 实现这个方法，需要自行实现\n    // oauth2-server 项目的测试代码的实现例子\n    public function jsonSerialize()\n    {\n        return $this->getIdentifier();\n    }\n}\n```\n\n```php\nclass UserEntity implements UserEntityInterface\n{\n    use EntityTrait;\n}\n```\n\n### Interfaces\n\n**Repositories**\n\n* League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php\n\n**Entities**\n\n* League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\TokenInterface.php\n* League\\OAuth2\\Server\\Entities\\UserEntityInterface.php\n\n### Traits\n\n* League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php\n\n\n\n## 事件\n\noauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。\n\n##### client.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'client.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n客户端身份验证未通过时触发此事件。你可以在客户端尝试 `n` 次失败后禁止它一段时间内的再次尝试。\n\n##### user.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'user.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 `n` 次后禁止用户再次尝试。\n\n\n\n## 参考文章\n\n《oauth2-server 官方文档》(https://oauth2.thephpleague.com/)\n\n《理解OAuth 2.0》-阮一峰（http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）","source":"_posts/OAuth2.0-and-oauth2-server-package.md","raw":"---\ntitle: OAuth2.0 与 oauth2-server 库的使用\ndate: 2018/11/22 20:08:09\n---\n\n[OAuth2.0](https://en.wikipedia.org/wiki/OAuth) 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。\n\n[league/oauth2-server](https://github.com/thephpleague/oauth2-server) 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。\n\n本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。\n\n<!--more-->  \n\n## 术语\n\n了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。\n\n**OAuth2.0 定义了四个角色**\n\n1. **Client**：客户端，第三方应用程序。\n2. **Resource Owner**：资源所有者，授权 Client 访问其帐户的用户。\n3. **Authorization server**：授权服务器，服务商专用于处理用户授权认证的服务器。\n4. **Resource server**：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。\n\n**oauth2-server**\n\n1. **Access token**：用于访问受保护资源的令牌。\n2. **Authorization code**：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。\n3. **Scope**：授予应用程序的权限范围。\n4. **JWT**：[Json Web Token](https://tools.ietf.org/html/rfc7519) 是一种用于安全传输的数据传输格式。\n\n\n## 运行流程\n![flowchart.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg)\n\n\n## 安装\n\n推荐使用 [Composer](https://getcomposer.org/) 进行安装：\n\n```string\ncomposer require league/oauth2-server\n```\n\n根据[授权模式](#授权模式)的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。\n\n*本文发布时，版本号为7.3.1。*\n\n\n\n**生成公钥与私钥**\n\n公钥与私钥用于签名和验证传输的 [JWT](https://tools.ietf.org/html/rfc7519)，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。\n\n*oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。*\n\n生成私钥，在终端中运行：\n\n```string\nopenssl genrsa -out private.key 2048\n```\n\n使用私钥提取私钥：\n\n```string\nopenssl rsa -in private.key -pubout -out public.key\n```\n\n私钥必须保密于授权服务器中，并将公钥分发给资源服务器。\n\n\n\n**生成加密密钥**\n\n加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，`string` 或 `defuse/php-encryption` 库的对象。\n\n*加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。*\n\n生成字符串密钥，在终端中输入：\n\n```string\nphp -r 'echo base64_encode(random_bytes(32)), PHP_EOL;'\n```\n\n生成对象，在项目根目录的终端中输入：\n\n```string\nvendor/bin/generate-defuse-key\n```\n\n将获得的内容，传入 AuthorizationServer：\n\n```php\nuse \\Defuse\\Crypto\\Key;\n$server = new AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKeyPath,\n    Key::loadFromAsciiSafeString($encryptionKey) //传入加密密钥\n);\n```\n\n\n\n**PHP版本支持**\n\n- PHP 7.0\n- PHP 7.1\n- PHP 7.2\n\n\n\n## 授权模式\n\nOAuth2.0 定义了四种授权模式，以应对不同情况时的授权。\n\n1. 授权码模式\n2. 隐式授权模式\n3. 密码模式\n4. 客户端模式\n\n\n\n## 客户端类型 \n\n* 保密的：\n\t* 客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）\n* 公开的：\n\t* 客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）\n\n\n\n## 选用哪种授权模式？\n\n如果客户端是保密的，应使用[授权码模式](#授权码模式)。\n\n如果客户端是公开的，应使用[隐式授权模式](#隐式授权模式)。\n\n如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用[密码模式](#密码模式)。\n\n如果客户端是以自己的名义，不与用户产生关系，应使用[客户端模式](#客户端模式)。\n\n\n## 预先注册\n\n客户端需要预先在授权服务器进行注册，用以获取 `client_id` 与 `client_secret`，也可以在注册是预先设定好 `redirect_uri`，以便于之后可以使用默认的 `redirect_uri`。\n\n\n## 授权码模式\n\n授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。\n\n#### 流程\n\n**第一部分（用户可见）**\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n *  `response_type`：授权类型，必选项，值固定为：`code`\n *   `client_id`：客户端ID，必选项\n *  `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n *  `scope`：权限范围，可选项，以空格分隔\n *  `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n* `code`：授权码(Authorization code)\n* `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序\n\n**第二部分（用户不可见）**\n\n客户端已得到授权，通过 `POST` 请求向授权服务器获取访问令牌(access token)：\n\n* `grant_type`：授权模式，值固定为：`authorization_code`\n* `client_id`：客户端ID\n* `client_secret`：客户端 secret\n* `redirect_uri`：使用与第一部分请求相同的 URI\n* `code`：第一部分所获的的授权码，要注意URL解码\n\n授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：\n\n* `token_type`：令牌类型，值固定为：`Bearer`\n\n* `expires_in`：访问令牌的存活时间\n\n* `access_token`：访问令牌\n\n* `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n\n#### 使用 oauth2-server 实现\n\n##### 初始化\n\nOAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 [Interfaces](#Interfaces) 与 [Traits](#Traits) 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 [Repositories](#Repositories) 与 [Entities](#Entities)。\n\n##### 初始化 server\n\n```php\n// 初始化存储库\n$clientRepository = new ClientRepository(); // Interface: ClientRepositoryInterface\n$scopeRepository = new ScopeRepository(); // Interface: ScopeRepositoryInterface\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n$authCodeRepository = new AuthCodeRepository(); // Interface: AuthCodeRepositoryInterface\n$refreshTokenRepository = new RefreshTokenRepository(); // Interface: RefreshTokenRepositoryInterface\n$userRepository = new UserRepository(); //Interface: UserRepositoryInterface\n\n// 私钥与加密密钥\n$privateKey = 'file://path/to/private.key';\n//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码\n$encryptionKey = 'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'; // 加密密钥字符串\n// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入\n\n// 初始化 server\n$server = new \\League\\OAuth2\\Server\\AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKey,\n    $encryptionKey\n);\n```\n\n##### 初始化授权码类型\n\n```php\n// 授权码授权类型初始化\n$grant = new \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(\n    $authCodeRepository,\n    $refreshTokenRepository,\n    new \\DateInterval('PT10M') // 设置授权码过期时间为10分钟\n);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将授权码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：https://example.com/authorize?response_type=code&client_id={client_id}&redirect_uri={redirect_uri}&scope{scope}&state={state})：\n\n```php\n$app->get('/authorize', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n        // 验证 HTTP 请求，并返回 authRequest 对象\n        $authRequest = $server->validateAuthorizationRequest($request);\n        // 此时应将 authRequest 对象序列化后存在当前会话(session)中\n        $_SESSION['authRequest'] = serialize($authRequest);\n        // 然后将用户重定向至登录入口或在当前地址直接响应登录页面\n        return $response->getBody()->write(file_get_contents(\"login.html\"));\n        \n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n        \n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n        \n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n客户端通过授权码请求访问令牌：\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 隐式授权模式\n\n隐式授权相当于是授权码模式的简化版本：\n\n#### 流程(用户可见)\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n* `response_type`：授权类型，必选项，值固定为：`token`\n* `client_id`：客户端ID，必选项\n* `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n* `scope`：权限范围，可选项，以空格分隔\n* `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序\n\n整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。\n\n*此模式下没有刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将隐式授权类型添加进 server\n$server->enableGrantType(\n    new ImplicitGrant(new \\DateInterval('PT1H')),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n\t      // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n\t\t\t\t// 设置用户实体(userEntity)\n\t\t    $authRequest->setUser(new UserEntity(1));\n\t\t\t\t// 设置权限范围\n\t\t\t\t$authRequest->setScopes(['basic'])\n\t\t\t\t// true = 批准，false = 拒绝\n\t\t    $authRequest->setAuthorizationApproved(true);\n\t\t\t\t// 完成后重定向至客户端请求重定向地址\n\t\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n## 密码模式\n\n密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。\n\n*OAuth2 协议规定此模式不需要传 `client_id` & `client_secret`，但 oauth-server 库需要*\n\n#### 流程\n\n客户端要求用户提供授权凭据，通常是账号密码\n\n然后，客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`password`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `username`：用户账号\n- `password`：用户密码\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\PasswordGrant(\n     $userRepository,\n     $refreshTokenRepository\n);\n\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将密码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 客户端模式\n\n客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`client_credentials`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n\n*此模式下无需刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将客户端授权类型添加进 server\n$server->enableGrantType(\n    new \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 刷新访问令牌(access token)\n\n访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`refresh_token`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `refresh_token`：刷新令牌\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 新的刷新令牌过期时间1个月\n\n// 将刷新访问令牌添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 新的访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 资源服务器验证访问令牌\n\noauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。\n\n客户端需要在 `HTTP Header` 中使用 `Authorization` 传入访问令牌，如果通过，中间件将会在 `request` 中加入对应数据：\n\n* `oauth_access_token_id`：访问令牌 id\n* `oauth_client_id`: 客户端id\n* `oauth_user_id`：用户id\n* `oauth_scopes`：权限范围\n\n授权不通过，则抛出 `OAuthServerException::accessDenied` 异常。\n\n```php\n// 初始化\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n\n// 授权服务器分发的公钥\n$publicKeyPath = 'file://path/to/public.key';\n        \n// 创建 ResourceServer\n$server = new \\League\\OAuth2\\Server\\ResourceServer(\n    $accessTokenRepository,\n    $publicKeyPath\n);\n\n// 中间件\nnew \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);\n```\n\n如果所用路由不支持中间件，可自行实现，符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可 ：\n\n```php\ntry {\n\t$request = $server->validateAuthenticatedRequest($request);\n} catch (OAuthServerException $exception) {\n\treturn $exception->generateHttpResponse($response);\n} catch (\\Exception $exception) {\n\treturn (new OAuthServerException($exception->getMessage(), 0, 'unknown_error', 500))->generateHttpResponse($response);\n}\n```\n\n\n\n## oauth2-server 实现\n\noauth2-server 的实现需要我们手动创建 [Repositories](#Repositories) 与 [Entities](#Entities)，下面展示一个项目目录示例：\n\n```\n- Entities\n\t- AccessTokenEntity.php\n\t- AuthCodeEntity.php\n\t- ClientEntity.php\n\t- RefreshTokenEntity.php\n\t- ScopeEntity.php\n\t- UserEntity.php\n- Repositories\n\t- AccessTokenRepository.php\n\t- AuthCodeRepository.php\n\t- ClientRepository.php\n\t- RefreshTokenRepository.php\n\t- ScopeRepository.php\n\t- UserRepository.php\n```\n\n### Repositories\n\nRepositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 [Interfaces](#Interfaces) 来定义所需要实现的方法。\n\n```php\nclass AccessTokenRepository implements AccessTokenRepositoryInterface\n{\n    /**\n     * @return AccessTokenEntityInterface\n     */\n    public function getNewToken(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)\n    {\n        // 创建新访问令牌时调用方法\n        // 需要返回 AccessTokenEntityInterface 对象\n        // 需要在返回前，向 AccessTokenEntity 传入参数中对应属性\n        // 示例代码：\n        $accessToken = new AccessTokenEntity();\n        $accessToken->setClient($clientEntity);\n        foreach ($scopes as $scope) {\n            $accessToken->addScope($scope);\n        }\n        $accessToken->setUserIdentifier($userIdentifier);\n\n        return $accessToken;\n    }\n\n    public function persistNewAccessToken(AccessTokenEntityInterface $accessTokenEntity)\n    {\n\t\t// 创建新访问令牌时调用此方法\n        // 可以用于持久化存储访问令牌，持久化数据库自行选择\n        // 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：\n        // $accessTokenEntity->getIdentifier(); // 获得令牌唯一标识符\n        // $accessTokenEntity->getExpiryDateTime(); // 获得令牌过期时间\n        // $accessTokenEntity->getUserIdentifier(); // 获得用户标识符\n        // $accessTokenEntity->getScopes(); // 获得权限范围\n        // $accessTokenEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAccessToken($tokenId)\n    {\n\t\t// 使用刷新令牌创建新的访问令牌时调用此方法\n        // 参数为原访问令牌的唯一标识符\n        // 可将其在持久化存储中过期\n    }\n\n    public function isAccessTokenRevoked($tokenId)\n    {\n        // 资源服务器验证访问令牌时将调用此方法\n        // 用于验证访问令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass AuthCodeRepository implements AuthCodeRepositoryInterface\n{\n    /**\n     * @return AuthCodeEntityInterface\n     */\n    public function getNewAuthCode()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 AuthCodeEntityInterface 对象\n        return new AuthCodeEntity();\n    }\n\n    public function persistNewAuthCode(AuthCodeEntityInterface $authCodeEntity)\n    {\n\t\t// 创建新授权码时调用此方法\n        // 可以用于持久化存储授权码，持久化数据库自行选择\n        // 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：\n        // $authCodeEntity->getIdentifier(); // 获得授权码唯一标识符\n        // $authCodeEntity->getExpiryDateTime(); // 获得授权码过期时间\n        // $authCodeEntity->getUserIdentifier(); // 获得用户标识符\n        // $authCodeEntity->getScopes(); // 获得权限范围\n        // $authCodeEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAuthCode($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 可以在此时将授权码从持久化数据库中删除\n        // 参数为授权码唯一标识符\n    }\n\n    public function isAuthCodeRevoked($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 用于验证授权码是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ClientRepository implements ClientRepositoryInterface\n{\n    /**\n     * @return ClientEntityInterface\n     */\n    public function getClientEntity($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)\n    {\n        // 获取客户端对象时调用方法，用于验证客户端\n        // 需要返回 ClientEntityInterface 对象\n        // $clientIdentifier 客户端唯一标识符\n        // $grantType 代表授权类型，根据类型不同，验证方式也不同\n        // $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的\n        // $mustValidateSecret 代表是否需要验证客户端密钥\n        $client = new ClientEntity();\n        $client->setIdentifier($clientIdentifier);\n\n        return $client;\n    }\n}\n```\n\n```php\nclass RefreshTokenRepository implements RefreshTokenRepositoryInterface\n{\n    /**\n     * @return RefreshTokenEntityInterface\n     */\n    public function getNewRefreshToken()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 RefreshTokenEntityInterface 对象\n        return new RefreshTokenEntity();\n    }\n\n    public function persistNewRefreshToken(RefreshTokenEntityInterface $refreshTokenEntity)\n    {\n\t\t// 创建新刷新令牌时调用此方法\n        // 用于持久化存储授刷新令牌\n        // 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：\n        // $refreshTokenEntity->getIdentifier(); // 获得刷新令牌唯一标识符\n        // $refreshTokenEntity->getExpiryDateTime(); // 获得刷新令牌过期时间\n        // $refreshTokenEntity->getAccessToken()->getIdentifier(); // 获得访问令牌标识符\n    }\n\n    public function revokeRefreshToken($tokenId)\n    {\n\t\t// 当使用刷新令牌获取访问令牌时调用此方法\n        // 原刷新令牌将删除，创建新的刷新令牌\n        // 参数为原刷新令牌唯一标识\n        // 可在此删除原刷新令牌\n    }\n\n    public function isRefreshTokenRevoked($tokenId)\n    {\n        // 当使用刷新令牌获取访问令牌时调用此方法\n        // 用于验证刷新令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ScopeRepository implements ScopeRepositoryInterface\n{\n    /**\n     * @return ScopeEntityInterface\n     */\n    public function getScopeEntityByIdentifier($identifier)\n    {\n        // 验证权限是否在权限范围中会调用此方法\n        // 参数为单个权限标识符\n        // ......\n        // 验证成功则返回 ScopeEntityInterface 对象\n        $scope = new ScopeEntity();\n        $scope->setIdentifier($identifier);\n\n        return $scope;\n    }\n\n    public function finalizeScopes(\n        array $scopes,\n        $grantType,\n        ClientEntityInterface $clientEntity,\n        $userIdentifier = null\n    ) {\n        // 在创建授权码与访问令牌前会调用此方法\n        // 用于验证权限范围、授权类型、客户端、用户是否匹配\n        // 可整合进项目自身的权限控制中\n        // 必须返回 ScopeEntityInterface 对象可用的 scope 数组\n        // 示例：\n        // $scope = new ScopeEntity();\n        // $scope->setIdentifier('example');\n        // $scopes[] = $scope;\n\n        return $scopes;\n    }\n}\n```\n\n```php\nclass UserRepository implements UserRepositoryInterface\n{\n    /**\n     * @return UserEntityInterface\n     */\n    public function getUserEntityByUserCredentials(\n        $username,\n        $password,\n        $grantType,\n        ClientEntityInterface $clientEntity\n    ) {\n        // 验证用户时调用此方法\n        // 用于验证用户信息是否符合\n        // 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)\n        // 验证成功返回 UserEntityInterface 对象\n        $user = new UserEntity();\n        $user->setIdentifier(1);\n\n        return $user;\n    }\n}\n```\n\n\n\n### Entities\n\nEntities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 [Interfaces](#Interfaces) 来定义需要实现的方法，同时提供了 [Traits](#Traits) 帮助我们实现，可以选择使用，有需要时也可以重写。\n\n```php\nclass AccessTokenEntity implements AccessTokenEntityInterface\n{\n    use AccessTokenTrait, TokenEntityTrait, EntityTrait;\n}\n```\n\n```php\nclass AuthCodeEntity implements AuthCodeEntityInterface\n{\n    use EntityTrait, TokenEntityTrait, AuthCodeTrait;\n}\n```\n\n```php\nclass ClientEntity implements ClientEntityInterface\n{\n    use EntityTrait, ClientTrait;\n}\n```\n\n```php\nclass RefreshTokenEntity implements RefreshTokenEntityInterface\n{\n    use RefreshTokenTrait, EntityTrait;\n}\n```\n\n```php\nclass ScopeEntity implements ScopeEntityInterface\n{\n    use EntityTrait;\n\t\n    // 没有 Trait 实现这个方法，需要自行实现\n    // oauth2-server 项目的测试代码的实现例子\n    public function jsonSerialize()\n    {\n        return $this->getIdentifier();\n    }\n}\n```\n\n```php\nclass UserEntity implements UserEntityInterface\n{\n    use EntityTrait;\n}\n```\n\n### Interfaces\n\n**Repositories**\n\n* League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php\n\n**Entities**\n\n* League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\TokenInterface.php\n* League\\OAuth2\\Server\\Entities\\UserEntityInterface.php\n\n### Traits\n\n* League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php\n\n\n\n## 事件\n\noauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。\n\n##### client.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'client.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n客户端身份验证未通过时触发此事件。你可以在客户端尝试 `n` 次失败后禁止它一段时间内的再次尝试。\n\n##### user.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'user.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 `n` 次后禁止用户再次尝试。\n\n\n\n## 参考文章\n\n《oauth2-server 官方文档》(https://oauth2.thephpleague.com/)\n\n《理解OAuth 2.0》-阮一峰（http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）","slug":"OAuth2.0-and-oauth2-server-package","published":1,"updated":"2020-07-23T00:29:18.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea4000dcyzeqmkhup2e","content":"<p><a href=\"https://en.wikipedia.org/wiki/OAuth\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a> 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。</p>\n<p><a href=\"https://github.com/thephpleague/oauth2-server\" target=\"_blank\" rel=\"noopener\">league/oauth2-server</a> 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。</p>\n<p>本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。</p>\n<a id=\"more\"></a>  \n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。</p>\n<p><strong>OAuth2.0 定义了四个角色</strong></p>\n<ol>\n<li><strong>Client</strong>：客户端，第三方应用程序。</li>\n<li><strong>Resource Owner</strong>：资源所有者，授权 Client 访问其帐户的用户。</li>\n<li><strong>Authorization server</strong>：授权服务器，服务商专用于处理用户授权认证的服务器。</li>\n<li><strong>Resource server</strong>：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。</li>\n</ol>\n<p><strong>oauth2-server</strong></p>\n<ol>\n<li><strong>Access token</strong>：用于访问受保护资源的令牌。</li>\n<li><strong>Authorization code</strong>：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。</li>\n<li><strong>Scope</strong>：授予应用程序的权限范围。</li>\n<li><strong>JWT</strong>：<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">Json Web Token</a> 是一种用于安全传输的数据传输格式。</li>\n</ol>\n<h2 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h2><p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg\" alt=\"flowchart.png\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>推荐使用 <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">Composer</a> 进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require league/oauth2-server</span><br></pre></td></tr></table></figure>\n<p>根据<a href=\"#授权模式\">授权模式</a>的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。</p>\n<p><em>本文发布时，版本号为7.3.1。</em></p>\n<p><strong>生成公钥与私钥</strong></p>\n<p>公钥与私钥用于签名和验证传输的 <a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">JWT</a>，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。</p>\n<p><em>oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。</em></p>\n<p>生成私钥，在终端中运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out private.key 2048</span><br></pre></td></tr></table></figure>\n<p>使用私钥提取私钥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in private.key -pubout -out public.key</span><br></pre></td></tr></table></figure>\n<p>私钥必须保密于授权服务器中，并将公钥分发给资源服务器。</p>\n<p><strong>生成加密密钥</strong></p>\n<p>加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，<code>string</code> 或 <code>defuse/php-encryption</code> 库的对象。</p>\n<p><em>加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。</em></p>\n<p>生成字符串密钥，在终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &apos;echo base64_encode(random_bytes(32)), PHP_EOL;&apos;</span><br></pre></td></tr></table></figure>\n<p>生成对象，在项目根目录的终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vendor/bin/generate-defuse-key</span><br></pre></td></tr></table></figure>\n<p>将获得的内容，传入 AuthorizationServer：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> \\<span class=\"title\">Defuse</span>\\<span class=\"title\">Crypto</span>\\<span class=\"title\">Key</span>;</span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKeyPath,</span><br><span class=\"line\">    Key::loadFromAsciiSafeString($encryptionKey) <span class=\"comment\">//传入加密密钥</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><strong>PHP版本支持</strong></p>\n<ul>\n<li>PHP 7.0</li>\n<li>PHP 7.1</li>\n<li>PHP 7.2</li>\n</ul>\n<h2 id=\"授权模式\"><a href=\"#授权模式\" class=\"headerlink\" title=\"授权模式\"></a>授权模式</h2><p>OAuth2.0 定义了四种授权模式，以应对不同情况时的授权。</p>\n<ol>\n<li>授权码模式</li>\n<li>隐式授权模式</li>\n<li>密码模式</li>\n<li>客户端模式</li>\n</ol>\n<h2 id=\"客户端类型\"><a href=\"#客户端类型\" class=\"headerlink\" title=\"客户端类型\"></a>客户端类型</h2><ul>\n<li>保密的：<ul>\n<li>客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）</li>\n</ul>\n</li>\n<li>公开的：<ul>\n<li>客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选用哪种授权模式？\"><a href=\"#选用哪种授权模式？\" class=\"headerlink\" title=\"选用哪种授权模式？\"></a>选用哪种授权模式？</h2><p>如果客户端是保密的，应使用<a href=\"#授权码模式\">授权码模式</a>。</p>\n<p>如果客户端是公开的，应使用<a href=\"#隐式授权模式\">隐式授权模式</a>。</p>\n<p>如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用<a href=\"#密码模式\">密码模式</a>。</p>\n<p>如果客户端是以自己的名义，不与用户产生关系，应使用<a href=\"#客户端模式\">客户端模式</a>。</p>\n<h2 id=\"预先注册\"><a href=\"#预先注册\" class=\"headerlink\" title=\"预先注册\"></a>预先注册</h2><p>客户端需要预先在授权服务器进行注册，用以获取 <code>client_id</code> 与 <code>client_secret</code>，也可以在注册是预先设定好 <code>redirect_uri</code>，以便于之后可以使用默认的 <code>redirect_uri</code>。</p>\n<h2 id=\"授权码模式\"><a href=\"#授权码模式\" class=\"headerlink\" title=\"授权码模式\"></a>授权码模式</h2><p>授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。</p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p><strong>第一部分（用户可见）</strong></p>\n<p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>code</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>code</code>：授权码(Authorization code)</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序</li>\n</ul>\n<p><strong>第二部分（用户不可见）</strong></p>\n<p>客户端已得到授权，通过 <code>POST</code> 请求向授权服务器获取访问令牌(access token)：</p>\n<ul>\n<li><code>grant_type</code>：授权模式，值固定为：<code>authorization_code</code></li>\n<li><code>client_id</code>：客户端ID</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>redirect_uri</code>：使用与第一部分请求相同的 URI</li>\n<li><code>code</code>：第一部分所获的的授权码，要注意URL解码</li>\n</ul>\n<p>授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：</p>\n<ul>\n<li><p><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></p>\n</li>\n<li><p><code>expires_in</code>：访问令牌的存活时间</p>\n</li>\n<li><p><code>access_token</code>：访问令牌</p>\n</li>\n<li><p><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</p>\n</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现\"><a href=\"#使用-oauth2-server-实现\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><p>OAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 <a href=\"#Interfaces\">Interfaces</a> 与 <a href=\"#Traits\">Traits</a> 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>。</p>\n<h5 id=\"初始化-server\"><a href=\"#初始化-server\" class=\"headerlink\" title=\"初始化 server\"></a>初始化 server</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化存储库</span></span><br><span class=\"line\">$clientRepository = <span class=\"keyword\">new</span> ClientRepository(); <span class=\"comment\">// Interface: ClientRepositoryInterface</span></span><br><span class=\"line\">$scopeRepository = <span class=\"keyword\">new</span> ScopeRepository(); <span class=\"comment\">// Interface: ScopeRepositoryInterface</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\">$authCodeRepository = <span class=\"keyword\">new</span> AuthCodeRepository(); <span class=\"comment\">// Interface: AuthCodeRepositoryInterface</span></span><br><span class=\"line\">$refreshTokenRepository = <span class=\"keyword\">new</span> RefreshTokenRepository(); <span class=\"comment\">// Interface: RefreshTokenRepositoryInterface</span></span><br><span class=\"line\">$userRepository = <span class=\"keyword\">new</span> UserRepository(); <span class=\"comment\">//Interface: UserRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 私钥与加密密钥</span></span><br><span class=\"line\">$privateKey = <span class=\"string\">'file://path/to/private.key'</span>;</span><br><span class=\"line\"><span class=\"comment\">//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码</span></span><br><span class=\"line\">$encryptionKey = <span class=\"string\">'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'</span>; <span class=\"comment\">// 加密密钥字符串</span></span><br><span class=\"line\"><span class=\"comment\">// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化 server</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKey,</span><br><span class=\"line\">    $encryptionKey</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h5 id=\"初始化授权码类型\"><a href=\"#初始化授权码类型\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 授权码授权类型初始化</span></span><br><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(</span><br><span class=\"line\">    $authCodeRepository,</span><br><span class=\"line\">    $refreshTokenRepository,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT10M'</span>) <span class=\"comment\">// 设置授权码过期时间为10分钟</span></span><br><span class=\"line\">);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将授权码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<p>用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：<a href=\"https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：\" target=\"_blank\" rel=\"noopener\">https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：</a></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;get(<span class=\"string\">'/authorize'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证 HTTP 请求，并返回 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = $server-&gt;validateAuthorizationRequest($request);</span><br><span class=\"line\">        <span class=\"comment\">// 此时应将 authRequest 对象序列化后存在当前会话(session)中</span></span><br><span class=\"line\">        $_SESSION[<span class=\"string\">'authRequest'</span>] = serialize($authRequest);</span><br><span class=\"line\">        <span class=\"comment\">// 然后将用户重定向至登录入口或在当前地址直接响应登录页面</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;getBody()-&gt;write(file_get_contents(<span class=\"string\">\"login.html\"</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">        // 设置用户实体(userEntity)</span><br><span class=\"line\">        $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">        // 设置权限范围</span><br><span class=\"line\">        $authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">        // true = 批准，false = 拒绝</span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">        // 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">        // 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>客户端通过授权码请求访问令牌：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式授权模式\"><a href=\"#隐式授权模式\" class=\"headerlink\" title=\"隐式授权模式\"></a>隐式授权模式</h2><p>隐式授权相当于是授权码模式的简化版本：</p>\n<h4 id=\"流程-用户可见\"><a href=\"#流程-用户可见\" class=\"headerlink\" title=\"流程(用户可见)\"></a>流程(用户可见)</h4><p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序</li>\n</ul>\n<p>整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。</p>\n<p><em>此模式下没有刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-1\"><a href=\"#使用-oauth2-server-实现-1\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-1\"><a href=\"#初始化授权码类型-1\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将隐式授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ImplicitGrant(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>)),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/login'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在会话(session)中取出 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[<span class=\"string\">'authRequest'</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 设置用户实体(userEntity)</span></span><br><span class=\"line\">        $authRequest-&gt;setUser(<span class=\"keyword\">new</span> UserEntity(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置权限范围</span></span><br><span class=\"line\">        $authRequest-&gt;setScopes([<span class=\"string\">'basic'</span>])</span><br><span class=\"line\">        <span class=\"comment\">// true = 批准，false = 拒绝</span></span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 完成后重定向至客户端请求重定向地址</span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">\t      // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">\t\t\t\t// 设置用户实体(userEntity)</span><br><span class=\"line\">\t\t    $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">\t\t\t\t// 设置权限范围</span><br><span class=\"line\">\t\t\t\t$authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">\t\t\t\t// true = 批准，false = 拒绝</span><br><span class=\"line\">\t\t    $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">\t\t\t\t// 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">    \t// 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"密码模式\"><a href=\"#密码模式\" class=\"headerlink\" title=\"密码模式\"></a>密码模式</h2><p>密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。</p>\n<p><em>OAuth2 协议规定此模式不需要传 <code>client_id</code> &amp; <code>client_secret</code>，但 oauth-server 库需要</em></p>\n<h4 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端要求用户提供授权凭据，通常是账号密码</p>\n<p>然后，客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>password</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>username</code>：用户账号</li>\n<li><code>password</code>：用户密码</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-2\"><a href=\"#使用-oauth2-server-实现-2\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-2\"><a href=\"#初始化授权码类型-2\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\PasswordGrant(</span><br><span class=\"line\">     $userRepository,</span><br><span class=\"line\">     $refreshTokenRepository</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将密码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端模式\"><a href=\"#客户端模式\" class=\"headerlink\" title=\"客户端模式\"></a>客户端模式</h2><p>客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。</p>\n<h4 id=\"流程-2\"><a href=\"#流程-2\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>client_credentials</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n</ul>\n<p><em>此模式下无需刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-3\"><a href=\"#使用-oauth2-server-实现-3\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-3\"><a href=\"#初始化授权码类型-3\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将客户端授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新访问令牌-access-token\"><a href=\"#刷新访问令牌-access-token\" class=\"headerlink\" title=\"刷新访问令牌(access token)\"></a>刷新访问令牌(access token)</h2><p>访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。</p>\n<h4 id=\"流程-3\"><a href=\"#流程-3\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>refresh_token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>refresh_token</code>：刷新令牌</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-4\"><a href=\"#使用-oauth2-server-实现-4\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-4\"><a href=\"#初始化授权码类型-4\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 新的刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将刷新访问令牌添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 新的访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"资源服务器验证访问令牌\"><a href=\"#资源服务器验证访问令牌\" class=\"headerlink\" title=\"资源服务器验证访问令牌\"></a>资源服务器验证访问令牌</h2><p>oauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。</p>\n<p>客户端需要在 <code>HTTP Header</code> 中使用 <code>Authorization</code> 传入访问令牌，如果通过，中间件将会在 <code>request</code> 中加入对应数据：</p>\n<ul>\n<li><code>oauth_access_token_id</code>：访问令牌 id</li>\n<li><code>oauth_client_id</code>: 客户端id</li>\n<li><code>oauth_user_id</code>：用户id</li>\n<li><code>oauth_scopes</code>：权限范围</li>\n</ul>\n<p>授权不通过，则抛出 <code>OAuthServerException::accessDenied</code> 异常。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 授权服务器分发的公钥</span></span><br><span class=\"line\">$publicKeyPath = <span class=\"string\">'file://path/to/public.key'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// 创建 ResourceServer</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\ResourceServer(</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $publicKeyPath</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中间件</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);</span><br></pre></td></tr></table></figure>\n<p>如果所用路由不支持中间件，可自行实现，符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可 ：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t$request = $server-&gt;validateAuthenticatedRequest($request);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> OAuthServerException($exception-&gt;getMessage(), <span class=\"number\">0</span>, <span class=\"string\">'unknown_error'</span>, <span class=\"number\">500</span>))-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"oauth2-server-实现\"><a href=\"#oauth2-server-实现\" class=\"headerlink\" title=\"oauth2-server 实现\"></a>oauth2-server 实现</h2><p>oauth2-server 的实现需要我们手动创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>，下面展示一个项目目录示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Entities</span><br><span class=\"line\">\t- AccessTokenEntity.php</span><br><span class=\"line\">\t- AuthCodeEntity.php</span><br><span class=\"line\">\t- ClientEntity.php</span><br><span class=\"line\">\t- RefreshTokenEntity.php</span><br><span class=\"line\">\t- ScopeEntity.php</span><br><span class=\"line\">\t- UserEntity.php</span><br><span class=\"line\">- Repositories</span><br><span class=\"line\">\t- AccessTokenRepository.php</span><br><span class=\"line\">\t- AuthCodeRepository.php</span><br><span class=\"line\">\t- ClientRepository.php</span><br><span class=\"line\">\t- RefreshTokenRepository.php</span><br><span class=\"line\">\t- ScopeRepository.php</span><br><span class=\"line\">\t- UserRepository.php</span><br></pre></td></tr></table></figure>\n<h3 id=\"Repositories\"><a href=\"#Repositories\" class=\"headerlink\" title=\"Repositories\"></a>Repositories</h3><p>Repositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义所需要实现的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AccessTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewToken</span><span class=\"params\">(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新访问令牌时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AccessTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要在返回前，向 AccessTokenEntity 传入参数中对应属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例代码：</span></span><br><span class=\"line\">        $accessToken = <span class=\"keyword\">new</span> AccessTokenEntity();</span><br><span class=\"line\">        $accessToken-&gt;setClient($clientEntity);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> ($scopes <span class=\"keyword\">as</span> $scope) &#123;</span><br><span class=\"line\">            $accessToken-&gt;addScope($scope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $accessToken-&gt;setUserIdentifier($userIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $accessToken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAccessToken</span><span class=\"params\">(AccessTokenEntityInterface $accessTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储访问令牌，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getIdentifier(); // 获得令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getExpiryDateTime(); // 获得令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAccessToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用刷新令牌创建新的访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原访问令牌的唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// 可将其在持久化存储中过期</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAccessTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源服务器验证访问令牌时将调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证访问令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AuthCodeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewAuthCode</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AuthCodeEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AuthCodeEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAuthCode</span><span class=\"params\">(AuthCodeEntityInterface $authCodeEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新授权码时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储授权码，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getIdentifier(); // 获得授权码唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getExpiryDateTime(); // 获得授权码过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAuthCode</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以在此时将授权码从持久化数据库中删除</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为授权码唯一标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAuthCodeRevoked</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证授权码是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ClientEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getClientEntity</span><span class=\"params\">($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取客户端对象时调用方法，用于验证客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 ClientEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientIdentifier 客户端唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $grantType 代表授权类型，根据类型不同，验证方式也不同</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的</span></span><br><span class=\"line\">        <span class=\"comment\">// $mustValidateSecret 代表是否需要验证客户端密钥</span></span><br><span class=\"line\">        $client = <span class=\"keyword\">new</span> ClientEntity();</span><br><span class=\"line\">        $client-&gt;setIdentifier($clientIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> RefreshTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewRefreshToken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 RefreshTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RefreshTokenEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewRefreshToken</span><span class=\"params\">(RefreshTokenEntityInterface $refreshTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新刷新令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于持久化存储授刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getIdentifier(); // 获得刷新令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getExpiryDateTime(); // 获得刷新令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getAccessToken()-&gt;getIdentifier(); // 获得访问令牌标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeRefreshToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 原刷新令牌将删除，创建新的刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原刷新令牌唯一标识</span></span><br><span class=\"line\">        <span class=\"comment\">// 可在此删除原刷新令牌</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRefreshTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证刷新令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ScopeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getScopeEntityByIdentifier</span><span class=\"params\">($identifier)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证权限是否在权限范围中会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为单个权限标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功则返回 ScopeEntityInterface 对象</span></span><br><span class=\"line\">        $scope = <span class=\"keyword\">new</span> ScopeEntity();</span><br><span class=\"line\">        $scope-&gt;setIdentifier($identifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalizeScopes</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        array $scopes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $userIdentifier = null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在创建授权码与访问令牌前会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证权限范围、授权类型、客户端、用户是否匹配</span></span><br><span class=\"line\">        <span class=\"comment\">// 可整合进项目自身的权限控制中</span></span><br><span class=\"line\">        <span class=\"comment\">// 必须返回 ScopeEntityInterface 对象可用的 scope 数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例：</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope = new ScopeEntity();</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope-&gt;setIdentifier('example');</span></span><br><span class=\"line\">        <span class=\"comment\">// $scopes[] = $scope;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scopes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> UserEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserEntityByUserCredentials</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $username,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $password,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证用户时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证用户信息是否符合</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功返回 UserEntityInterface 对象</span></span><br><span class=\"line\">        $user = <span class=\"keyword\">new</span> UserEntity();</span><br><span class=\"line\">        $user-&gt;setIdentifier(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Entities\"><a href=\"#Entities\" class=\"headerlink\" title=\"Entities\"></a>Entities</h3><p>Entities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义需要实现的方法，同时提供了 <a href=\"#Traits\">Traits</a> 帮助我们实现，可以选择使用，有需要时也可以重写。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">AccessTokenTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">AuthCodeTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">ClientTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">RefreshTokenTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 没有 Trait 实现这个方法，需要自行实现</span></span><br><span class=\"line\">    <span class=\"comment\">// oauth2-server 项目的测试代码的实现例子</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonSerialize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;getIdentifier();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h3><p><strong>Repositories</strong></p>\n<ul>\n<li><p>League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php</p>\n</li>\n</ul>\n<p><strong>Entities</strong></p>\n<ul>\n<li>League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\TokenInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\UserEntityInterface.php</li>\n</ul>\n<h3 id=\"Traits\"><a href=\"#Traits\" class=\"headerlink\" title=\"Traits\"></a>Traits</h3><ul>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php</li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>oauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。</p>\n<h5 id=\"client-authentication-failed\"><a href=\"#client-authentication-failed\" class=\"headerlink\" title=\"client.authentication.failed\"></a>client.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'client.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>客户端身份验证未通过时触发此事件。你可以在客户端尝试 <code>n</code> 次失败后禁止它一段时间内的再次尝试。</p>\n<h5 id=\"user-authentication-failed\"><a href=\"#user-authentication-failed\" class=\"headerlink\" title=\"user.authentication.failed\"></a>user.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'user.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 <code>n</code> 次后禁止用户再次尝试。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>《oauth2-server 官方文档》(<a href=\"https://oauth2.thephpleague.com/\" target=\"_blank\" rel=\"noopener\">https://oauth2.thephpleague.com/</a>)</p>\n<p>《理解OAuth 2.0》-阮一峰（<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://en.wikipedia.org/wiki/OAuth\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a> 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。</p>\n<p><a href=\"https://github.com/thephpleague/oauth2-server\" target=\"_blank\" rel=\"noopener\">league/oauth2-server</a> 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。</p>\n<p>本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。</p>","more":"<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。</p>\n<p><strong>OAuth2.0 定义了四个角色</strong></p>\n<ol>\n<li><strong>Client</strong>：客户端，第三方应用程序。</li>\n<li><strong>Resource Owner</strong>：资源所有者，授权 Client 访问其帐户的用户。</li>\n<li><strong>Authorization server</strong>：授权服务器，服务商专用于处理用户授权认证的服务器。</li>\n<li><strong>Resource server</strong>：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。</li>\n</ol>\n<p><strong>oauth2-server</strong></p>\n<ol>\n<li><strong>Access token</strong>：用于访问受保护资源的令牌。</li>\n<li><strong>Authorization code</strong>：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。</li>\n<li><strong>Scope</strong>：授予应用程序的权限范围。</li>\n<li><strong>JWT</strong>：<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">Json Web Token</a> 是一种用于安全传输的数据传输格式。</li>\n</ol>\n<h2 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h2><p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg\" alt=\"flowchart.png\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>推荐使用 <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">Composer</a> 进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require league/oauth2-server</span><br></pre></td></tr></table></figure>\n<p>根据<a href=\"#授权模式\">授权模式</a>的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。</p>\n<p><em>本文发布时，版本号为7.3.1。</em></p>\n<p><strong>生成公钥与私钥</strong></p>\n<p>公钥与私钥用于签名和验证传输的 <a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">JWT</a>，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。</p>\n<p><em>oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。</em></p>\n<p>生成私钥，在终端中运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out private.key 2048</span><br></pre></td></tr></table></figure>\n<p>使用私钥提取私钥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in private.key -pubout -out public.key</span><br></pre></td></tr></table></figure>\n<p>私钥必须保密于授权服务器中，并将公钥分发给资源服务器。</p>\n<p><strong>生成加密密钥</strong></p>\n<p>加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，<code>string</code> 或 <code>defuse/php-encryption</code> 库的对象。</p>\n<p><em>加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。</em></p>\n<p>生成字符串密钥，在终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &apos;echo base64_encode(random_bytes(32)), PHP_EOL;&apos;</span><br></pre></td></tr></table></figure>\n<p>生成对象，在项目根目录的终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vendor/bin/generate-defuse-key</span><br></pre></td></tr></table></figure>\n<p>将获得的内容，传入 AuthorizationServer：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> \\<span class=\"title\">Defuse</span>\\<span class=\"title\">Crypto</span>\\<span class=\"title\">Key</span>;</span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKeyPath,</span><br><span class=\"line\">    Key::loadFromAsciiSafeString($encryptionKey) <span class=\"comment\">//传入加密密钥</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><strong>PHP版本支持</strong></p>\n<ul>\n<li>PHP 7.0</li>\n<li>PHP 7.1</li>\n<li>PHP 7.2</li>\n</ul>\n<h2 id=\"授权模式\"><a href=\"#授权模式\" class=\"headerlink\" title=\"授权模式\"></a>授权模式</h2><p>OAuth2.0 定义了四种授权模式，以应对不同情况时的授权。</p>\n<ol>\n<li>授权码模式</li>\n<li>隐式授权模式</li>\n<li>密码模式</li>\n<li>客户端模式</li>\n</ol>\n<h2 id=\"客户端类型\"><a href=\"#客户端类型\" class=\"headerlink\" title=\"客户端类型\"></a>客户端类型</h2><ul>\n<li>保密的：<ul>\n<li>客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）</li>\n</ul>\n</li>\n<li>公开的：<ul>\n<li>客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选用哪种授权模式？\"><a href=\"#选用哪种授权模式？\" class=\"headerlink\" title=\"选用哪种授权模式？\"></a>选用哪种授权模式？</h2><p>如果客户端是保密的，应使用<a href=\"#授权码模式\">授权码模式</a>。</p>\n<p>如果客户端是公开的，应使用<a href=\"#隐式授权模式\">隐式授权模式</a>。</p>\n<p>如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用<a href=\"#密码模式\">密码模式</a>。</p>\n<p>如果客户端是以自己的名义，不与用户产生关系，应使用<a href=\"#客户端模式\">客户端模式</a>。</p>\n<h2 id=\"预先注册\"><a href=\"#预先注册\" class=\"headerlink\" title=\"预先注册\"></a>预先注册</h2><p>客户端需要预先在授权服务器进行注册，用以获取 <code>client_id</code> 与 <code>client_secret</code>，也可以在注册是预先设定好 <code>redirect_uri</code>，以便于之后可以使用默认的 <code>redirect_uri</code>。</p>\n<h2 id=\"授权码模式\"><a href=\"#授权码模式\" class=\"headerlink\" title=\"授权码模式\"></a>授权码模式</h2><p>授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。</p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p><strong>第一部分（用户可见）</strong></p>\n<p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>code</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>code</code>：授权码(Authorization code)</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序</li>\n</ul>\n<p><strong>第二部分（用户不可见）</strong></p>\n<p>客户端已得到授权，通过 <code>POST</code> 请求向授权服务器获取访问令牌(access token)：</p>\n<ul>\n<li><code>grant_type</code>：授权模式，值固定为：<code>authorization_code</code></li>\n<li><code>client_id</code>：客户端ID</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>redirect_uri</code>：使用与第一部分请求相同的 URI</li>\n<li><code>code</code>：第一部分所获的的授权码，要注意URL解码</li>\n</ul>\n<p>授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：</p>\n<ul>\n<li><p><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></p>\n</li>\n<li><p><code>expires_in</code>：访问令牌的存活时间</p>\n</li>\n<li><p><code>access_token</code>：访问令牌</p>\n</li>\n<li><p><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</p>\n</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现\"><a href=\"#使用-oauth2-server-实现\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><p>OAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 <a href=\"#Interfaces\">Interfaces</a> 与 <a href=\"#Traits\">Traits</a> 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>。</p>\n<h5 id=\"初始化-server\"><a href=\"#初始化-server\" class=\"headerlink\" title=\"初始化 server\"></a>初始化 server</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化存储库</span></span><br><span class=\"line\">$clientRepository = <span class=\"keyword\">new</span> ClientRepository(); <span class=\"comment\">// Interface: ClientRepositoryInterface</span></span><br><span class=\"line\">$scopeRepository = <span class=\"keyword\">new</span> ScopeRepository(); <span class=\"comment\">// Interface: ScopeRepositoryInterface</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\">$authCodeRepository = <span class=\"keyword\">new</span> AuthCodeRepository(); <span class=\"comment\">// Interface: AuthCodeRepositoryInterface</span></span><br><span class=\"line\">$refreshTokenRepository = <span class=\"keyword\">new</span> RefreshTokenRepository(); <span class=\"comment\">// Interface: RefreshTokenRepositoryInterface</span></span><br><span class=\"line\">$userRepository = <span class=\"keyword\">new</span> UserRepository(); <span class=\"comment\">//Interface: UserRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 私钥与加密密钥</span></span><br><span class=\"line\">$privateKey = <span class=\"string\">'file://path/to/private.key'</span>;</span><br><span class=\"line\"><span class=\"comment\">//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码</span></span><br><span class=\"line\">$encryptionKey = <span class=\"string\">'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'</span>; <span class=\"comment\">// 加密密钥字符串</span></span><br><span class=\"line\"><span class=\"comment\">// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化 server</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKey,</span><br><span class=\"line\">    $encryptionKey</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h5 id=\"初始化授权码类型\"><a href=\"#初始化授权码类型\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 授权码授权类型初始化</span></span><br><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(</span><br><span class=\"line\">    $authCodeRepository,</span><br><span class=\"line\">    $refreshTokenRepository,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT10M'</span>) <span class=\"comment\">// 设置授权码过期时间为10分钟</span></span><br><span class=\"line\">);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将授权码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<p>用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：<a href=\"https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：\" target=\"_blank\" rel=\"noopener\">https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：</a></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;get(<span class=\"string\">'/authorize'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证 HTTP 请求，并返回 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = $server-&gt;validateAuthorizationRequest($request);</span><br><span class=\"line\">        <span class=\"comment\">// 此时应将 authRequest 对象序列化后存在当前会话(session)中</span></span><br><span class=\"line\">        $_SESSION[<span class=\"string\">'authRequest'</span>] = serialize($authRequest);</span><br><span class=\"line\">        <span class=\"comment\">// 然后将用户重定向至登录入口或在当前地址直接响应登录页面</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;getBody()-&gt;write(file_get_contents(<span class=\"string\">\"login.html\"</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">        // 设置用户实体(userEntity)</span><br><span class=\"line\">        $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">        // 设置权限范围</span><br><span class=\"line\">        $authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">        // true = 批准，false = 拒绝</span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">        // 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">        // 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>客户端通过授权码请求访问令牌：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式授权模式\"><a href=\"#隐式授权模式\" class=\"headerlink\" title=\"隐式授权模式\"></a>隐式授权模式</h2><p>隐式授权相当于是授权码模式的简化版本：</p>\n<h4 id=\"流程-用户可见\"><a href=\"#流程-用户可见\" class=\"headerlink\" title=\"流程(用户可见)\"></a>流程(用户可见)</h4><p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序</li>\n</ul>\n<p>整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。</p>\n<p><em>此模式下没有刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-1\"><a href=\"#使用-oauth2-server-实现-1\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-1\"><a href=\"#初始化授权码类型-1\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将隐式授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ImplicitGrant(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>)),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/login'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在会话(session)中取出 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[<span class=\"string\">'authRequest'</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 设置用户实体(userEntity)</span></span><br><span class=\"line\">        $authRequest-&gt;setUser(<span class=\"keyword\">new</span> UserEntity(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置权限范围</span></span><br><span class=\"line\">        $authRequest-&gt;setScopes([<span class=\"string\">'basic'</span>])</span><br><span class=\"line\">        <span class=\"comment\">// true = 批准，false = 拒绝</span></span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 完成后重定向至客户端请求重定向地址</span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">\t      // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">\t\t\t\t// 设置用户实体(userEntity)</span><br><span class=\"line\">\t\t    $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">\t\t\t\t// 设置权限范围</span><br><span class=\"line\">\t\t\t\t$authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">\t\t\t\t// true = 批准，false = 拒绝</span><br><span class=\"line\">\t\t    $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">\t\t\t\t// 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">    \t// 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"密码模式\"><a href=\"#密码模式\" class=\"headerlink\" title=\"密码模式\"></a>密码模式</h2><p>密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。</p>\n<p><em>OAuth2 协议规定此模式不需要传 <code>client_id</code> &amp; <code>client_secret</code>，但 oauth-server 库需要</em></p>\n<h4 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端要求用户提供授权凭据，通常是账号密码</p>\n<p>然后，客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>password</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>username</code>：用户账号</li>\n<li><code>password</code>：用户密码</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-2\"><a href=\"#使用-oauth2-server-实现-2\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-2\"><a href=\"#初始化授权码类型-2\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\PasswordGrant(</span><br><span class=\"line\">     $userRepository,</span><br><span class=\"line\">     $refreshTokenRepository</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将密码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端模式\"><a href=\"#客户端模式\" class=\"headerlink\" title=\"客户端模式\"></a>客户端模式</h2><p>客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。</p>\n<h4 id=\"流程-2\"><a href=\"#流程-2\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>client_credentials</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n</ul>\n<p><em>此模式下无需刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-3\"><a href=\"#使用-oauth2-server-实现-3\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-3\"><a href=\"#初始化授权码类型-3\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将客户端授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新访问令牌-access-token\"><a href=\"#刷新访问令牌-access-token\" class=\"headerlink\" title=\"刷新访问令牌(access token)\"></a>刷新访问令牌(access token)</h2><p>访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。</p>\n<h4 id=\"流程-3\"><a href=\"#流程-3\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>refresh_token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>refresh_token</code>：刷新令牌</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-4\"><a href=\"#使用-oauth2-server-实现-4\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-4\"><a href=\"#初始化授权码类型-4\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 新的刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将刷新访问令牌添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 新的访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"资源服务器验证访问令牌\"><a href=\"#资源服务器验证访问令牌\" class=\"headerlink\" title=\"资源服务器验证访问令牌\"></a>资源服务器验证访问令牌</h2><p>oauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。</p>\n<p>客户端需要在 <code>HTTP Header</code> 中使用 <code>Authorization</code> 传入访问令牌，如果通过，中间件将会在 <code>request</code> 中加入对应数据：</p>\n<ul>\n<li><code>oauth_access_token_id</code>：访问令牌 id</li>\n<li><code>oauth_client_id</code>: 客户端id</li>\n<li><code>oauth_user_id</code>：用户id</li>\n<li><code>oauth_scopes</code>：权限范围</li>\n</ul>\n<p>授权不通过，则抛出 <code>OAuthServerException::accessDenied</code> 异常。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 授权服务器分发的公钥</span></span><br><span class=\"line\">$publicKeyPath = <span class=\"string\">'file://path/to/public.key'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// 创建 ResourceServer</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\ResourceServer(</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $publicKeyPath</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中间件</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);</span><br></pre></td></tr></table></figure>\n<p>如果所用路由不支持中间件，可自行实现，符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可 ：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t$request = $server-&gt;validateAuthenticatedRequest($request);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> OAuthServerException($exception-&gt;getMessage(), <span class=\"number\">0</span>, <span class=\"string\">'unknown_error'</span>, <span class=\"number\">500</span>))-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"oauth2-server-实现\"><a href=\"#oauth2-server-实现\" class=\"headerlink\" title=\"oauth2-server 实现\"></a>oauth2-server 实现</h2><p>oauth2-server 的实现需要我们手动创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>，下面展示一个项目目录示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Entities</span><br><span class=\"line\">\t- AccessTokenEntity.php</span><br><span class=\"line\">\t- AuthCodeEntity.php</span><br><span class=\"line\">\t- ClientEntity.php</span><br><span class=\"line\">\t- RefreshTokenEntity.php</span><br><span class=\"line\">\t- ScopeEntity.php</span><br><span class=\"line\">\t- UserEntity.php</span><br><span class=\"line\">- Repositories</span><br><span class=\"line\">\t- AccessTokenRepository.php</span><br><span class=\"line\">\t- AuthCodeRepository.php</span><br><span class=\"line\">\t- ClientRepository.php</span><br><span class=\"line\">\t- RefreshTokenRepository.php</span><br><span class=\"line\">\t- ScopeRepository.php</span><br><span class=\"line\">\t- UserRepository.php</span><br></pre></td></tr></table></figure>\n<h3 id=\"Repositories\"><a href=\"#Repositories\" class=\"headerlink\" title=\"Repositories\"></a>Repositories</h3><p>Repositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义所需要实现的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AccessTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewToken</span><span class=\"params\">(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新访问令牌时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AccessTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要在返回前，向 AccessTokenEntity 传入参数中对应属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例代码：</span></span><br><span class=\"line\">        $accessToken = <span class=\"keyword\">new</span> AccessTokenEntity();</span><br><span class=\"line\">        $accessToken-&gt;setClient($clientEntity);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> ($scopes <span class=\"keyword\">as</span> $scope) &#123;</span><br><span class=\"line\">            $accessToken-&gt;addScope($scope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $accessToken-&gt;setUserIdentifier($userIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $accessToken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAccessToken</span><span class=\"params\">(AccessTokenEntityInterface $accessTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储访问令牌，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getIdentifier(); // 获得令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getExpiryDateTime(); // 获得令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAccessToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用刷新令牌创建新的访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原访问令牌的唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// 可将其在持久化存储中过期</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAccessTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源服务器验证访问令牌时将调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证访问令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AuthCodeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewAuthCode</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AuthCodeEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AuthCodeEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAuthCode</span><span class=\"params\">(AuthCodeEntityInterface $authCodeEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新授权码时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储授权码，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getIdentifier(); // 获得授权码唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getExpiryDateTime(); // 获得授权码过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAuthCode</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以在此时将授权码从持久化数据库中删除</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为授权码唯一标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAuthCodeRevoked</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证授权码是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ClientEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getClientEntity</span><span class=\"params\">($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取客户端对象时调用方法，用于验证客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 ClientEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientIdentifier 客户端唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $grantType 代表授权类型，根据类型不同，验证方式也不同</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的</span></span><br><span class=\"line\">        <span class=\"comment\">// $mustValidateSecret 代表是否需要验证客户端密钥</span></span><br><span class=\"line\">        $client = <span class=\"keyword\">new</span> ClientEntity();</span><br><span class=\"line\">        $client-&gt;setIdentifier($clientIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> RefreshTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewRefreshToken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 RefreshTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RefreshTokenEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewRefreshToken</span><span class=\"params\">(RefreshTokenEntityInterface $refreshTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新刷新令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于持久化存储授刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getIdentifier(); // 获得刷新令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getExpiryDateTime(); // 获得刷新令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getAccessToken()-&gt;getIdentifier(); // 获得访问令牌标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeRefreshToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 原刷新令牌将删除，创建新的刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原刷新令牌唯一标识</span></span><br><span class=\"line\">        <span class=\"comment\">// 可在此删除原刷新令牌</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRefreshTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证刷新令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ScopeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getScopeEntityByIdentifier</span><span class=\"params\">($identifier)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证权限是否在权限范围中会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为单个权限标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功则返回 ScopeEntityInterface 对象</span></span><br><span class=\"line\">        $scope = <span class=\"keyword\">new</span> ScopeEntity();</span><br><span class=\"line\">        $scope-&gt;setIdentifier($identifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalizeScopes</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        array $scopes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $userIdentifier = null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在创建授权码与访问令牌前会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证权限范围、授权类型、客户端、用户是否匹配</span></span><br><span class=\"line\">        <span class=\"comment\">// 可整合进项目自身的权限控制中</span></span><br><span class=\"line\">        <span class=\"comment\">// 必须返回 ScopeEntityInterface 对象可用的 scope 数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例：</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope = new ScopeEntity();</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope-&gt;setIdentifier('example');</span></span><br><span class=\"line\">        <span class=\"comment\">// $scopes[] = $scope;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scopes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> UserEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserEntityByUserCredentials</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $username,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $password,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证用户时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证用户信息是否符合</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功返回 UserEntityInterface 对象</span></span><br><span class=\"line\">        $user = <span class=\"keyword\">new</span> UserEntity();</span><br><span class=\"line\">        $user-&gt;setIdentifier(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Entities\"><a href=\"#Entities\" class=\"headerlink\" title=\"Entities\"></a>Entities</h3><p>Entities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义需要实现的方法，同时提供了 <a href=\"#Traits\">Traits</a> 帮助我们实现，可以选择使用，有需要时也可以重写。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">AccessTokenTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">AuthCodeTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">ClientTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">RefreshTokenTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 没有 Trait 实现这个方法，需要自行实现</span></span><br><span class=\"line\">    <span class=\"comment\">// oauth2-server 项目的测试代码的实现例子</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonSerialize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;getIdentifier();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h3><p><strong>Repositories</strong></p>\n<ul>\n<li><p>League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php</p>\n</li>\n</ul>\n<p><strong>Entities</strong></p>\n<ul>\n<li>League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\TokenInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\UserEntityInterface.php</li>\n</ul>\n<h3 id=\"Traits\"><a href=\"#Traits\" class=\"headerlink\" title=\"Traits\"></a>Traits</h3><ul>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php</li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>oauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。</p>\n<h5 id=\"client-authentication-failed\"><a href=\"#client-authentication-failed\" class=\"headerlink\" title=\"client.authentication.failed\"></a>client.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'client.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>客户端身份验证未通过时触发此事件。你可以在客户端尝试 <code>n</code> 次失败后禁止它一段时间内的再次尝试。</p>\n<h5 id=\"user-authentication-failed\"><a href=\"#user-authentication-failed\" class=\"headerlink\" title=\"user.authentication.failed\"></a>user.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'user.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 <code>n</code> 次后禁止用户再次尝试。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>《oauth2-server 官方文档》(<a href=\"https://oauth2.thephpleague.com/\" target=\"_blank\" rel=\"noopener\">https://oauth2.thephpleague.com/</a>)</p>\n<p>《理解OAuth 2.0》-阮一峰（<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）</a></p>"},{"title":"RESTful缓存方案","date":"2016-09-10T11:18:17.000Z","_content":"\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","source":"_posts/RESTful-cache.md","raw":"---\ntitle: RESTful缓存方案\ndate: 2016/9/10 19:18:17\n---\n\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","slug":"RESTful-cache","published":1,"updated":"2020-07-23T00:29:18.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea5000ecyzeu85xbohh","content":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>\n<a id=\"more\"></a>  \n<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">资源无更新示例:</span><br><span class=\"line\">304 Not Modified</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\"></span><br><span class=\"line\">资源有更新示例:</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;ooooooooooooo&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>\n","site":{"data":{}},"excerpt":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>","more":"<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">资源无更新示例:</span><br><span class=\"line\">304 Not Modified</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\"></span><br><span class=\"line\">资源有更新示例:</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;ooooooooooooo&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>"},{"title":"Vue 学习路线","date":"2019-04-10T13:20:19.000Z","_content":"\n## 前言\n\n本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。\n\n<!--more-->  \n\n## 为什么选择vue\n\n可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。\n\n* Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。\n* 相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。\n\n* 渐进式框架也可以更好的逐步的改变原有项目。\n* 团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。\n\n## 学习路线\n\n0. ### JavaScript与web基础\n\n   学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。\n\n1. ### Vue 基本概念\n\n   使用 Vue 来构建项目，需要先了解一些基本概念：\n\n   **渐进式框架**\n\n   渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。\n\n   在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。\n\n   Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。\n\n   **声明式渲染**\n\n   ```HTML\n   <div id=\"app\">\n     {{ message }}\n   </div>\n   ```\n\n   ```javascript\n   var app = new Vue({\n     el: '#app',\n     data: {\n       message: 'Hello Vue!'\n     }\n   })\n   ```\n\n   这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。\n\n   **响应式数据**\n\n   在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 `app.message` 的值，就可以看到页面也会发生对应改变。\n\n   **组件化**\n\n   组件化的核心思想就是：将页面结构映射为组件树。\n\n   ![component-tree.png](https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480)\n\n   组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。\n\n   **单页面应用与客户端路由**\n\n   单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。\n\n   Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。\n\n   **状态管理**\n\n   在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。\n\n   这就是 Vuex 所做的事情。\n\n2. ### 使用 Vue 构建单页面应用\n\n   以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。\n\n   **构建工具**\n\n   Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。\n\n   最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。\n\n   **使用 axios 访问 Web API**\n\n   Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。\n\n   作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。\n\n   如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。\n\n   **测试**\n\n   如果想要开发出稳定可维护的项目，测试是必不可少的。\n\n   Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。\n\n   **Chrome 开发者工具**\n\n   Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。\n\n   **多端支持**\n\n   可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。\n\n3. ### 前端技术栈\n\n   上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。\n\n   **现代 JavaScript 与 Babel**\n\n   Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。\n\n   如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。\n\n   **Webpack**\n\n   Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。\n\n   虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。\n\n   **TypeScript 与 Flow**\n\n   Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。\n\n   这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。\n\n   Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。\n\n4. ### Vue 生态系统\n\n   **官方核心插件**\n\n   上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。\n\n   **官方工具**\n\n   上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。\n\n   **UI 组件库**\n\n   也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。\n\n   市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。\n\n5. ### 深入理解 Vue\n\n   **为什么是渐进式框架**\n\n   *框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》*\n\n   当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。\n\n   但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。\n\n   React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。\n\n   Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。\n\n   Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。\n\n   **声明式渲染**\n\n   Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。\n\n   那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。\n\n   虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。\n\n   Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。\n\n   当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。\n\n   不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。\n\n   **状态管理**\n\n   状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。\n\n   ![state-单向数据流.png](https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c)\n\n   在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。\n\n   它将组件的共享状态抽离出来，放入 Store，组件通过调度（`dispatch`）使用 Action，Action 通过提交（`commit`）Mutation 修改 State，然后响应到组件。\n\n   ![vuex.png](https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d)\n\n6. ### 实现原理\n\n   **生命周期**\n\n   ![lifecycle.png](https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4)\n\n   **Virtual DOM**\n\n   Virtual DOM 在 Vue 中的实现。\n\n   **响应式数据原理**\n\n   在 Vue2，使用的是 ES5 的 `Object.defineProperty` 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。\n\n   在即将到来的 Vue3 中，会使用 `Proxy` 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。\n\n   **编译与渲染函数**\n\n   在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。\n\n   **组件化**\n\n   每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。\n\n   **v-model**\n\n   Vue 提供了 `v-model` 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。\n\n   ```html\n   <input v-model=\"sth\" />\n   <input v-bind:value=\"sth\" v-on:input=\"sth = $event.target.value\" />\n   ```\n\n   **核心插件**\n\n   Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。\n\n   Vuex：初始化过程，如何管理全局状态等。\n\n## 思维导图\n\n![Vue 学习路线.png](https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6)\n\n## 相关学习资料\n\n[《Vue 2.0——渐进式前端解决方案》](https://www.infoq.cn/article/vue-2-progressive-front-end-solution) 尤雨溪\n\n[《Vue Guide》](https://cn.vuejs.org/v2/guide/) Vue 官方团队\n\n[《Vue.js 技术揭秘》](https://ustbhuangyi.github.io/vue-analysis/) ustbhuangyi\n\n[《Vuex》](https://vuex.vuejs.org/zh/) Vuex\n\n[VueConf](https://vue.w3ctech.com/) VueConf\n\n[Vue.js developers](https://vuejsdevelopers.com/) vuejsdevelopers.com\n\n## 参考文章\n\n[《2019 年 Vue 学习路线图》](https://www.infoq.cn/article/9XymmTqu*4QwahqikMka)","source":"_posts/Vue-learning-route.md","raw":"---\ntitle: Vue 学习路线\ndate: 2019/04/10 21:20:19\n---\n\n## 前言\n\n本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。\n\n<!--more-->  \n\n## 为什么选择vue\n\n可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。\n\n* Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。\n* 相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。\n\n* 渐进式框架也可以更好的逐步的改变原有项目。\n* 团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。\n\n## 学习路线\n\n0. ### JavaScript与web基础\n\n   学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。\n\n1. ### Vue 基本概念\n\n   使用 Vue 来构建项目，需要先了解一些基本概念：\n\n   **渐进式框架**\n\n   渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。\n\n   在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。\n\n   Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。\n\n   **声明式渲染**\n\n   ```HTML\n   <div id=\"app\">\n     {{ message }}\n   </div>\n   ```\n\n   ```javascript\n   var app = new Vue({\n     el: '#app',\n     data: {\n       message: 'Hello Vue!'\n     }\n   })\n   ```\n\n   这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。\n\n   **响应式数据**\n\n   在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 `app.message` 的值，就可以看到页面也会发生对应改变。\n\n   **组件化**\n\n   组件化的核心思想就是：将页面结构映射为组件树。\n\n   ![component-tree.png](https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480)\n\n   组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。\n\n   **单页面应用与客户端路由**\n\n   单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。\n\n   Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。\n\n   **状态管理**\n\n   在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。\n\n   这就是 Vuex 所做的事情。\n\n2. ### 使用 Vue 构建单页面应用\n\n   以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。\n\n   **构建工具**\n\n   Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。\n\n   最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。\n\n   **使用 axios 访问 Web API**\n\n   Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。\n\n   作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。\n\n   如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。\n\n   **测试**\n\n   如果想要开发出稳定可维护的项目，测试是必不可少的。\n\n   Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。\n\n   **Chrome 开发者工具**\n\n   Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。\n\n   **多端支持**\n\n   可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。\n\n3. ### 前端技术栈\n\n   上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。\n\n   **现代 JavaScript 与 Babel**\n\n   Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。\n\n   如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。\n\n   **Webpack**\n\n   Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。\n\n   虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。\n\n   **TypeScript 与 Flow**\n\n   Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。\n\n   这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。\n\n   Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。\n\n4. ### Vue 生态系统\n\n   **官方核心插件**\n\n   上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。\n\n   **官方工具**\n\n   上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。\n\n   **UI 组件库**\n\n   也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。\n\n   市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。\n\n5. ### 深入理解 Vue\n\n   **为什么是渐进式框架**\n\n   *框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》*\n\n   当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。\n\n   但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。\n\n   React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。\n\n   Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。\n\n   Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。\n\n   **声明式渲染**\n\n   Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。\n\n   那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。\n\n   虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。\n\n   Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。\n\n   当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。\n\n   不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。\n\n   **状态管理**\n\n   状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。\n\n   ![state-单向数据流.png](https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c)\n\n   在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。\n\n   它将组件的共享状态抽离出来，放入 Store，组件通过调度（`dispatch`）使用 Action，Action 通过提交（`commit`）Mutation 修改 State，然后响应到组件。\n\n   ![vuex.png](https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d)\n\n6. ### 实现原理\n\n   **生命周期**\n\n   ![lifecycle.png](https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4)\n\n   **Virtual DOM**\n\n   Virtual DOM 在 Vue 中的实现。\n\n   **响应式数据原理**\n\n   在 Vue2，使用的是 ES5 的 `Object.defineProperty` 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。\n\n   在即将到来的 Vue3 中，会使用 `Proxy` 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。\n\n   **编译与渲染函数**\n\n   在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。\n\n   **组件化**\n\n   每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。\n\n   **v-model**\n\n   Vue 提供了 `v-model` 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。\n\n   ```html\n   <input v-model=\"sth\" />\n   <input v-bind:value=\"sth\" v-on:input=\"sth = $event.target.value\" />\n   ```\n\n   **核心插件**\n\n   Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。\n\n   Vuex：初始化过程，如何管理全局状态等。\n\n## 思维导图\n\n![Vue 学习路线.png](https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6)\n\n## 相关学习资料\n\n[《Vue 2.0——渐进式前端解决方案》](https://www.infoq.cn/article/vue-2-progressive-front-end-solution) 尤雨溪\n\n[《Vue Guide》](https://cn.vuejs.org/v2/guide/) Vue 官方团队\n\n[《Vue.js 技术揭秘》](https://ustbhuangyi.github.io/vue-analysis/) ustbhuangyi\n\n[《Vuex》](https://vuex.vuejs.org/zh/) Vuex\n\n[VueConf](https://vue.w3ctech.com/) VueConf\n\n[Vue.js developers](https://vuejsdevelopers.com/) vuejsdevelopers.com\n\n## 参考文章\n\n[《2019 年 Vue 学习路线图》](https://www.infoq.cn/article/9XymmTqu*4QwahqikMka)","slug":"Vue-learning-route","published":1,"updated":"2020-07-23T00:29:18.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea6000fcyzeaconor0f","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。</p>\n<a id=\"more\"></a>  \n<h2 id=\"为什么选择vue\"><a href=\"#为什么选择vue\" class=\"headerlink\" title=\"为什么选择vue\"></a>为什么选择vue</h2><p>可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。</p>\n<ul>\n<li>Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。</li>\n<li><p>相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。</p>\n</li>\n<li><p>渐进式框架也可以更好的逐步的改变原有项目。</p>\n</li>\n<li>团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。</li>\n</ul>\n<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><ol>\n<li><h3 id=\"JavaScript与web基础\"><a href=\"#JavaScript与web基础\" class=\"headerlink\" title=\"JavaScript与web基础\"></a>JavaScript与web基础</h3><p>学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。</p>\n</li>\n<li><h3 id=\"Vue-基本概念\"><a href=\"#Vue-基本概念\" class=\"headerlink\" title=\"Vue 基本概念\"></a>Vue 基本概念</h3><p>使用 Vue 来构建项目，需要先了解一些基本概念：</p>\n<p><strong>渐进式框架</strong></p>\n<p>渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。</p>\n<p>在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。</p>\n<p>Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。</p>\n<p><strong>声明式渲染</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123; message &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。</p>\n<p><strong>响应式数据</strong></p>\n<p>在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 <code>app.message</code> 的值，就可以看到页面也会发生对应改变。</p>\n<p><strong>组件化</strong></p>\n<p>组件化的核心思想就是：将页面结构映射为组件树。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480\" alt=\"component-tree.png\"></p>\n<p>组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。</p>\n<p><strong>单页面应用与客户端路由</strong></p>\n<p>单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。</p>\n<p>Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。</p>\n<p><strong>状态管理</strong></p>\n<p>在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。</p>\n<p>这就是 Vuex 所做的事情。</p>\n</li>\n<li><h3 id=\"使用-Vue-构建单页面应用\"><a href=\"#使用-Vue-构建单页面应用\" class=\"headerlink\" title=\"使用 Vue 构建单页面应用\"></a>使用 Vue 构建单页面应用</h3><p>以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。</p>\n<p><strong>构建工具</strong></p>\n<p>Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。</p>\n<p>最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。</p>\n<p><strong>使用 axios 访问 Web API</strong></p>\n<p>Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。</p>\n<p>作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。</p>\n<p>如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。</p>\n<p><strong>测试</strong></p>\n<p>如果想要开发出稳定可维护的项目，测试是必不可少的。</p>\n<p>Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。</p>\n<p><strong>Chrome 开发者工具</strong></p>\n<p>Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。</p>\n<p><strong>多端支持</strong></p>\n<p>可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。</p>\n</li>\n<li><h3 id=\"前端技术栈\"><a href=\"#前端技术栈\" class=\"headerlink\" title=\"前端技术栈\"></a>前端技术栈</h3><p>上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。</p>\n<p><strong>现代 JavaScript 与 Babel</strong></p>\n<p>Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。</p>\n<p>如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。</p>\n<p><strong>Webpack</strong></p>\n<p>Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。</p>\n<p>虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。</p>\n<p><strong>TypeScript 与 Flow</strong></p>\n<p>Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。</p>\n<p>这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。</p>\n<p>Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。</p>\n</li>\n<li><h3 id=\"Vue-生态系统\"><a href=\"#Vue-生态系统\" class=\"headerlink\" title=\"Vue 生态系统\"></a>Vue 生态系统</h3><p><strong>官方核心插件</strong></p>\n<p>上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。</p>\n<p><strong>官方工具</strong></p>\n<p>上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。</p>\n<p><strong>UI 组件库</strong></p>\n<p>也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。</p>\n<p>市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。</p>\n</li>\n<li><h3 id=\"深入理解-Vue\"><a href=\"#深入理解-Vue\" class=\"headerlink\" title=\"深入理解 Vue\"></a>深入理解 Vue</h3><p><strong>为什么是渐进式框架</strong></p>\n<p><em>框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》</em></p>\n<p>当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。</p>\n<p>但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。</p>\n<p>React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。</p>\n<p>Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。</p>\n<p>Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。</p>\n<p><strong>声明式渲染</strong></p>\n<p>Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。</p>\n<p>那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。</p>\n<p>虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。</p>\n<p>Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。</p>\n<p>当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。</p>\n<p>不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。</p>\n<p><strong>状态管理</strong></p>\n<p>状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c\" alt=\"state-单向数据流.png\"></p>\n<p>在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。</p>\n<p>它将组件的共享状态抽离出来，放入 Store，组件通过调度（<code>dispatch</code>）使用 Action，Action 通过提交（<code>commit</code>）Mutation 修改 State，然后响应到组件。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d\" alt=\"vuex.png\"></p>\n</li>\n<li><h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><strong>生命周期</strong></p>\n<p><img src=\"https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4\" alt=\"lifecycle.png\"></p>\n<p><strong>Virtual DOM</strong></p>\n<p>Virtual DOM 在 Vue 中的实现。</p>\n<p><strong>响应式数据原理</strong></p>\n<p>在 Vue2，使用的是 ES5 的 <code>Object.defineProperty</code> 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。</p>\n<p>在即将到来的 Vue3 中，会使用 <code>Proxy</code> 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。</p>\n<p><strong>编译与渲染函数</strong></p>\n<p>在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。</p>\n<p><strong>组件化</strong></p>\n<p>每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。</p>\n<p><strong>v-model</strong></p>\n<p>Vue 提供了 <code>v-model</code> 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"sth\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"sth\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"sth = $event.target.value\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>核心插件</strong></p>\n<p>Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。</p>\n<p>Vuex：初始化过程，如何管理全局状态等。</p>\n</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><img src=\"https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6\" alt=\"Vue 学习路线.png\"></p>\n<h2 id=\"相关学习资料\"><a href=\"#相关学习资料\" class=\"headerlink\" title=\"相关学习资料\"></a>相关学习资料</h2><p><a href=\"https://www.infoq.cn/article/vue-2-progressive-front-end-solution\" target=\"_blank\" rel=\"noopener\">《Vue 2.0——渐进式前端解决方案》</a> 尤雨溪</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">《Vue Guide》</a> Vue 官方团队</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/\" target=\"_blank\" rel=\"noopener\">《Vue.js 技术揭秘》</a> ustbhuangyi</p>\n<p><a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">《Vuex》</a> Vuex</p>\n<p><a href=\"https://vue.w3ctech.com/\" target=\"_blank\" rel=\"noopener\">VueConf</a> VueConf</p>\n<p><a href=\"https://vuejsdevelopers.com/\" target=\"_blank\" rel=\"noopener\">Vue.js developers</a> vuejsdevelopers.com</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.infoq.cn/article/9XymmTqu*4QwahqikMka\" target=\"_blank\" rel=\"noopener\">《2019 年 Vue 学习路线图》</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。</p>","more":"<h2 id=\"为什么选择vue\"><a href=\"#为什么选择vue\" class=\"headerlink\" title=\"为什么选择vue\"></a>为什么选择vue</h2><p>可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。</p>\n<ul>\n<li>Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。</li>\n<li><p>相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。</p>\n</li>\n<li><p>渐进式框架也可以更好的逐步的改变原有项目。</p>\n</li>\n<li>团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。</li>\n</ul>\n<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><ol>\n<li><h3 id=\"JavaScript与web基础\"><a href=\"#JavaScript与web基础\" class=\"headerlink\" title=\"JavaScript与web基础\"></a>JavaScript与web基础</h3><p>学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。</p>\n</li>\n<li><h3 id=\"Vue-基本概念\"><a href=\"#Vue-基本概念\" class=\"headerlink\" title=\"Vue 基本概念\"></a>Vue 基本概念</h3><p>使用 Vue 来构建项目，需要先了解一些基本概念：</p>\n<p><strong>渐进式框架</strong></p>\n<p>渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。</p>\n<p>在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。</p>\n<p>Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。</p>\n<p><strong>声明式渲染</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123; message &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。</p>\n<p><strong>响应式数据</strong></p>\n<p>在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 <code>app.message</code> 的值，就可以看到页面也会发生对应改变。</p>\n<p><strong>组件化</strong></p>\n<p>组件化的核心思想就是：将页面结构映射为组件树。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480\" alt=\"component-tree.png\"></p>\n<p>组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。</p>\n<p><strong>单页面应用与客户端路由</strong></p>\n<p>单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。</p>\n<p>Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。</p>\n<p><strong>状态管理</strong></p>\n<p>在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。</p>\n<p>这就是 Vuex 所做的事情。</p>\n</li>\n<li><h3 id=\"使用-Vue-构建单页面应用\"><a href=\"#使用-Vue-构建单页面应用\" class=\"headerlink\" title=\"使用 Vue 构建单页面应用\"></a>使用 Vue 构建单页面应用</h3><p>以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。</p>\n<p><strong>构建工具</strong></p>\n<p>Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。</p>\n<p>最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。</p>\n<p><strong>使用 axios 访问 Web API</strong></p>\n<p>Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。</p>\n<p>作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。</p>\n<p>如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。</p>\n<p><strong>测试</strong></p>\n<p>如果想要开发出稳定可维护的项目，测试是必不可少的。</p>\n<p>Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。</p>\n<p><strong>Chrome 开发者工具</strong></p>\n<p>Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。</p>\n<p><strong>多端支持</strong></p>\n<p>可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。</p>\n</li>\n<li><h3 id=\"前端技术栈\"><a href=\"#前端技术栈\" class=\"headerlink\" title=\"前端技术栈\"></a>前端技术栈</h3><p>上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。</p>\n<p><strong>现代 JavaScript 与 Babel</strong></p>\n<p>Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。</p>\n<p>如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。</p>\n<p><strong>Webpack</strong></p>\n<p>Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。</p>\n<p>虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。</p>\n<p><strong>TypeScript 与 Flow</strong></p>\n<p>Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。</p>\n<p>这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。</p>\n<p>Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。</p>\n</li>\n<li><h3 id=\"Vue-生态系统\"><a href=\"#Vue-生态系统\" class=\"headerlink\" title=\"Vue 生态系统\"></a>Vue 生态系统</h3><p><strong>官方核心插件</strong></p>\n<p>上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。</p>\n<p><strong>官方工具</strong></p>\n<p>上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。</p>\n<p><strong>UI 组件库</strong></p>\n<p>也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。</p>\n<p>市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。</p>\n</li>\n<li><h3 id=\"深入理解-Vue\"><a href=\"#深入理解-Vue\" class=\"headerlink\" title=\"深入理解 Vue\"></a>深入理解 Vue</h3><p><strong>为什么是渐进式框架</strong></p>\n<p><em>框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》</em></p>\n<p>当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。</p>\n<p>但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。</p>\n<p>React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。</p>\n<p>Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。</p>\n<p>Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。</p>\n<p><strong>声明式渲染</strong></p>\n<p>Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。</p>\n<p>那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。</p>\n<p>虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。</p>\n<p>Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。</p>\n<p>当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。</p>\n<p>不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。</p>\n<p><strong>状态管理</strong></p>\n<p>状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c\" alt=\"state-单向数据流.png\"></p>\n<p>在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。</p>\n<p>它将组件的共享状态抽离出来，放入 Store，组件通过调度（<code>dispatch</code>）使用 Action，Action 通过提交（<code>commit</code>）Mutation 修改 State，然后响应到组件。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d\" alt=\"vuex.png\"></p>\n</li>\n<li><h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><strong>生命周期</strong></p>\n<p><img src=\"https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4\" alt=\"lifecycle.png\"></p>\n<p><strong>Virtual DOM</strong></p>\n<p>Virtual DOM 在 Vue 中的实现。</p>\n<p><strong>响应式数据原理</strong></p>\n<p>在 Vue2，使用的是 ES5 的 <code>Object.defineProperty</code> 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。</p>\n<p>在即将到来的 Vue3 中，会使用 <code>Proxy</code> 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。</p>\n<p><strong>编译与渲染函数</strong></p>\n<p>在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。</p>\n<p><strong>组件化</strong></p>\n<p>每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。</p>\n<p><strong>v-model</strong></p>\n<p>Vue 提供了 <code>v-model</code> 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"sth\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"sth\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"sth = $event.target.value\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>核心插件</strong></p>\n<p>Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。</p>\n<p>Vuex：初始化过程，如何管理全局状态等。</p>\n</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><img src=\"https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6\" alt=\"Vue 学习路线.png\"></p>\n<h2 id=\"相关学习资料\"><a href=\"#相关学习资料\" class=\"headerlink\" title=\"相关学习资料\"></a>相关学习资料</h2><p><a href=\"https://www.infoq.cn/article/vue-2-progressive-front-end-solution\" target=\"_blank\" rel=\"noopener\">《Vue 2.0——渐进式前端解决方案》</a> 尤雨溪</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">《Vue Guide》</a> Vue 官方团队</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/\" target=\"_blank\" rel=\"noopener\">《Vue.js 技术揭秘》</a> ustbhuangyi</p>\n<p><a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">《Vuex》</a> Vuex</p>\n<p><a href=\"https://vue.w3ctech.com/\" target=\"_blank\" rel=\"noopener\">VueConf</a> VueConf</p>\n<p><a href=\"https://vuejsdevelopers.com/\" target=\"_blank\" rel=\"noopener\">Vue.js developers</a> vuejsdevelopers.com</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.infoq.cn/article/9XymmTqu*4QwahqikMka\" target=\"_blank\" rel=\"noopener\">《2019 年 Vue 学习路线图》</a></p>"},{"title":"超媒体驱动的 Web API","date":"2017-04-20T11:18:17.000Z","_content":"\n**REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。**\n\n<!--more-->  \n\n### 超媒体的重要性\n\n超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。\n\n> Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。\n\n这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 **互联网规模（Internet-scale）** 的 **分布式** **超媒体** 系统的需求来进行分析。\n\n**超媒体是 REST 的基点之一。**\n\n### WEB API 中的超媒体\n\n超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《[REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。\n\n**关于超媒体与超文本，以下是Fielding博士在评论中的回复**\n\n> When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.\n\n### 超媒体的作用\n\n论文中给出的正式的超媒体的定义：\n\n> 超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。\n\n**超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力**。举个例子，HTML 的 <a> 标签：\n\n```\n<a href=\"http://www.baidu.com/\">点击我将跳转至百度</a>\n```\n\n这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\n```\n\n这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。\n\n> 超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。\n\n以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。\n\n> 通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。\n\n### Web API 存在的问题\n\n* Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。\n\n* 要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。\n\n* Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。\n\n### 解决方案\n\n目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。\n\n### 困惑-Web API的发展方向\n\n目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？\n\n### 总结\n\n嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。\n","source":"_posts/hypertext-driven.md","raw":"---\ntitle: 超媒体驱动的 Web API\ndate: 2017/4/20 19:18:17\n---\n\n**REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。**\n\n<!--more-->  \n\n### 超媒体的重要性\n\n超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。\n\n> Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。\n\n这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 **互联网规模（Internet-scale）** 的 **分布式** **超媒体** 系统的需求来进行分析。\n\n**超媒体是 REST 的基点之一。**\n\n### WEB API 中的超媒体\n\n超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《[REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。\n\n**关于超媒体与超文本，以下是Fielding博士在评论中的回复**\n\n> When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.\n\n### 超媒体的作用\n\n论文中给出的正式的超媒体的定义：\n\n> 超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。\n\n**超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力**。举个例子，HTML 的 <a> 标签：\n\n```\n<a href=\"http://www.baidu.com/\">点击我将跳转至百度</a>\n```\n\n这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\n```\n\n这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。\n\n> 超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。\n\n以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。\n\n> 通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。\n\n### Web API 存在的问题\n\n* Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。\n\n* 要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。\n\n* Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。\n\n### 解决方案\n\n目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。\n\n### 困惑-Web API的发展方向\n\n目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？\n\n### 总结\n\n嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。\n","slug":"hypertext-driven","published":1,"updated":"2020-07-23T00:29:18.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea8000gcyzebunc3486","content":"<p><strong>REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。</strong></p>\n<a id=\"more\"></a>  \n<h3 id=\"超媒体的重要性\"><a href=\"#超媒体的重要性\" class=\"headerlink\" title=\"超媒体的重要性\"></a>超媒体的重要性</h3><p>超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。</p>\n<blockquote>\n<p>Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。</p>\n</blockquote>\n<p>这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 <strong>互联网规模（Internet-scale）</strong> 的 <strong>分布式</strong> <strong>超媒体</strong> 系统的需求来进行分析。</p>\n<p><strong>超媒体是 REST 的基点之一。</strong></p>\n<h3 id=\"WEB-API-中的超媒体\"><a href=\"#WEB-API-中的超媒体\" class=\"headerlink\" title=\"WEB API 中的超媒体\"></a>WEB API 中的超媒体</h3><p>超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《<a href=\"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\" target=\"_blank\" rel=\"noopener\">REST APIs must be hypertext-driven</a>》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。</p>\n<p><strong>关于超媒体与超文本，以下是Fielding博士在评论中的回复</strong></p>\n<blockquote>\n<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.</p>\n</blockquote>\n<h3 id=\"超媒体的作用\"><a href=\"#超媒体的作用\" class=\"headerlink\" title=\"超媒体的作用\"></a>超媒体的作用</h3><p>论文中给出的正式的超媒体的定义：</p>\n<blockquote>\n<p>超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。</p>\n</blockquote>\n<p><strong>超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力</strong>。举个例子，HTML 的 <a> 标签：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;点击我将跳转至百度&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br></pre></td></tr></table></figure>\n<p>这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。</p>\n<blockquote>\n<p>超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。</p>\n</blockquote>\n<p>以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。</p>\n<blockquote>\n<p>通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。</p>\n</blockquote>\n<h3 id=\"Web-API-存在的问题\"><a href=\"#Web-API-存在的问题\" class=\"headerlink\" title=\"Web API 存在的问题\"></a>Web API 存在的问题</h3><ul>\n<li><p>Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。</p>\n</li>\n<li><p>要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。</p>\n</li>\n<li><p>Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。</p>\n<h3 id=\"困惑-Web-API的发展方向\"><a href=\"#困惑-Web-API的发展方向\" class=\"headerlink\" title=\"困惑-Web API的发展方向\"></a>困惑-Web API的发展方向</h3><p>目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。</p>\n","site":{"data":{}},"excerpt":"<p><strong>REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。</strong></p>","more":"<h3 id=\"超媒体的重要性\"><a href=\"#超媒体的重要性\" class=\"headerlink\" title=\"超媒体的重要性\"></a>超媒体的重要性</h3><p>超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。</p>\n<blockquote>\n<p>Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。</p>\n</blockquote>\n<p>这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 <strong>互联网规模（Internet-scale）</strong> 的 <strong>分布式</strong> <strong>超媒体</strong> 系统的需求来进行分析。</p>\n<p><strong>超媒体是 REST 的基点之一。</strong></p>\n<h3 id=\"WEB-API-中的超媒体\"><a href=\"#WEB-API-中的超媒体\" class=\"headerlink\" title=\"WEB API 中的超媒体\"></a>WEB API 中的超媒体</h3><p>超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《<a href=\"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\" target=\"_blank\" rel=\"noopener\">REST APIs must be hypertext-driven</a>》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。</p>\n<p><strong>关于超媒体与超文本，以下是Fielding博士在评论中的回复</strong></p>\n<blockquote>\n<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.</p>\n</blockquote>\n<h3 id=\"超媒体的作用\"><a href=\"#超媒体的作用\" class=\"headerlink\" title=\"超媒体的作用\"></a>超媒体的作用</h3><p>论文中给出的正式的超媒体的定义：</p>\n<blockquote>\n<p>超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。</p>\n</blockquote>\n<p><strong>超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力</strong>。举个例子，HTML 的 <a> 标签：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;点击我将跳转至百度&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br></pre></td></tr></table></figure>\n<p>这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。</p>\n<blockquote>\n<p>超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。</p>\n</blockquote>\n<p>以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。</p>\n<blockquote>\n<p>通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。</p>\n</blockquote>\n<h3 id=\"Web-API-存在的问题\"><a href=\"#Web-API-存在的问题\" class=\"headerlink\" title=\"Web API 存在的问题\"></a>Web API 存在的问题</h3><ul>\n<li><p>Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。</p>\n</li>\n<li><p>要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。</p>\n</li>\n<li><p>Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。</p>\n<h3 id=\"困惑-Web-API的发展方向\"><a href=\"#困惑-Web-API的发展方向\" class=\"headerlink\" title=\"困惑-Web API的发展方向\"></a>困惑-Web API的发展方向</h3><p>目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。</p>"},{"title":"Session 与 JWT","date":"2017-08-11T11:18:17.000Z","_content":"\n**关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT**\n\n<!--more-->  \n\n### 知识点\n\n1. **无状态**\n\n\t* 关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。\n\n\t* 《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》\n\n\t* > 客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有**会话状态（session state）** 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。\n\n\t* 《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。\n\n2. **Cookie**\n\n\t* 说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。\n\n\t* > cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。\n\n\t* > 可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。\n\n\t* 以上是《HTTP权威指南》一书中对于 cookie 的解释。\n\n3. **Session ID**\n\n\t* 会话 cookie 就是现在人们常说的 session，他的表现形式通常为：\n\n\t* > 一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。\n\n\t* 恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是**使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法**。\n\n4. **JWT**\n\n\t* > JSON Web Token（JWT）是一种开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。\n\n\t* 这种格式有很多优点，我这里用于与 session ID 来比较的是它的**自成一体**。\n\n\t* > 自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。\n\n\t* 是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。\n\n### 比较\n\n在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，[《为什么 session 机制没有被 JWT 所取代?》](https://www.v2ex.com/t/381996)，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。\n\n### 无状态架构的取舍\n\n在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。\n\nFielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。\n\n> 这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。\n> 与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。\n\n*顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。*\n\n### Session ID 与 JWT 的取舍\n\n**Session ID**\n\n先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。\n\n* 可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。\n* 可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。\n* 可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。\n\n**JWT**\n\n再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。\n\n*额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。*\n\n**取舍**\n\n服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。\n\n### 总结\n\nsession ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。\n\n但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。\n","source":"_posts/session-and-JWT.md","raw":"---\ntitle: Session 与 JWT\ndate: 2017/8/11 19:18:17\n---\n\n**关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT**\n\n<!--more-->  \n\n### 知识点\n\n1. **无状态**\n\n\t* 关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。\n\n\t* 《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》\n\n\t* > 客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有**会话状态（session state）** 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。\n\n\t* 《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。\n\n2. **Cookie**\n\n\t* 说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。\n\n\t* > cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。\n\n\t* > 可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。\n\n\t* 以上是《HTTP权威指南》一书中对于 cookie 的解释。\n\n3. **Session ID**\n\n\t* 会话 cookie 就是现在人们常说的 session，他的表现形式通常为：\n\n\t* > 一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。\n\n\t* 恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是**使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法**。\n\n4. **JWT**\n\n\t* > JSON Web Token（JWT）是一种开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。\n\n\t* 这种格式有很多优点，我这里用于与 session ID 来比较的是它的**自成一体**。\n\n\t* > 自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。\n\n\t* 是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。\n\n### 比较\n\n在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，[《为什么 session 机制没有被 JWT 所取代?》](https://www.v2ex.com/t/381996)，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。\n\n### 无状态架构的取舍\n\n在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。\n\nFielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。\n\n> 这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。\n> 与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。\n\n*顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。*\n\n### Session ID 与 JWT 的取舍\n\n**Session ID**\n\n先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。\n\n* 可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。\n* 可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。\n* 可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。\n\n**JWT**\n\n再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。\n\n*额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。*\n\n**取舍**\n\n服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。\n\n### 总结\n\nsession ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。\n\n但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。\n","slug":"session-and-JWT","published":1,"updated":"2020-07-23T00:29:18.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34ea9000hcyzeee6yzfh2","content":"<p><strong>关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT</strong></p>\n<a id=\"more\"></a>  \n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li><p><strong>无状态</strong></p>\n<ul>\n<li><p>关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。</p>\n</li>\n<li><p>《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》</p>\n</li>\n<li><blockquote>\n<p>客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有<strong>会话状态（session state）</strong> 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。</p>\n</blockquote>\n</li>\n<li><p>《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Cookie</strong></p>\n<ul>\n<li><p>说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。</p>\n</li>\n<li><blockquote>\n<p>cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。</p>\n</blockquote>\n</li>\n<li><p>以上是《HTTP权威指南》一书中对于 cookie 的解释。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Session ID</strong></p>\n<ul>\n<li><p>会话 cookie 就是现在人们常说的 session，他的表现形式通常为：</p>\n</li>\n<li><blockquote>\n<p>一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。</p>\n</blockquote>\n</li>\n<li><p>恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是<strong>使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>JWT</strong></p>\n<ul>\n<li><blockquote>\n<p>JSON Web Token（JWT）是一种开放标准（<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">RFC 7519</a>），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。</p>\n</blockquote>\n</li>\n<li><p>这种格式有很多优点，我这里用于与 session ID 来比较的是它的<strong>自成一体</strong>。</p>\n</li>\n<li><blockquote>\n<p>自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。</p>\n</blockquote>\n</li>\n<li><p>是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，<a href=\"https://www.v2ex.com/t/381996\" target=\"_blank\" rel=\"noopener\">《为什么 session 机制没有被 JWT 所取代?》</a>，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。</p>\n<h3 id=\"无状态架构的取舍\"><a href=\"#无状态架构的取舍\" class=\"headerlink\" title=\"无状态架构的取舍\"></a>无状态架构的取舍</h3><p>在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。</p>\n<p>Fielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。</p>\n<blockquote>\n<p>这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。<br>与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。</p>\n</blockquote>\n<p><em>顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。</em></p>\n<h3 id=\"Session-ID-与-JWT-的取舍\"><a href=\"#Session-ID-与-JWT-的取舍\" class=\"headerlink\" title=\"Session ID 与 JWT 的取舍\"></a>Session ID 与 JWT 的取舍</h3><p><strong>Session ID</strong></p>\n<p>先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。</p>\n<ul>\n<li>可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。</li>\n<li>可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。</li>\n<li>可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。</li>\n</ul>\n<p><strong>JWT</strong></p>\n<p>再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。</p>\n<p><em>额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。</em></p>\n<p><strong>取舍</strong></p>\n<p>服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>session ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。</p>\n<p>但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。</p>\n","site":{"data":{}},"excerpt":"<p><strong>关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT</strong></p>","more":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li><p><strong>无状态</strong></p>\n<ul>\n<li><p>关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。</p>\n</li>\n<li><p>《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》</p>\n</li>\n<li><blockquote>\n<p>客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有<strong>会话状态（session state）</strong> 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。</p>\n</blockquote>\n</li>\n<li><p>《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Cookie</strong></p>\n<ul>\n<li><p>说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。</p>\n</li>\n<li><blockquote>\n<p>cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。</p>\n</blockquote>\n</li>\n<li><p>以上是《HTTP权威指南》一书中对于 cookie 的解释。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Session ID</strong></p>\n<ul>\n<li><p>会话 cookie 就是现在人们常说的 session，他的表现形式通常为：</p>\n</li>\n<li><blockquote>\n<p>一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。</p>\n</blockquote>\n</li>\n<li><p>恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是<strong>使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>JWT</strong></p>\n<ul>\n<li><blockquote>\n<p>JSON Web Token（JWT）是一种开放标准（<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">RFC 7519</a>），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。</p>\n</blockquote>\n</li>\n<li><p>这种格式有很多优点，我这里用于与 session ID 来比较的是它的<strong>自成一体</strong>。</p>\n</li>\n<li><blockquote>\n<p>自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。</p>\n</blockquote>\n</li>\n<li><p>是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，<a href=\"https://www.v2ex.com/t/381996\" target=\"_blank\" rel=\"noopener\">《为什么 session 机制没有被 JWT 所取代?》</a>，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。</p>\n<h3 id=\"无状态架构的取舍\"><a href=\"#无状态架构的取舍\" class=\"headerlink\" title=\"无状态架构的取舍\"></a>无状态架构的取舍</h3><p>在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。</p>\n<p>Fielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。</p>\n<blockquote>\n<p>这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。<br>与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。</p>\n</blockquote>\n<p><em>顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。</em></p>\n<h3 id=\"Session-ID-与-JWT-的取舍\"><a href=\"#Session-ID-与-JWT-的取舍\" class=\"headerlink\" title=\"Session ID 与 JWT 的取舍\"></a>Session ID 与 JWT 的取舍</h3><p><strong>Session ID</strong></p>\n<p>先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。</p>\n<ul>\n<li>可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。</li>\n<li>可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。</li>\n<li>可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。</li>\n</ul>\n<p><strong>JWT</strong></p>\n<p>再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。</p>\n<p><em>额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。</em></p>\n<p><strong>取舍</strong></p>\n<p>服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>session ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。</p>\n<p>但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。</p>"},{"title":"记一次 Traefik 无法代理 MySQL 问题","date":"2020-04-12T16:00:00.000Z","_content":"\nTraefik 从 2.0 版本开始支持 TCP route，我也使用 Traefik 作为 kubernetes 集群的 Ingress，但是在使用过程中，发现 Traefik 为 MySQL 创建的 TCP route 无法正常工作，经过排查搜索后发现了官方人员关于这个疑惑的[解答](https://community.containo.us/t/v2-tcp-router-with-tls-example/2664)，以下截取片段：\n\n> But be careful: not all protocols based on TCP and using TLS supports the SNI routing or the passthrough. It requires the protocol supporting SNI (for instance MySQL doesn't) and doing a TLS handshake (if it is a STARTTLS, then it does not work).\n\n虽然找到了问题是由于 MySQL 不支持，但也勾起了我的好奇心，什么是 SNI？Traefik 为什么要使用 `HostSNI` 创建 TCP route 呢？为什么 MySQL 不支持 SNI 呢？于是带着这些问题，我开始寻找答案。\n\n<!--more-->  \n\n\n## TLS Extensions —— SNI\n\n首先从了解 SNI 开始，SNI 是 TLS 的一个扩展协议。\n\n### 什么是 TLS Extensions？\n\nTLS 扩展于 2003 年以一个独立的规范（[RFC 3546](https://tools.ietf.org/html/rfc3546)）被提出，经过不断的发展：[RFC 4366](https://tools.ietf.org/html/rfc4366)、[RFC 6066](https://tools.ietf.org/html/rfc6066) 等，先后被加入到 TLS1.1、TLS1.2、TLS1.3 中。它能让 Client 和 Server 在不更新 TLS 的基础上，获得新的功能。\n\nClient 在 ClientHello 中声明多个自己可以支持的 Extensions，Server 收到 ClientHello 以后，依次解析 Extensions，有些如果需要立即回应，就在 ServerHello 中作出回应，有些不需要回应，或者 Server 不支持的 Extensions 就不用响应，忽略不处理。\n\n在 ClientHello 中，Extension 字段位于 Compression Methods 字段之后，通过 Wireshark 工具进行查看：\n\n![github-wireshark](https://tva1.sinaimg.cn/large/007S8ZIlly1ge84vtby39j31nf0u0wt5.jpg)\n\n### 什么是 SNI 扩展？\n\n我们知道，在 Nginx 中可以通过指定不同的 `server_name` 来配置多个站点。HTTP/1.1 协议请求头中的 `Host` 字段可以标识出当前请求属于哪个站点。但是在 TLS 协议中，没有提供一种机制来告诉 Server 它正在建立连接的 Server 的名称，那么对于在同一个地址，并且还使用不同证书的情况下，Server 怎么知道该发送哪个证书？\n\n于是为了解决这个问题，SNI 应运而生。SNI 全称是 Server Name Indication，[最初是 2003 年标准化的](https://tools.ietf.org/html/rfc3546#page-8)，在 [RFC 6066](https://tools.ietf.org/html/rfc6066#page5) 中有更新。它允许 Server 在同一个网络地址上托管多个启用了 TLS 的服务，要求 Client 在初始 TLS 握手期间指定要连接到哪个服务。\n\n```c\nstruct {\n  NameType name_type;\n  select (name_type) {\n  \tcase host_name: HostName;\n  } name;\n} ServerName;\n\nenum {\n\thost_name(0), (255)\n} NameType;\n\nopaque HostName<1..2^16-1>;\n\nstruct {\n\tServerName server_name_list<1..2^16-1>\n} ServerNameList;\n```\n\nExtension type 是 `server_name`，点开上图 Wireshark 中 `server_name` 一行，查看更详细信息：\n\n![server_name](https://tva1.sinaimg.cn/large/007S8ZIlly1ge85t4pu0uj31n80u019m.jpg)\n\n`ServerNameList` 不能包含多个具有相同 `ServerNameType` 的名称，当前 `ServernameType` 只有 `host_name` 一种，在以后可能会添加更多类型，`host_name` 包含标准的 DNS hostname 且不含结尾点。如果 Server 支持 SNI 扩展，但不能识别 `server_name`，则应该发送 `fatal-level unrecognized_name(112)` 来终止握手或继续握手。\n\n*更多详细的规范内容可以到 [RFC 6066](https://tools.ietf.org/html/rfc6066#page5) 中查看。[这里](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml) 有一个扩展协议列表。*\n\n\n\n## Traefik 的 TCP 路由与 SNI\n\nTraefik 从 2.0 开始支持 TCP 路由，也支持在相同的 `entryPoints`（traefik 中的入口端口） 中定义不同的 TCP 路由，但是我们都知道，TCP 是传输层协议，没有任何 SNI 类的机制来保证同一地址入口可以处理不同的服务。那么，Traefik 是怎么做的呢？\n\n### 部署基于 TLS 的 TCP 路由\n\n答案很简单，Traefik 支持通过 SNI 在每台主机上进行路由，因为这是通过 TCP 进行路由的惟一标准方法，但是 TCP 本身没有 SNI，因此必须使用 TLS。部署配置：\n\n```yaml\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: example\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: HostSNI(`web.example.com`)\n    services:\n    - name: example-service-name\n      port: 80\n  tls: \n    secretName: traefik-tls-certs\n```\n\n`HostSNI` 中的值对应 SNI 扩展中 `server_name` 的值，Traefik 以此来进行路由，并找到对应证书。还需要注意的是 `entryPoints` 部分由部署的 Traefik 配置中的 `entryPoints` 参数决定，此处的 `web` 是我们指定的一个 `entryPoints` 名称，端口地址对应为 80 端口：\n\n```yaml\n......\n- image: traefik:2.1.1\n  name: traefik\n  ports:\n  - name: web\n    containerPort: 80\n    hostPort: 80\n  args:\n  - --entryPoints.web.address=:80\n......\n```\n\n此处使用 `hostPort` 的方式暴露入口点，是为了能够通过 Traefik 部署的节点的入口点端口直接访问到 backend service。\n\n### 部署非 TLS 的 TCP 路由\n\n如果有不支持 SNI/TLS 协议的应用客户端，Traefik 也可以部署 “plain TCP”，也就是标准的通过端口进行路由。此时虽然 `metch` 还是使用 `HostSNI`，但需要指定为通配符 `*`：\n\n```yaml\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: example\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: HostSNI(`*`)\n    services:\n    - name: example-service-name\n      port: 80\n```\n\n### 其他\n\n使用 Traefik 代理 TLS 服务时，backend service 可不设置 TLS 相关，由 Traefik 负责全部相关机制。如果 backend service 有需要加密后的数据时，可通过 `passthrough` 参数配置，Traefik 将发送加密后的数据给 backend service：\n\n```yaml\n......\n  tls: \n    secretName: traefik-tls-certs\n    passthrough: true\n```\n\n\n\n## 为什么不能为 MySQL 代理\n\n当我明白 SNI 协议以及 Traefik 如何使用 SNI/TLS 为 TCP 创建路由时，我开始研究为什么 MySQL 不能使用 SNI 扩展，甚至在 2016 年就有人提出过这个问题，但可惜一直没有人跟进：https://bugs.mysql.com/bug.php?id=82872。这让我有些疑惑，毕竟 MySQL 已经实现了 TLS 功能，为什么在有用户有需求的情况下不加上 SNI 扩展呢？毕竟这又不是过于复杂的功能。\n\n在寻找到答案之前，让我们先简单复习下 TLS 协议的标准流程：首先是 TCP 的三次握手，随后开始 TLS 的握手，如果是 TLS1.2 或之前需要四次握手，如果是 TLS1.3 则需要三次握手，最后开始传输加密数据。\n\n下面来看看 MySQL 的流程，输入命令：`mysql -hmysql.example.com -P3306 -uroot -pmysql --ssl-mode=REQUIRED`，使用 wireshark 查看：\n\n*MySQL 对于 TCP 连接已经默认使用 tls，如果不想使用需要修改参数为 `--ssl-mode=DISABLED`，同时对于 localhost 默认使用 soket 连接，强制使用 TCP 连接需要增加参数: `--protocol tcp`。*\n\n![mysql](https://tva1.sinaimg.cn/large/007S8ZIlly1ge97ghpl3ej31ja0u07t9.jpg)\n\n上图中可以看出，在 TCP 握手后，Server 会发送 MySQL 协议 HandShake Paket：`Server Greeting proto=10 version=5.7.29`，开始 MySQL 协议的握手流程，随后 Client 发送 Auth Paket，图中为开启 TLS 认证的流程，所以并未显示 `user` 的内容，如果设置 MySQL Client 参数为 `--ssl-mode=DISABLED`，将显示认证的用户名，并且 Server 会在随后发送 `Auth Switch Request` 包继续认证流程，此处不再赘述，有兴趣的可以自己抓包看一下。\n\n看到这里其实就已经很清晰了，MySQL 在连接时会将自定义协议握手流程置于 TLS 协议握手之前，以至于 Traefik 无法通过 TLS SNI 找到对应 backend service，也就无法发送 MySQL 的 HandShake Paket。对于 MySQL Client 来说，如果是有超时机制，会响应 `waiting for initial communication packet` 或类似的错误，如果没有超时机制，就会一直等待。\n\n这点对于 Traefik 来说也很无奈，MySQL 自定义协议中也没有 SNI 的机制，而 TLS 又在 MySQL 协议握手之后发生，导致它完全没办法进行路由，只好期望 MySQL 能尽快修改这部分的流程。[这里](https://github.com/containous/traefik/issues/5155)有官方对于这件事的一些回复：https://github.com/containous/traefik/issues/5155\n\n\n\n## 其他常见数据库\n\n了解到了 MySQL 的问题，不禁让我好奇，其他的常见数据库是否也拥有相同问题，于是我又去看了 MongoDB 和 Redis。\n\n### MongoDB\n\n使用命令进行连接：`mongo --host mongo.example.com --port 27017 --ssl`\n\n![mongodb](https://tva1.sinaimg.cn/large/007S8ZIlly1ge98i03x3ej31pq0u0wsp.jpg)\n\n非常标准的流程，也支持 SNI 扩展，Traefik 可以顺利的进行路由。\n\n### Redis\n\nRedis 从 6.0 开始支持 SSL/TLS，但 6.0 正在处于 RC（Release　Candidate） 阶段，如果想要测试，可以下载代码后自行编译。TLS 特性是个可选特性，需要在编译时使用参数确认使用：`make BUILD_TLS=yes`。\n\n*相关官方文档：https://redis.io/topics/encryption*\n\n编译后尝试连接 Traefik 代理的地址：`./redis-cli --tls -h testtcp.ohuna.cloud -p 6379`，却发现 Traefik 响应了 fatal level error： `Unknown CA`：\n\n![redis](https://tva1.sinaimg.cn/large/007S8ZIlly1ge99xitc2zj31j50u0qlj.jpg)\n\n很明显是因为 redis 没有使用 SNI 扩展，但文档中又没有提及，所以我去 redis 源码中寻找答案。在 `tls.h` 中了解到 redis 使用了 openssl：\n\n```c\n......\n#ifdef USE_OPENSSL\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n```\n\n于是通过 openssl 设置 SNI 的函数 `SSL_set_tlsext_host_name` 进行查找：\n\n```c\n#redis-cli.c\n    if (config.sni && !SSL_set_tlsext_host_name(ssl, config.sni)) {\n        *err = \"Failed to configure SNI\";\n        SSL_free(ssl);\n        return REDIS_ERR;\n    }\n......\n  #ifdef USE_OPENSSL\n        } else if (!strcmp(argv[i],\"--tls\")) {\n            config.tls = 1;\n        } else if (!strcmp(argv[i],\"--sni\") && !lastarg) {\n            config.sni = argv[++i];\n......\n```\n\n发现可以通过 `--sni` 参数进行指定，通过 `redis-cli --help` 能查看到相关说明：\n\n```bash\nredis-cli 5.9.103\n\nUsage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n......\n\t--tls              Establish a secure TLS connection.\n  --sni <host>       Server name indication for TLS.\n```\n\n由于粗心大意，导致耽误了时间去寻找 SNI 的设置方法，不过 redis 需要必须手动设置 SNI 的方式也是很奇怪。重新使用带有 `--sni` 参数的命令进行连接：`./redis-cli --tls -h redis.example.com -p 6379 --sni redis.example.com`，这次成功连接，查看 TLS ClientHello 中也带有 `server_name`：\n\n![redis-success](https://tva1.sinaimg.cn/large/007S8ZIlly1ge9amao5j7j31ji0u01a4.jpg)\n\n\n\n## 扩展阅读——ESNI\n\n虽然关于 Traefik 与 MySQL 的问题告一段落，但 SNI 本身还有其他可学习的内容。\n\n#### SNI 的安全问题\n\n由于 SNI 扩展是在 TLS 握手期间通过 ClientHello 进行发送，在此时 Client 和 Server 还未共享加密密钥，因此 ClientHello 消息未被加密发送。这就意味着如果有中间人，是可以拦截明文的 ClientHello 消息，并知道 Client 将要访问的网址。\n\n#### ESNI\n\n当前有一项草案正在试图解决这个问题，也就是 [ESNI（Encrypted Server Name Indication）](https://tools.ietf.org/html/draft-rescorla-tls-esni-00)。\n\n对于加密 SNI 内容这种先有鸡还是先有蛋的问题，ESNI 通过引入 DNS 来解决。服务器在已知的 DNS 记录上发布一个公钥，客户端可以在连接 Server 之前获得该公钥。然后，客户端将 ClientHello 中的 SNI 扩展替换为 ESNI，也就是使用获得的公钥对 SNI 信息对称加密。\n\nESNI 必须要基于 TLS1.3 版本，因为 TLS1.3 使用了 Deffie-Hellman 算法进行密钥交换，DH 算法可以使通信的双方能在非安全的信道中安全的交换密钥。否则，就算加密了 SNI，也可以通过明文证书进行验证。\n\n如果仅仅使用 DNS 也不行，因为 DNS 默认是为加密的，所以需要使用的 DNS 支持 DNS over TLS（DoT）或 DNS over HTTPS（DoH）特性。\n\n*简单的学习下 ESNI，更多详细内容可以通过 Cloudflare 的[文章](https://blog.cloudflare.com/zh/encrypted-sni-zh/)或[草案](https://tools.ietf.org/html/draft-rescorla-tls-esni-00)进行了解。*\n\n\n\n## 参考和致谢\n\n学习过程中碰到了诸多问题，幸好互联网上有着众多的学习资料，感谢以下文档与博客：\n\n[一文搞懂 Traefik2.1 的使用](https://www.qikqiak.com/post/traefik-2.1-101/)\n\n[HTTPS 交互过程分析](https://harttle.land/2018/03/25/https-protocols.html)\n\n[关于启用 HTTPS 的一些经验分享（二）](https://imququ.com/post/sth-about-switch-to-https-2.html)\n\n[HTTPS 温故知新（六） —— TLS 中的 Extensions](https://halfrost.com/https-extensions/)\n\n[RFC 6066](https://tools.ietf.org/html/rfc6066)\n\n[实现自己的数据库驱动——WireShark分析MySQL网络协议中的数据包（二）]([https://www.callmejiagu.com/2018/10/26/WireShark-%E5%88%86%E6%9E%90MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/](https://www.callmejiagu.com/2018/10/26/WireShark-分析MySQL网络协议中的数据包（二）/))\n\n[不加密，无隐私：加密SNI工作原理](https://blog.cloudflare.com/zh/encrypted-sni-zh/)","source":"_posts/记一次 Traefik 无法代理 MySQL 问题.md","raw":"---\ntitle: 记一次 Traefik 无法代理 MySQL 问题\ndate: 2020/4/13 00:00:00\n---\n\nTraefik 从 2.0 版本开始支持 TCP route，我也使用 Traefik 作为 kubernetes 集群的 Ingress，但是在使用过程中，发现 Traefik 为 MySQL 创建的 TCP route 无法正常工作，经过排查搜索后发现了官方人员关于这个疑惑的[解答](https://community.containo.us/t/v2-tcp-router-with-tls-example/2664)，以下截取片段：\n\n> But be careful: not all protocols based on TCP and using TLS supports the SNI routing or the passthrough. It requires the protocol supporting SNI (for instance MySQL doesn't) and doing a TLS handshake (if it is a STARTTLS, then it does not work).\n\n虽然找到了问题是由于 MySQL 不支持，但也勾起了我的好奇心，什么是 SNI？Traefik 为什么要使用 `HostSNI` 创建 TCP route 呢？为什么 MySQL 不支持 SNI 呢？于是带着这些问题，我开始寻找答案。\n\n<!--more-->  \n\n\n## TLS Extensions —— SNI\n\n首先从了解 SNI 开始，SNI 是 TLS 的一个扩展协议。\n\n### 什么是 TLS Extensions？\n\nTLS 扩展于 2003 年以一个独立的规范（[RFC 3546](https://tools.ietf.org/html/rfc3546)）被提出，经过不断的发展：[RFC 4366](https://tools.ietf.org/html/rfc4366)、[RFC 6066](https://tools.ietf.org/html/rfc6066) 等，先后被加入到 TLS1.1、TLS1.2、TLS1.3 中。它能让 Client 和 Server 在不更新 TLS 的基础上，获得新的功能。\n\nClient 在 ClientHello 中声明多个自己可以支持的 Extensions，Server 收到 ClientHello 以后，依次解析 Extensions，有些如果需要立即回应，就在 ServerHello 中作出回应，有些不需要回应，或者 Server 不支持的 Extensions 就不用响应，忽略不处理。\n\n在 ClientHello 中，Extension 字段位于 Compression Methods 字段之后，通过 Wireshark 工具进行查看：\n\n![github-wireshark](https://tva1.sinaimg.cn/large/007S8ZIlly1ge84vtby39j31nf0u0wt5.jpg)\n\n### 什么是 SNI 扩展？\n\n我们知道，在 Nginx 中可以通过指定不同的 `server_name` 来配置多个站点。HTTP/1.1 协议请求头中的 `Host` 字段可以标识出当前请求属于哪个站点。但是在 TLS 协议中，没有提供一种机制来告诉 Server 它正在建立连接的 Server 的名称，那么对于在同一个地址，并且还使用不同证书的情况下，Server 怎么知道该发送哪个证书？\n\n于是为了解决这个问题，SNI 应运而生。SNI 全称是 Server Name Indication，[最初是 2003 年标准化的](https://tools.ietf.org/html/rfc3546#page-8)，在 [RFC 6066](https://tools.ietf.org/html/rfc6066#page5) 中有更新。它允许 Server 在同一个网络地址上托管多个启用了 TLS 的服务，要求 Client 在初始 TLS 握手期间指定要连接到哪个服务。\n\n```c\nstruct {\n  NameType name_type;\n  select (name_type) {\n  \tcase host_name: HostName;\n  } name;\n} ServerName;\n\nenum {\n\thost_name(0), (255)\n} NameType;\n\nopaque HostName<1..2^16-1>;\n\nstruct {\n\tServerName server_name_list<1..2^16-1>\n} ServerNameList;\n```\n\nExtension type 是 `server_name`，点开上图 Wireshark 中 `server_name` 一行，查看更详细信息：\n\n![server_name](https://tva1.sinaimg.cn/large/007S8ZIlly1ge85t4pu0uj31n80u019m.jpg)\n\n`ServerNameList` 不能包含多个具有相同 `ServerNameType` 的名称，当前 `ServernameType` 只有 `host_name` 一种，在以后可能会添加更多类型，`host_name` 包含标准的 DNS hostname 且不含结尾点。如果 Server 支持 SNI 扩展，但不能识别 `server_name`，则应该发送 `fatal-level unrecognized_name(112)` 来终止握手或继续握手。\n\n*更多详细的规范内容可以到 [RFC 6066](https://tools.ietf.org/html/rfc6066#page5) 中查看。[这里](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml) 有一个扩展协议列表。*\n\n\n\n## Traefik 的 TCP 路由与 SNI\n\nTraefik 从 2.0 开始支持 TCP 路由，也支持在相同的 `entryPoints`（traefik 中的入口端口） 中定义不同的 TCP 路由，但是我们都知道，TCP 是传输层协议，没有任何 SNI 类的机制来保证同一地址入口可以处理不同的服务。那么，Traefik 是怎么做的呢？\n\n### 部署基于 TLS 的 TCP 路由\n\n答案很简单，Traefik 支持通过 SNI 在每台主机上进行路由，因为这是通过 TCP 进行路由的惟一标准方法，但是 TCP 本身没有 SNI，因此必须使用 TLS。部署配置：\n\n```yaml\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: example\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: HostSNI(`web.example.com`)\n    services:\n    - name: example-service-name\n      port: 80\n  tls: \n    secretName: traefik-tls-certs\n```\n\n`HostSNI` 中的值对应 SNI 扩展中 `server_name` 的值，Traefik 以此来进行路由，并找到对应证书。还需要注意的是 `entryPoints` 部分由部署的 Traefik 配置中的 `entryPoints` 参数决定，此处的 `web` 是我们指定的一个 `entryPoints` 名称，端口地址对应为 80 端口：\n\n```yaml\n......\n- image: traefik:2.1.1\n  name: traefik\n  ports:\n  - name: web\n    containerPort: 80\n    hostPort: 80\n  args:\n  - --entryPoints.web.address=:80\n......\n```\n\n此处使用 `hostPort` 的方式暴露入口点，是为了能够通过 Traefik 部署的节点的入口点端口直接访问到 backend service。\n\n### 部署非 TLS 的 TCP 路由\n\n如果有不支持 SNI/TLS 协议的应用客户端，Traefik 也可以部署 “plain TCP”，也就是标准的通过端口进行路由。此时虽然 `metch` 还是使用 `HostSNI`，但需要指定为通配符 `*`：\n\n```yaml\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: example\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: HostSNI(`*`)\n    services:\n    - name: example-service-name\n      port: 80\n```\n\n### 其他\n\n使用 Traefik 代理 TLS 服务时，backend service 可不设置 TLS 相关，由 Traefik 负责全部相关机制。如果 backend service 有需要加密后的数据时，可通过 `passthrough` 参数配置，Traefik 将发送加密后的数据给 backend service：\n\n```yaml\n......\n  tls: \n    secretName: traefik-tls-certs\n    passthrough: true\n```\n\n\n\n## 为什么不能为 MySQL 代理\n\n当我明白 SNI 协议以及 Traefik 如何使用 SNI/TLS 为 TCP 创建路由时，我开始研究为什么 MySQL 不能使用 SNI 扩展，甚至在 2016 年就有人提出过这个问题，但可惜一直没有人跟进：https://bugs.mysql.com/bug.php?id=82872。这让我有些疑惑，毕竟 MySQL 已经实现了 TLS 功能，为什么在有用户有需求的情况下不加上 SNI 扩展呢？毕竟这又不是过于复杂的功能。\n\n在寻找到答案之前，让我们先简单复习下 TLS 协议的标准流程：首先是 TCP 的三次握手，随后开始 TLS 的握手，如果是 TLS1.2 或之前需要四次握手，如果是 TLS1.3 则需要三次握手，最后开始传输加密数据。\n\n下面来看看 MySQL 的流程，输入命令：`mysql -hmysql.example.com -P3306 -uroot -pmysql --ssl-mode=REQUIRED`，使用 wireshark 查看：\n\n*MySQL 对于 TCP 连接已经默认使用 tls，如果不想使用需要修改参数为 `--ssl-mode=DISABLED`，同时对于 localhost 默认使用 soket 连接，强制使用 TCP 连接需要增加参数: `--protocol tcp`。*\n\n![mysql](https://tva1.sinaimg.cn/large/007S8ZIlly1ge97ghpl3ej31ja0u07t9.jpg)\n\n上图中可以看出，在 TCP 握手后，Server 会发送 MySQL 协议 HandShake Paket：`Server Greeting proto=10 version=5.7.29`，开始 MySQL 协议的握手流程，随后 Client 发送 Auth Paket，图中为开启 TLS 认证的流程，所以并未显示 `user` 的内容，如果设置 MySQL Client 参数为 `--ssl-mode=DISABLED`，将显示认证的用户名，并且 Server 会在随后发送 `Auth Switch Request` 包继续认证流程，此处不再赘述，有兴趣的可以自己抓包看一下。\n\n看到这里其实就已经很清晰了，MySQL 在连接时会将自定义协议握手流程置于 TLS 协议握手之前，以至于 Traefik 无法通过 TLS SNI 找到对应 backend service，也就无法发送 MySQL 的 HandShake Paket。对于 MySQL Client 来说，如果是有超时机制，会响应 `waiting for initial communication packet` 或类似的错误，如果没有超时机制，就会一直等待。\n\n这点对于 Traefik 来说也很无奈，MySQL 自定义协议中也没有 SNI 的机制，而 TLS 又在 MySQL 协议握手之后发生，导致它完全没办法进行路由，只好期望 MySQL 能尽快修改这部分的流程。[这里](https://github.com/containous/traefik/issues/5155)有官方对于这件事的一些回复：https://github.com/containous/traefik/issues/5155\n\n\n\n## 其他常见数据库\n\n了解到了 MySQL 的问题，不禁让我好奇，其他的常见数据库是否也拥有相同问题，于是我又去看了 MongoDB 和 Redis。\n\n### MongoDB\n\n使用命令进行连接：`mongo --host mongo.example.com --port 27017 --ssl`\n\n![mongodb](https://tva1.sinaimg.cn/large/007S8ZIlly1ge98i03x3ej31pq0u0wsp.jpg)\n\n非常标准的流程，也支持 SNI 扩展，Traefik 可以顺利的进行路由。\n\n### Redis\n\nRedis 从 6.0 开始支持 SSL/TLS，但 6.0 正在处于 RC（Release　Candidate） 阶段，如果想要测试，可以下载代码后自行编译。TLS 特性是个可选特性，需要在编译时使用参数确认使用：`make BUILD_TLS=yes`。\n\n*相关官方文档：https://redis.io/topics/encryption*\n\n编译后尝试连接 Traefik 代理的地址：`./redis-cli --tls -h testtcp.ohuna.cloud -p 6379`，却发现 Traefik 响应了 fatal level error： `Unknown CA`：\n\n![redis](https://tva1.sinaimg.cn/large/007S8ZIlly1ge99xitc2zj31j50u0qlj.jpg)\n\n很明显是因为 redis 没有使用 SNI 扩展，但文档中又没有提及，所以我去 redis 源码中寻找答案。在 `tls.h` 中了解到 redis 使用了 openssl：\n\n```c\n......\n#ifdef USE_OPENSSL\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n```\n\n于是通过 openssl 设置 SNI 的函数 `SSL_set_tlsext_host_name` 进行查找：\n\n```c\n#redis-cli.c\n    if (config.sni && !SSL_set_tlsext_host_name(ssl, config.sni)) {\n        *err = \"Failed to configure SNI\";\n        SSL_free(ssl);\n        return REDIS_ERR;\n    }\n......\n  #ifdef USE_OPENSSL\n        } else if (!strcmp(argv[i],\"--tls\")) {\n            config.tls = 1;\n        } else if (!strcmp(argv[i],\"--sni\") && !lastarg) {\n            config.sni = argv[++i];\n......\n```\n\n发现可以通过 `--sni` 参数进行指定，通过 `redis-cli --help` 能查看到相关说明：\n\n```bash\nredis-cli 5.9.103\n\nUsage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n......\n\t--tls              Establish a secure TLS connection.\n  --sni <host>       Server name indication for TLS.\n```\n\n由于粗心大意，导致耽误了时间去寻找 SNI 的设置方法，不过 redis 需要必须手动设置 SNI 的方式也是很奇怪。重新使用带有 `--sni` 参数的命令进行连接：`./redis-cli --tls -h redis.example.com -p 6379 --sni redis.example.com`，这次成功连接，查看 TLS ClientHello 中也带有 `server_name`：\n\n![redis-success](https://tva1.sinaimg.cn/large/007S8ZIlly1ge9amao5j7j31ji0u01a4.jpg)\n\n\n\n## 扩展阅读——ESNI\n\n虽然关于 Traefik 与 MySQL 的问题告一段落，但 SNI 本身还有其他可学习的内容。\n\n#### SNI 的安全问题\n\n由于 SNI 扩展是在 TLS 握手期间通过 ClientHello 进行发送，在此时 Client 和 Server 还未共享加密密钥，因此 ClientHello 消息未被加密发送。这就意味着如果有中间人，是可以拦截明文的 ClientHello 消息，并知道 Client 将要访问的网址。\n\n#### ESNI\n\n当前有一项草案正在试图解决这个问题，也就是 [ESNI（Encrypted Server Name Indication）](https://tools.ietf.org/html/draft-rescorla-tls-esni-00)。\n\n对于加密 SNI 内容这种先有鸡还是先有蛋的问题，ESNI 通过引入 DNS 来解决。服务器在已知的 DNS 记录上发布一个公钥，客户端可以在连接 Server 之前获得该公钥。然后，客户端将 ClientHello 中的 SNI 扩展替换为 ESNI，也就是使用获得的公钥对 SNI 信息对称加密。\n\nESNI 必须要基于 TLS1.3 版本，因为 TLS1.3 使用了 Deffie-Hellman 算法进行密钥交换，DH 算法可以使通信的双方能在非安全的信道中安全的交换密钥。否则，就算加密了 SNI，也可以通过明文证书进行验证。\n\n如果仅仅使用 DNS 也不行，因为 DNS 默认是为加密的，所以需要使用的 DNS 支持 DNS over TLS（DoT）或 DNS over HTTPS（DoH）特性。\n\n*简单的学习下 ESNI，更多详细内容可以通过 Cloudflare 的[文章](https://blog.cloudflare.com/zh/encrypted-sni-zh/)或[草案](https://tools.ietf.org/html/draft-rescorla-tls-esni-00)进行了解。*\n\n\n\n## 参考和致谢\n\n学习过程中碰到了诸多问题，幸好互联网上有着众多的学习资料，感谢以下文档与博客：\n\n[一文搞懂 Traefik2.1 的使用](https://www.qikqiak.com/post/traefik-2.1-101/)\n\n[HTTPS 交互过程分析](https://harttle.land/2018/03/25/https-protocols.html)\n\n[关于启用 HTTPS 的一些经验分享（二）](https://imququ.com/post/sth-about-switch-to-https-2.html)\n\n[HTTPS 温故知新（六） —— TLS 中的 Extensions](https://halfrost.com/https-extensions/)\n\n[RFC 6066](https://tools.ietf.org/html/rfc6066)\n\n[实现自己的数据库驱动——WireShark分析MySQL网络协议中的数据包（二）]([https://www.callmejiagu.com/2018/10/26/WireShark-%E5%88%86%E6%9E%90MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/](https://www.callmejiagu.com/2018/10/26/WireShark-分析MySQL网络协议中的数据包（二）/))\n\n[不加密，无隐私：加密SNI工作原理](https://blog.cloudflare.com/zh/encrypted-sni-zh/)","slug":"记一次 Traefik 无法代理 MySQL 问题","published":1,"updated":"2020-07-23T00:29:18.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcy34eac000icyzevu0ah67d","content":"<p>Traefik 从 2.0 版本开始支持 TCP route，我也使用 Traefik 作为 kubernetes 集群的 Ingress，但是在使用过程中，发现 Traefik 为 MySQL 创建的 TCP route 无法正常工作，经过排查搜索后发现了官方人员关于这个疑惑的<a href=\"https://community.containo.us/t/v2-tcp-router-with-tls-example/2664\" target=\"_blank\" rel=\"noopener\">解答</a>，以下截取片段：</p>\n<blockquote>\n<p>But be careful: not all protocols based on TCP and using TLS supports the SNI routing or the passthrough. It requires the protocol supporting SNI (for instance MySQL doesn’t) and doing a TLS handshake (if it is a STARTTLS, then it does not work).</p>\n</blockquote>\n<p>虽然找到了问题是由于 MySQL 不支持，但也勾起了我的好奇心，什么是 SNI？Traefik 为什么要使用 <code>HostSNI</code> 创建 TCP route 呢？为什么 MySQL 不支持 SNI 呢？于是带着这些问题，我开始寻找答案。</p>\n<a id=\"more\"></a>  \n<h2 id=\"TLS-Extensions-——-SNI\"><a href=\"#TLS-Extensions-——-SNI\" class=\"headerlink\" title=\"TLS Extensions —— SNI\"></a>TLS Extensions —— SNI</h2><p>首先从了解 SNI 开始，SNI 是 TLS 的一个扩展协议。</p>\n<h3 id=\"什么是-TLS-Extensions？\"><a href=\"#什么是-TLS-Extensions？\" class=\"headerlink\" title=\"什么是 TLS Extensions？\"></a>什么是 TLS Extensions？</h3><p>TLS 扩展于 2003 年以一个独立的规范（<a href=\"https://tools.ietf.org/html/rfc3546\" target=\"_blank\" rel=\"noopener\">RFC 3546</a>）被提出，经过不断的发展：<a href=\"https://tools.ietf.org/html/rfc4366\" target=\"_blank\" rel=\"noopener\">RFC 4366</a>、<a href=\"https://tools.ietf.org/html/rfc6066\" target=\"_blank\" rel=\"noopener\">RFC 6066</a> 等，先后被加入到 TLS1.1、TLS1.2、TLS1.3 中。它能让 Client 和 Server 在不更新 TLS 的基础上，获得新的功能。</p>\n<p>Client 在 ClientHello 中声明多个自己可以支持的 Extensions，Server 收到 ClientHello 以后，依次解析 Extensions，有些如果需要立即回应，就在 ServerHello 中作出回应，有些不需要回应，或者 Server 不支持的 Extensions 就不用响应，忽略不处理。</p>\n<p>在 ClientHello 中，Extension 字段位于 Compression Methods 字段之后，通过 Wireshark 工具进行查看：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge84vtby39j31nf0u0wt5.jpg\" alt=\"github-wireshark\"></p>\n<h3 id=\"什么是-SNI-扩展？\"><a href=\"#什么是-SNI-扩展？\" class=\"headerlink\" title=\"什么是 SNI 扩展？\"></a>什么是 SNI 扩展？</h3><p>我们知道，在 Nginx 中可以通过指定不同的 <code>server_name</code> 来配置多个站点。HTTP/1.1 协议请求头中的 <code>Host</code> 字段可以标识出当前请求属于哪个站点。但是在 TLS 协议中，没有提供一种机制来告诉 Server 它正在建立连接的 Server 的名称，那么对于在同一个地址，并且还使用不同证书的情况下，Server 怎么知道该发送哪个证书？</p>\n<p>于是为了解决这个问题，SNI 应运而生。SNI 全称是 Server Name Indication，<a href=\"https://tools.ietf.org/html/rfc3546#page-8\" target=\"_blank\" rel=\"noopener\">最初是 2003 年标准化的</a>，在 <a href=\"https://tools.ietf.org/html/rfc6066#page5\" target=\"_blank\" rel=\"noopener\">RFC 6066</a> 中有更新。它允许 Server 在同一个网络地址上托管多个启用了 TLS 的服务，要求 Client 在初始 TLS 握手期间指定要连接到哪个服务。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  NameType name_type;</span><br><span class=\"line\">  select (name_type) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">case</span> host_name: HostName;</span><br><span class=\"line\">  &#125; name;</span><br><span class=\"line\">&#125; ServerName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">\thost_name(<span class=\"number\">0</span>), (<span class=\"number\">255</span>)</span><br><span class=\"line\">&#125; NameType;</span><br><span class=\"line\"></span><br><span class=\"line\">opaque HostName&lt;<span class=\"number\">1.</span><span class=\"number\">.2</span>^<span class=\"number\">16</span><span class=\"number\">-1</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tServerName server_name_list&lt;<span class=\"number\">1.</span><span class=\"number\">.2</span>^<span class=\"number\">16</span><span class=\"number\">-1</span>&gt;</span><br><span class=\"line\">&#125; ServerNameList;</span><br></pre></td></tr></table></figure>\n<p>Extension type 是 <code>server_name</code>，点开上图 Wireshark 中 <code>server_name</code> 一行，查看更详细信息：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge85t4pu0uj31n80u019m.jpg\" alt=\"server_name\"></p>\n<p><code>ServerNameList</code> 不能包含多个具有相同 <code>ServerNameType</code> 的名称，当前 <code>ServernameType</code> 只有 <code>host_name</code> 一种，在以后可能会添加更多类型，<code>host_name</code> 包含标准的 DNS hostname 且不含结尾点。如果 Server 支持 SNI 扩展，但不能识别 <code>server_name</code>，则应该发送 <code>fatal-level unrecognized_name(112)</code> 来终止握手或继续握手。</p>\n<p><em>更多详细的规范内容可以到 <a href=\"https://tools.ietf.org/html/rfc6066#page5\" target=\"_blank\" rel=\"noopener\">RFC 6066</a> 中查看。<a href=\"https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml\" target=\"_blank\" rel=\"noopener\">这里</a> 有一个扩展协议列表。</em></p>\n<h2 id=\"Traefik-的-TCP-路由与-SNI\"><a href=\"#Traefik-的-TCP-路由与-SNI\" class=\"headerlink\" title=\"Traefik 的 TCP 路由与 SNI\"></a>Traefik 的 TCP 路由与 SNI</h2><p>Traefik 从 2.0 开始支持 TCP 路由，也支持在相同的 <code>entryPoints</code>（traefik 中的入口端口） 中定义不同的 TCP 路由，但是我们都知道，TCP 是传输层协议，没有任何 SNI 类的机制来保证同一地址入口可以处理不同的服务。那么，Traefik 是怎么做的呢？</p>\n<h3 id=\"部署基于-TLS-的-TCP-路由\"><a href=\"#部署基于-TLS-的-TCP-路由\" class=\"headerlink\" title=\"部署基于 TLS 的 TCP 路由\"></a>部署基于 TLS 的 TCP 路由</h3><p>答案很简单，Traefik 支持通过 SNI 在每台主机上进行路由，因为这是通过 TCP 进行路由的惟一标准方法，但是 TCP 本身没有 SNI，因此必须使用 TLS。部署配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> traefik.containo.us/v1alpha1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> IngressRouteTCP</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> example</span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  entryPoints:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> web</span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">  - match:</span> HostSNI(`web.example.com`)</span><br><span class=\"line\"><span class=\"attr\">    services:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> example-service-name</span><br><span class=\"line\"><span class=\"attr\">      port:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attr\">  tls:</span> </span><br><span class=\"line\"><span class=\"attr\">    secretName:</span> traefik-tls-certs</span><br></pre></td></tr></table></figure>\n<p><code>HostSNI</code> 中的值对应 SNI 扩展中 <code>server_name</code> 的值，Traefik 以此来进行路由，并找到对应证书。还需要注意的是 <code>entryPoints</code> 部分由部署的 Traefik 配置中的 <code>entryPoints</code> 参数决定，此处的 <code>web</code> 是我们指定的一个 <code>entryPoints</code> 名称，端口地址对应为 80 端口：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"attr\">- image:</span> traefik:<span class=\"number\">2.1</span><span class=\"number\">.1</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> traefik</span><br><span class=\"line\"><span class=\"attr\">  ports:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> web</span><br><span class=\"line\"><span class=\"attr\">    containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attr\">    hostPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attr\">  args:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> --entryPoints.web.address=:<span class=\"number\">80</span></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>此处使用 <code>hostPort</code> 的方式暴露入口点，是为了能够通过 Traefik 部署的节点的入口点端口直接访问到 backend service。</p>\n<h3 id=\"部署非-TLS-的-TCP-路由\"><a href=\"#部署非-TLS-的-TCP-路由\" class=\"headerlink\" title=\"部署非 TLS 的 TCP 路由\"></a>部署非 TLS 的 TCP 路由</h3><p>如果有不支持 SNI/TLS 协议的应用客户端，Traefik 也可以部署 “plain TCP”，也就是标准的通过端口进行路由。此时虽然 <code>metch</code> 还是使用 <code>HostSNI</code>，但需要指定为通配符 <code>*</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> traefik.containo.us/v1alpha1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> IngressRouteTCP</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> example</span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  entryPoints:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> web</span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">  - match:</span> HostSNI(`*`)</span><br><span class=\"line\"><span class=\"attr\">    services:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> example-service-name</span><br><span class=\"line\"><span class=\"attr\">      port:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>使用 Traefik 代理 TLS 服务时，backend service 可不设置 TLS 相关，由 Traefik 负责全部相关机制。如果 backend service 有需要加密后的数据时，可通过 <code>passthrough</code> 参数配置，Traefik 将发送加密后的数据给 backend service：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"attr\">  tls:</span> </span><br><span class=\"line\"><span class=\"attr\">    secretName:</span> traefik-tls-certs</span><br><span class=\"line\"><span class=\"attr\">    passthrough:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么不能为-MySQL-代理\"><a href=\"#为什么不能为-MySQL-代理\" class=\"headerlink\" title=\"为什么不能为 MySQL 代理\"></a>为什么不能为 MySQL 代理</h2><p>当我明白 SNI 协议以及 Traefik 如何使用 SNI/TLS 为 TCP 创建路由时，我开始研究为什么 MySQL 不能使用 SNI 扩展，甚至在 2016 年就有人提出过这个问题，但可惜一直没有人跟进：<a href=\"https://bugs.mysql.com/bug.php?id=82872。这让我有些疑惑，毕竟\" target=\"_blank\" rel=\"noopener\">https://bugs.mysql.com/bug.php?id=82872。这让我有些疑惑，毕竟</a> MySQL 已经实现了 TLS 功能，为什么在有用户有需求的情况下不加上 SNI 扩展呢？毕竟这又不是过于复杂的功能。</p>\n<p>在寻找到答案之前，让我们先简单复习下 TLS 协议的标准流程：首先是 TCP 的三次握手，随后开始 TLS 的握手，如果是 TLS1.2 或之前需要四次握手，如果是 TLS1.3 则需要三次握手，最后开始传输加密数据。</p>\n<p>下面来看看 MySQL 的流程，输入命令：<code>mysql -hmysql.example.com -P3306 -uroot -pmysql --ssl-mode=REQUIRED</code>，使用 wireshark 查看：</p>\n<p><em>MySQL 对于 TCP 连接已经默认使用 tls，如果不想使用需要修改参数为 <code>--ssl-mode=DISABLED</code>，同时对于 localhost 默认使用 soket 连接，强制使用 TCP 连接需要增加参数: <code>--protocol tcp</code>。</em></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge97ghpl3ej31ja0u07t9.jpg\" alt=\"mysql\"></p>\n<p>上图中可以看出，在 TCP 握手后，Server 会发送 MySQL 协议 HandShake Paket：<code>Server Greeting proto=10 version=5.7.29</code>，开始 MySQL 协议的握手流程，随后 Client 发送 Auth Paket，图中为开启 TLS 认证的流程，所以并未显示 <code>user</code> 的内容，如果设置 MySQL Client 参数为 <code>--ssl-mode=DISABLED</code>，将显示认证的用户名，并且 Server 会在随后发送 <code>Auth Switch Request</code> 包继续认证流程，此处不再赘述，有兴趣的可以自己抓包看一下。</p>\n<p>看到这里其实就已经很清晰了，MySQL 在连接时会将自定义协议握手流程置于 TLS 协议握手之前，以至于 Traefik 无法通过 TLS SNI 找到对应 backend service，也就无法发送 MySQL 的 HandShake Paket。对于 MySQL Client 来说，如果是有超时机制，会响应 <code>waiting for initial communication packet</code> 或类似的错误，如果没有超时机制，就会一直等待。</p>\n<p>这点对于 Traefik 来说也很无奈，MySQL 自定义协议中也没有 SNI 的机制，而 TLS 又在 MySQL 协议握手之后发生，导致它完全没办法进行路由，只好期望 MySQL 能尽快修改这部分的流程。<a href=\"https://github.com/containous/traefik/issues/5155\" target=\"_blank\" rel=\"noopener\">这里</a>有官方对于这件事的一些回复：<a href=\"https://github.com/containous/traefik/issues/5155\" target=\"_blank\" rel=\"noopener\">https://github.com/containous/traefik/issues/5155</a></p>\n<h2 id=\"其他常见数据库\"><a href=\"#其他常见数据库\" class=\"headerlink\" title=\"其他常见数据库\"></a>其他常见数据库</h2><p>了解到了 MySQL 的问题，不禁让我好奇，其他的常见数据库是否也拥有相同问题，于是我又去看了 MongoDB 和 Redis。</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>使用命令进行连接：<code>mongo --host mongo.example.com --port 27017 --ssl</code></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge98i03x3ej31pq0u0wsp.jpg\" alt=\"mongodb\"></p>\n<p>非常标准的流程，也支持 SNI 扩展，Traefik 可以顺利的进行路由。</p>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p>Redis 从 6.0 开始支持 SSL/TLS，但 6.0 正在处于 RC（Release　Candidate） 阶段，如果想要测试，可以下载代码后自行编译。TLS 特性是个可选特性，需要在编译时使用参数确认使用：<code>make BUILD_TLS=yes</code>。</p>\n<p><em>相关官方文档：<a href=\"https://redis.io/topics/encryption\" target=\"_blank\" rel=\"noopener\">https://redis.io/topics/encryption</a></em></p>\n<p>编译后尝试连接 Traefik 代理的地址：<code>./redis-cli --tls -h testtcp.ohuna.cloud -p 6379</code>，却发现 Traefik 响应了 fatal level error： <code>Unknown CA</code>：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge99xitc2zj31j50u0qlj.jpg\" alt=\"redis\"></p>\n<p>很明显是因为 redis 没有使用 SNI 扩展，但文档中又没有提及，所以我去 redis 源码中寻找答案。在 <code>tls.h</code> 中了解到 redis 使用了 openssl：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> USE_OPENSSL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;openssl/ssl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;openssl/err.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;openssl/rand.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>于是通过 openssl 设置 SNI 的函数 <code>SSL_set_tlsext_host_name</code> 进行查找：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#redis-cli.c</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.sni &amp;&amp; !SSL_set_tlsext_host_name(ssl, config.sni)) &#123;</span><br><span class=\"line\">        *err = <span class=\"string\">\"Failed to configure SNI\"</span>;</span><br><span class=\"line\">        SSL_free(ssl);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> REDIS_ERR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> USE_OPENSSL</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[i],<span class=\"string\">\"--tls\"</span>)) &#123;</span><br><span class=\"line\">            config.tls = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[i],<span class=\"string\">\"--sni\"</span>) &amp;&amp; !lastarg) &#123;</span><br><span class=\"line\">            config.sni = argv[++i];</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>发现可以通过 <code>--sni</code> 参数进行指定，通过 <code>redis-cli --help</code> 能查看到相关说明：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli 5.9.103</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]</span><br><span class=\"line\">......</span><br><span class=\"line\">\t--tls              Establish a secure TLS connection.</span><br><span class=\"line\">  --sni &lt;host&gt;       Server name indication <span class=\"keyword\">for</span> TLS.</span><br></pre></td></tr></table></figure>\n<p>由于粗心大意，导致耽误了时间去寻找 SNI 的设置方法，不过 redis 需要必须手动设置 SNI 的方式也是很奇怪。重新使用带有 <code>--sni</code> 参数的命令进行连接：<code>./redis-cli --tls -h redis.example.com -p 6379 --sni redis.example.com</code>，这次成功连接，查看 TLS ClientHello 中也带有 <code>server_name</code>：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge9amao5j7j31ji0u01a4.jpg\" alt=\"redis-success\"></p>\n<h2 id=\"扩展阅读——ESNI\"><a href=\"#扩展阅读——ESNI\" class=\"headerlink\" title=\"扩展阅读——ESNI\"></a>扩展阅读——ESNI</h2><p>虽然关于 Traefik 与 MySQL 的问题告一段落，但 SNI 本身还有其他可学习的内容。</p>\n<h4 id=\"SNI-的安全问题\"><a href=\"#SNI-的安全问题\" class=\"headerlink\" title=\"SNI 的安全问题\"></a>SNI 的安全问题</h4><p>由于 SNI 扩展是在 TLS 握手期间通过 ClientHello 进行发送，在此时 Client 和 Server 还未共享加密密钥，因此 ClientHello 消息未被加密发送。这就意味着如果有中间人，是可以拦截明文的 ClientHello 消息，并知道 Client 将要访问的网址。</p>\n<h4 id=\"ESNI\"><a href=\"#ESNI\" class=\"headerlink\" title=\"ESNI\"></a>ESNI</h4><p>当前有一项草案正在试图解决这个问题，也就是 <a href=\"https://tools.ietf.org/html/draft-rescorla-tls-esni-00\" target=\"_blank\" rel=\"noopener\">ESNI（Encrypted Server Name Indication）</a>。</p>\n<p>对于加密 SNI 内容这种先有鸡还是先有蛋的问题，ESNI 通过引入 DNS 来解决。服务器在已知的 DNS 记录上发布一个公钥，客户端可以在连接 Server 之前获得该公钥。然后，客户端将 ClientHello 中的 SNI 扩展替换为 ESNI，也就是使用获得的公钥对 SNI 信息对称加密。</p>\n<p>ESNI 必须要基于 TLS1.3 版本，因为 TLS1.3 使用了 Deffie-Hellman 算法进行密钥交换，DH 算法可以使通信的双方能在非安全的信道中安全的交换密钥。否则，就算加密了 SNI，也可以通过明文证书进行验证。</p>\n<p>如果仅仅使用 DNS 也不行，因为 DNS 默认是为加密的，所以需要使用的 DNS 支持 DNS over TLS（DoT）或 DNS over HTTPS（DoH）特性。</p>\n<p><em>简单的学习下 ESNI，更多详细内容可以通过 Cloudflare 的<a href=\"https://blog.cloudflare.com/zh/encrypted-sni-zh/\" target=\"_blank\" rel=\"noopener\">文章</a>或<a href=\"https://tools.ietf.org/html/draft-rescorla-tls-esni-00\" target=\"_blank\" rel=\"noopener\">草案</a>进行了解。</em></p>\n<h2 id=\"参考和致谢\"><a href=\"#参考和致谢\" class=\"headerlink\" title=\"参考和致谢\"></a>参考和致谢</h2><p>学习过程中碰到了诸多问题，幸好互联网上有着众多的学习资料，感谢以下文档与博客：</p>\n<p><a href=\"https://www.qikqiak.com/post/traefik-2.1-101/\" target=\"_blank\" rel=\"noopener\">一文搞懂 Traefik2.1 的使用</a></p>\n<p><a href=\"https://harttle.land/2018/03/25/https-protocols.html\" target=\"_blank\" rel=\"noopener\">HTTPS 交互过程分析</a></p>\n<p><a href=\"https://imququ.com/post/sth-about-switch-to-https-2.html\" target=\"_blank\" rel=\"noopener\">关于启用 HTTPS 的一些经验分享（二）</a></p>\n<p><a href=\"https://halfrost.com/https-extensions/\" target=\"_blank\" rel=\"noopener\">HTTPS 温故知新（六） —— TLS 中的 Extensions</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc6066\" target=\"_blank\" rel=\"noopener\">RFC 6066</a></p>\n<p><a href=\"[https://www.callmejiagu.com/2018/10/26/WireShark-%E5%88%86%E6%9E%90MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/](https://www.callmejiagu.com/2018/10/26/WireShark-分析MySQL网络协议中的数据包（二）/\">实现自己的数据库驱动——WireShark分析MySQL网络协议中的数据包（二）</a>)</p>\n<p><a href=\"https://blog.cloudflare.com/zh/encrypted-sni-zh/\" target=\"_blank\" rel=\"noopener\">不加密，无隐私：加密SNI工作原理</a></p>\n","site":{"data":{}},"excerpt":"<p>Traefik 从 2.0 版本开始支持 TCP route，我也使用 Traefik 作为 kubernetes 集群的 Ingress，但是在使用过程中，发现 Traefik 为 MySQL 创建的 TCP route 无法正常工作，经过排查搜索后发现了官方人员关于这个疑惑的<a href=\"https://community.containo.us/t/v2-tcp-router-with-tls-example/2664\" target=\"_blank\" rel=\"noopener\">解答</a>，以下截取片段：</p>\n<blockquote>\n<p>But be careful: not all protocols based on TCP and using TLS supports the SNI routing or the passthrough. It requires the protocol supporting SNI (for instance MySQL doesn’t) and doing a TLS handshake (if it is a STARTTLS, then it does not work).</p>\n</blockquote>\n<p>虽然找到了问题是由于 MySQL 不支持，但也勾起了我的好奇心，什么是 SNI？Traefik 为什么要使用 <code>HostSNI</code> 创建 TCP route 呢？为什么 MySQL 不支持 SNI 呢？于是带着这些问题，我开始寻找答案。</p>","more":"<h2 id=\"TLS-Extensions-——-SNI\"><a href=\"#TLS-Extensions-——-SNI\" class=\"headerlink\" title=\"TLS Extensions —— SNI\"></a>TLS Extensions —— SNI</h2><p>首先从了解 SNI 开始，SNI 是 TLS 的一个扩展协议。</p>\n<h3 id=\"什么是-TLS-Extensions？\"><a href=\"#什么是-TLS-Extensions？\" class=\"headerlink\" title=\"什么是 TLS Extensions？\"></a>什么是 TLS Extensions？</h3><p>TLS 扩展于 2003 年以一个独立的规范（<a href=\"https://tools.ietf.org/html/rfc3546\" target=\"_blank\" rel=\"noopener\">RFC 3546</a>）被提出，经过不断的发展：<a href=\"https://tools.ietf.org/html/rfc4366\" target=\"_blank\" rel=\"noopener\">RFC 4366</a>、<a href=\"https://tools.ietf.org/html/rfc6066\" target=\"_blank\" rel=\"noopener\">RFC 6066</a> 等，先后被加入到 TLS1.1、TLS1.2、TLS1.3 中。它能让 Client 和 Server 在不更新 TLS 的基础上，获得新的功能。</p>\n<p>Client 在 ClientHello 中声明多个自己可以支持的 Extensions，Server 收到 ClientHello 以后，依次解析 Extensions，有些如果需要立即回应，就在 ServerHello 中作出回应，有些不需要回应，或者 Server 不支持的 Extensions 就不用响应，忽略不处理。</p>\n<p>在 ClientHello 中，Extension 字段位于 Compression Methods 字段之后，通过 Wireshark 工具进行查看：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge84vtby39j31nf0u0wt5.jpg\" alt=\"github-wireshark\"></p>\n<h3 id=\"什么是-SNI-扩展？\"><a href=\"#什么是-SNI-扩展？\" class=\"headerlink\" title=\"什么是 SNI 扩展？\"></a>什么是 SNI 扩展？</h3><p>我们知道，在 Nginx 中可以通过指定不同的 <code>server_name</code> 来配置多个站点。HTTP/1.1 协议请求头中的 <code>Host</code> 字段可以标识出当前请求属于哪个站点。但是在 TLS 协议中，没有提供一种机制来告诉 Server 它正在建立连接的 Server 的名称，那么对于在同一个地址，并且还使用不同证书的情况下，Server 怎么知道该发送哪个证书？</p>\n<p>于是为了解决这个问题，SNI 应运而生。SNI 全称是 Server Name Indication，<a href=\"https://tools.ietf.org/html/rfc3546#page-8\" target=\"_blank\" rel=\"noopener\">最初是 2003 年标准化的</a>，在 <a href=\"https://tools.ietf.org/html/rfc6066#page5\" target=\"_blank\" rel=\"noopener\">RFC 6066</a> 中有更新。它允许 Server 在同一个网络地址上托管多个启用了 TLS 的服务，要求 Client 在初始 TLS 握手期间指定要连接到哪个服务。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  NameType name_type;</span><br><span class=\"line\">  select (name_type) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">case</span> host_name: HostName;</span><br><span class=\"line\">  &#125; name;</span><br><span class=\"line\">&#125; ServerName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">\thost_name(<span class=\"number\">0</span>), (<span class=\"number\">255</span>)</span><br><span class=\"line\">&#125; NameType;</span><br><span class=\"line\"></span><br><span class=\"line\">opaque HostName&lt;<span class=\"number\">1.</span><span class=\"number\">.2</span>^<span class=\"number\">16</span><span class=\"number\">-1</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tServerName server_name_list&lt;<span class=\"number\">1.</span><span class=\"number\">.2</span>^<span class=\"number\">16</span><span class=\"number\">-1</span>&gt;</span><br><span class=\"line\">&#125; ServerNameList;</span><br></pre></td></tr></table></figure>\n<p>Extension type 是 <code>server_name</code>，点开上图 Wireshark 中 <code>server_name</code> 一行，查看更详细信息：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge85t4pu0uj31n80u019m.jpg\" alt=\"server_name\"></p>\n<p><code>ServerNameList</code> 不能包含多个具有相同 <code>ServerNameType</code> 的名称，当前 <code>ServernameType</code> 只有 <code>host_name</code> 一种，在以后可能会添加更多类型，<code>host_name</code> 包含标准的 DNS hostname 且不含结尾点。如果 Server 支持 SNI 扩展，但不能识别 <code>server_name</code>，则应该发送 <code>fatal-level unrecognized_name(112)</code> 来终止握手或继续握手。</p>\n<p><em>更多详细的规范内容可以到 <a href=\"https://tools.ietf.org/html/rfc6066#page5\" target=\"_blank\" rel=\"noopener\">RFC 6066</a> 中查看。<a href=\"https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml\" target=\"_blank\" rel=\"noopener\">这里</a> 有一个扩展协议列表。</em></p>\n<h2 id=\"Traefik-的-TCP-路由与-SNI\"><a href=\"#Traefik-的-TCP-路由与-SNI\" class=\"headerlink\" title=\"Traefik 的 TCP 路由与 SNI\"></a>Traefik 的 TCP 路由与 SNI</h2><p>Traefik 从 2.0 开始支持 TCP 路由，也支持在相同的 <code>entryPoints</code>（traefik 中的入口端口） 中定义不同的 TCP 路由，但是我们都知道，TCP 是传输层协议，没有任何 SNI 类的机制来保证同一地址入口可以处理不同的服务。那么，Traefik 是怎么做的呢？</p>\n<h3 id=\"部署基于-TLS-的-TCP-路由\"><a href=\"#部署基于-TLS-的-TCP-路由\" class=\"headerlink\" title=\"部署基于 TLS 的 TCP 路由\"></a>部署基于 TLS 的 TCP 路由</h3><p>答案很简单，Traefik 支持通过 SNI 在每台主机上进行路由，因为这是通过 TCP 进行路由的惟一标准方法，但是 TCP 本身没有 SNI，因此必须使用 TLS。部署配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> traefik.containo.us/v1alpha1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> IngressRouteTCP</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> example</span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  entryPoints:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> web</span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">  - match:</span> HostSNI(`web.example.com`)</span><br><span class=\"line\"><span class=\"attr\">    services:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> example-service-name</span><br><span class=\"line\"><span class=\"attr\">      port:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attr\">  tls:</span> </span><br><span class=\"line\"><span class=\"attr\">    secretName:</span> traefik-tls-certs</span><br></pre></td></tr></table></figure>\n<p><code>HostSNI</code> 中的值对应 SNI 扩展中 <code>server_name</code> 的值，Traefik 以此来进行路由，并找到对应证书。还需要注意的是 <code>entryPoints</code> 部分由部署的 Traefik 配置中的 <code>entryPoints</code> 参数决定，此处的 <code>web</code> 是我们指定的一个 <code>entryPoints</code> 名称，端口地址对应为 80 端口：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"attr\">- image:</span> traefik:<span class=\"number\">2.1</span><span class=\"number\">.1</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> traefik</span><br><span class=\"line\"><span class=\"attr\">  ports:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> web</span><br><span class=\"line\"><span class=\"attr\">    containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attr\">    hostPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"attr\">  args:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> --entryPoints.web.address=:<span class=\"number\">80</span></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>此处使用 <code>hostPort</code> 的方式暴露入口点，是为了能够通过 Traefik 部署的节点的入口点端口直接访问到 backend service。</p>\n<h3 id=\"部署非-TLS-的-TCP-路由\"><a href=\"#部署非-TLS-的-TCP-路由\" class=\"headerlink\" title=\"部署非 TLS 的 TCP 路由\"></a>部署非 TLS 的 TCP 路由</h3><p>如果有不支持 SNI/TLS 协议的应用客户端，Traefik 也可以部署 “plain TCP”，也就是标准的通过端口进行路由。此时虽然 <code>metch</code> 还是使用 <code>HostSNI</code>，但需要指定为通配符 <code>*</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> traefik.containo.us/v1alpha1</span><br><span class=\"line\"><span class=\"attr\">kind:</span> IngressRouteTCP</span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> example</span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  entryPoints:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> web</span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">  - match:</span> HostSNI(`*`)</span><br><span class=\"line\"><span class=\"attr\">    services:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> example-service-name</span><br><span class=\"line\"><span class=\"attr\">      port:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>使用 Traefik 代理 TLS 服务时，backend service 可不设置 TLS 相关，由 Traefik 负责全部相关机制。如果 backend service 有需要加密后的数据时，可通过 <code>passthrough</code> 参数配置，Traefik 将发送加密后的数据给 backend service：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"attr\">  tls:</span> </span><br><span class=\"line\"><span class=\"attr\">    secretName:</span> traefik-tls-certs</span><br><span class=\"line\"><span class=\"attr\">    passthrough:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么不能为-MySQL-代理\"><a href=\"#为什么不能为-MySQL-代理\" class=\"headerlink\" title=\"为什么不能为 MySQL 代理\"></a>为什么不能为 MySQL 代理</h2><p>当我明白 SNI 协议以及 Traefik 如何使用 SNI/TLS 为 TCP 创建路由时，我开始研究为什么 MySQL 不能使用 SNI 扩展，甚至在 2016 年就有人提出过这个问题，但可惜一直没有人跟进：<a href=\"https://bugs.mysql.com/bug.php?id=82872。这让我有些疑惑，毕竟\" target=\"_blank\" rel=\"noopener\">https://bugs.mysql.com/bug.php?id=82872。这让我有些疑惑，毕竟</a> MySQL 已经实现了 TLS 功能，为什么在有用户有需求的情况下不加上 SNI 扩展呢？毕竟这又不是过于复杂的功能。</p>\n<p>在寻找到答案之前，让我们先简单复习下 TLS 协议的标准流程：首先是 TCP 的三次握手，随后开始 TLS 的握手，如果是 TLS1.2 或之前需要四次握手，如果是 TLS1.3 则需要三次握手，最后开始传输加密数据。</p>\n<p>下面来看看 MySQL 的流程，输入命令：<code>mysql -hmysql.example.com -P3306 -uroot -pmysql --ssl-mode=REQUIRED</code>，使用 wireshark 查看：</p>\n<p><em>MySQL 对于 TCP 连接已经默认使用 tls，如果不想使用需要修改参数为 <code>--ssl-mode=DISABLED</code>，同时对于 localhost 默认使用 soket 连接，强制使用 TCP 连接需要增加参数: <code>--protocol tcp</code>。</em></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge97ghpl3ej31ja0u07t9.jpg\" alt=\"mysql\"></p>\n<p>上图中可以看出，在 TCP 握手后，Server 会发送 MySQL 协议 HandShake Paket：<code>Server Greeting proto=10 version=5.7.29</code>，开始 MySQL 协议的握手流程，随后 Client 发送 Auth Paket，图中为开启 TLS 认证的流程，所以并未显示 <code>user</code> 的内容，如果设置 MySQL Client 参数为 <code>--ssl-mode=DISABLED</code>，将显示认证的用户名，并且 Server 会在随后发送 <code>Auth Switch Request</code> 包继续认证流程，此处不再赘述，有兴趣的可以自己抓包看一下。</p>\n<p>看到这里其实就已经很清晰了，MySQL 在连接时会将自定义协议握手流程置于 TLS 协议握手之前，以至于 Traefik 无法通过 TLS SNI 找到对应 backend service，也就无法发送 MySQL 的 HandShake Paket。对于 MySQL Client 来说，如果是有超时机制，会响应 <code>waiting for initial communication packet</code> 或类似的错误，如果没有超时机制，就会一直等待。</p>\n<p>这点对于 Traefik 来说也很无奈，MySQL 自定义协议中也没有 SNI 的机制，而 TLS 又在 MySQL 协议握手之后发生，导致它完全没办法进行路由，只好期望 MySQL 能尽快修改这部分的流程。<a href=\"https://github.com/containous/traefik/issues/5155\" target=\"_blank\" rel=\"noopener\">这里</a>有官方对于这件事的一些回复：<a href=\"https://github.com/containous/traefik/issues/5155\" target=\"_blank\" rel=\"noopener\">https://github.com/containous/traefik/issues/5155</a></p>\n<h2 id=\"其他常见数据库\"><a href=\"#其他常见数据库\" class=\"headerlink\" title=\"其他常见数据库\"></a>其他常见数据库</h2><p>了解到了 MySQL 的问题，不禁让我好奇，其他的常见数据库是否也拥有相同问题，于是我又去看了 MongoDB 和 Redis。</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>使用命令进行连接：<code>mongo --host mongo.example.com --port 27017 --ssl</code></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge98i03x3ej31pq0u0wsp.jpg\" alt=\"mongodb\"></p>\n<p>非常标准的流程，也支持 SNI 扩展，Traefik 可以顺利的进行路由。</p>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p>Redis 从 6.0 开始支持 SSL/TLS，但 6.0 正在处于 RC（Release　Candidate） 阶段，如果想要测试，可以下载代码后自行编译。TLS 特性是个可选特性，需要在编译时使用参数确认使用：<code>make BUILD_TLS=yes</code>。</p>\n<p><em>相关官方文档：<a href=\"https://redis.io/topics/encryption\" target=\"_blank\" rel=\"noopener\">https://redis.io/topics/encryption</a></em></p>\n<p>编译后尝试连接 Traefik 代理的地址：<code>./redis-cli --tls -h testtcp.ohuna.cloud -p 6379</code>，却发现 Traefik 响应了 fatal level error： <code>Unknown CA</code>：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge99xitc2zj31j50u0qlj.jpg\" alt=\"redis\"></p>\n<p>很明显是因为 redis 没有使用 SNI 扩展，但文档中又没有提及，所以我去 redis 源码中寻找答案。在 <code>tls.h</code> 中了解到 redis 使用了 openssl：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> USE_OPENSSL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;openssl/ssl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;openssl/err.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;openssl/rand.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>于是通过 openssl 设置 SNI 的函数 <code>SSL_set_tlsext_host_name</code> 进行查找：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#redis-cli.c</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.sni &amp;&amp; !SSL_set_tlsext_host_name(ssl, config.sni)) &#123;</span><br><span class=\"line\">        *err = <span class=\"string\">\"Failed to configure SNI\"</span>;</span><br><span class=\"line\">        SSL_free(ssl);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> REDIS_ERR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> USE_OPENSSL</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[i],<span class=\"string\">\"--tls\"</span>)) &#123;</span><br><span class=\"line\">            config.tls = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[i],<span class=\"string\">\"--sni\"</span>) &amp;&amp; !lastarg) &#123;</span><br><span class=\"line\">            config.sni = argv[++i];</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>发现可以通过 <code>--sni</code> 参数进行指定，通过 <code>redis-cli --help</code> 能查看到相关说明：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli 5.9.103</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]</span><br><span class=\"line\">......</span><br><span class=\"line\">\t--tls              Establish a secure TLS connection.</span><br><span class=\"line\">  --sni &lt;host&gt;       Server name indication <span class=\"keyword\">for</span> TLS.</span><br></pre></td></tr></table></figure>\n<p>由于粗心大意，导致耽误了时间去寻找 SNI 的设置方法，不过 redis 需要必须手动设置 SNI 的方式也是很奇怪。重新使用带有 <code>--sni</code> 参数的命令进行连接：<code>./redis-cli --tls -h redis.example.com -p 6379 --sni redis.example.com</code>，这次成功连接，查看 TLS ClientHello 中也带有 <code>server_name</code>：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge9amao5j7j31ji0u01a4.jpg\" alt=\"redis-success\"></p>\n<h2 id=\"扩展阅读——ESNI\"><a href=\"#扩展阅读——ESNI\" class=\"headerlink\" title=\"扩展阅读——ESNI\"></a>扩展阅读——ESNI</h2><p>虽然关于 Traefik 与 MySQL 的问题告一段落，但 SNI 本身还有其他可学习的内容。</p>\n<h4 id=\"SNI-的安全问题\"><a href=\"#SNI-的安全问题\" class=\"headerlink\" title=\"SNI 的安全问题\"></a>SNI 的安全问题</h4><p>由于 SNI 扩展是在 TLS 握手期间通过 ClientHello 进行发送，在此时 Client 和 Server 还未共享加密密钥，因此 ClientHello 消息未被加密发送。这就意味着如果有中间人，是可以拦截明文的 ClientHello 消息，并知道 Client 将要访问的网址。</p>\n<h4 id=\"ESNI\"><a href=\"#ESNI\" class=\"headerlink\" title=\"ESNI\"></a>ESNI</h4><p>当前有一项草案正在试图解决这个问题，也就是 <a href=\"https://tools.ietf.org/html/draft-rescorla-tls-esni-00\" target=\"_blank\" rel=\"noopener\">ESNI（Encrypted Server Name Indication）</a>。</p>\n<p>对于加密 SNI 内容这种先有鸡还是先有蛋的问题，ESNI 通过引入 DNS 来解决。服务器在已知的 DNS 记录上发布一个公钥，客户端可以在连接 Server 之前获得该公钥。然后，客户端将 ClientHello 中的 SNI 扩展替换为 ESNI，也就是使用获得的公钥对 SNI 信息对称加密。</p>\n<p>ESNI 必须要基于 TLS1.3 版本，因为 TLS1.3 使用了 Deffie-Hellman 算法进行密钥交换，DH 算法可以使通信的双方能在非安全的信道中安全的交换密钥。否则，就算加密了 SNI，也可以通过明文证书进行验证。</p>\n<p>如果仅仅使用 DNS 也不行，因为 DNS 默认是为加密的，所以需要使用的 DNS 支持 DNS over TLS（DoT）或 DNS over HTTPS（DoH）特性。</p>\n<p><em>简单的学习下 ESNI，更多详细内容可以通过 Cloudflare 的<a href=\"https://blog.cloudflare.com/zh/encrypted-sni-zh/\" target=\"_blank\" rel=\"noopener\">文章</a>或<a href=\"https://tools.ietf.org/html/draft-rescorla-tls-esni-00\" target=\"_blank\" rel=\"noopener\">草案</a>进行了解。</em></p>\n<h2 id=\"参考和致谢\"><a href=\"#参考和致谢\" class=\"headerlink\" title=\"参考和致谢\"></a>参考和致谢</h2><p>学习过程中碰到了诸多问题，幸好互联网上有着众多的学习资料，感谢以下文档与博客：</p>\n<p><a href=\"https://www.qikqiak.com/post/traefik-2.1-101/\" target=\"_blank\" rel=\"noopener\">一文搞懂 Traefik2.1 的使用</a></p>\n<p><a href=\"https://harttle.land/2018/03/25/https-protocols.html\" target=\"_blank\" rel=\"noopener\">HTTPS 交互过程分析</a></p>\n<p><a href=\"https://imququ.com/post/sth-about-switch-to-https-2.html\" target=\"_blank\" rel=\"noopener\">关于启用 HTTPS 的一些经验分享（二）</a></p>\n<p><a href=\"https://halfrost.com/https-extensions/\" target=\"_blank\" rel=\"noopener\">HTTPS 温故知新（六） —— TLS 中的 Extensions</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc6066\" target=\"_blank\" rel=\"noopener\">RFC 6066</a></p>\n<p><a href=\"[https://www.callmejiagu.com/2018/10/26/WireShark-%E5%88%86%E6%9E%90MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/](https://www.callmejiagu.com/2018/10/26/WireShark-分析MySQL网络协议中的数据包（二）/\">实现自己的数据库驱动——WireShark分析MySQL网络协议中的数据包（二）</a>)</p>\n<p><a href=\"https://blog.cloudflare.com/zh/encrypted-sni-zh/\" target=\"_blank\" rel=\"noopener\">不加密，无隐私：加密SNI工作原理</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}