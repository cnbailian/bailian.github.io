{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/Api安全研究.md","hash":"d4ea08bf1fb8f2947a5b7a90866cf948b625dc8e","modified":1545642477650},{"_id":"source/about/index.md","hash":"5f21b142563daf3c12cb86a2caf13d655f7c7a09","modified":1545642477655},{"_id":"source/_posts/JSON Schema.md","hash":"510de13efd2ebdb759d27824b720e1f94ca15a99","modified":1560149637900},{"_id":"source/_posts/JWT 与 OAuth 2.0.md","hash":"b483b80ef5462756ec3463063ee80c2ef85102ea","modified":1545642477653},{"_id":"source/_posts/RESTful缓存方案.md","hash":"b30dd6df21d9ab9eee31dc871cabeb874b7118f7","modified":1545642477654},{"_id":"source/_posts/chromeBox 大纲.dat","hash":"26d44ea5427717e9a087f0fb0e1c761b9ce8ce9a","modified":1545642477654},{"_id":"source/_posts/hypertext-driven.md","hash":"7c47b00bad71c25116dc9f01a5d65d60ea89e85b","modified":1545642477654},{"_id":"source/_posts/session and JWT.md","hash":"56ac04d78acbb0948a3941f3225589f1d535f697","modified":1545642477655},{"_id":"source/_posts/tpshop代码审计--续.dat","hash":"a364ec4317bbbf9bd2e355726344e0d9335de13c","modified":1545642477655},{"_id":"source/_posts/tpshop代码审计.dat","hash":"c6b836d318b4d08b294f94135262b27946d7959b","modified":1545642477655},{"_id":"source/archive/index.md","hash":"fc18302dc4b2a347ac7969bab93eda360f3b7bd3","modified":1545642477656},{"_id":"source/links/index.md","hash":"49e30f19d6276ac9f7ddd5956d05c854ae37d99a","modified":1545642477656},{"_id":"source/resume/index.md","hash":"c725e2562527c21166422f47aa74b4b363054e42","modified":1545642477656},{"_id":"source/tags/index.md","hash":"35867ca3284afb0c225bd922f41386fd8b21d8e8","modified":1545642477656},{"_id":"source/_posts/RESTful API 实践.md","hash":"3382658902611a004b85a58ba43e46a153ff63e2","modified":1545642477654},{"_id":"public/atom.xml","hash":"d644e373698557571e6714c88fbea7ec6cf20f65","modified":1560150213704},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213707},{"_id":"public/archive/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213707},{"_id":"public/links/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213707},{"_id":"public/resume/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213707},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213707},{"_id":"public/2018/12/RESTful缓存方案/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213707},{"_id":"public/2018/12/hypertext-driven/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/2018/12/session and JWT/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/2018/12/JSON Schema/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/2018/12/JWT 与 OAuth 2.0/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/2018/12/Api安全研究/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/archives/2018/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213708},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213709},{"_id":"public/2018/12/RESTful API 实践/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560150213711}],"Category":[],"Data":[],"Page":[{"title":"关于我","layout":"about","_content":"\n<!-- 这里写你的简介 -->\n\n普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程\n\n代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客\n\n博客用的Hexo + gihub，主题是https://github.com/imochen/hexo-theme-meizi\n\n<!-- 本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。\n\n最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。 -->\n","source":"about/index.md","raw":"title: \"关于我\"\nlayout: \"about\"\n---\n\n<!-- 这里写你的简介 -->\n\n普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程\n\n代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客\n\n博客用的Hexo + gihub，主题是https://github.com/imochen/hexo-theme-meizi\n\n<!-- 本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。\n\n最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。 -->\n","date":"2018-12-24T09:07:57.655Z","updated":"2018-12-24T09:07:57.655Z","path":"about/index.html","comments":1,"_id":"cjwq15l610001ki79vs929xyu","content":"<!-- 这里写你的简介 -->\n<p>普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程</p>\n<p>代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客</p>\n<p>博客用的Hexo + gihub，主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\" target=\"_blank\" rel=\"external\">https://github.com/imochen/hexo-theme-meizi</a></p>\n<!-- 本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。\n\n最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。 -->\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的简介 -->\n<p>普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程</p>\n<p>代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客</p>\n<p>博客用的Hexo + gihub，主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\" target=\"_blank\" rel=\"external\">https://github.com/imochen/hexo-theme-meizi</a></p>\n<!-- 本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。\n\n最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。 -->\n"},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"title: \"归档\"\nlayout: \"all-archives\"\n---","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"archive/index.html","comments":1,"_id":"cjwq15l660007ki798pf90zyd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"友情链接","layout":"links","_content":"\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","source":"links/index.md","raw":"title: \"友情链接\"\nlayout: \"links\"\n---\n\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"links/index.html","comments":1,"_id":"cjwq15l670008ki79ifkuu5ji","content":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"external\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"external\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n"},{"title":"简历","layout":"resume","_content":"\n**个人信息**\n\n* 姓名：白联\n* 年龄：22\n* 工作经验：2年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 期望职位：PHP程序员\n* 期望薪资：10k\n* 工作状态：在职\n\n**联系方式**\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n**工作经历**\n\n* 中普互联网金融-信息技术部（2016-6 ~ 2017-9）\n  * 主要项目1：\n    * 中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。\n    * 问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。\n  * 主要项目2：\n    * 中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen\n    * 问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。\n    * 解决：我将解决方案整理了一篇 RESTful API 的实践博文（https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\n  * 主要项目3：\n    * 友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。\n    * 问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。\n    * 解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。\n\n* 沈阳星乐科技（2016-01 ~ 2016-06）\n\n* 沈阳谊来网络科技（2015-07 ~ 2015-12）\n\n**技术能力**\n\n* 熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。\n* 单元测试：PHPUnit。\n* 开发环境：Docker（目前在用） & Vagrant（docker之前用）\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解 Python，Go。\n* 熟悉 HTTP 协议、REST、Web API。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n\n**技术文章**\n\n* 《超媒体驱动的 Web API》 https://cnbailian.github.io/2017/10/hypertext-driven/\n* 《Session 与 JWT》 https://cnbailian.github.io/2017/10/session%20and%20JWT/\n* 《RESTful API 实践》 https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\n\n**技术演讲**\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n**个人评价**\n\n个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。\n\n擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。\n\n**致谢**\n\n感谢您的阅读，期待有机会能与您共事。\n","source":"resume/index.md","raw":"title: \"简历\"\nlayout: \"resume\"\n---\n\n**个人信息**\n\n* 姓名：白联\n* 年龄：22\n* 工作经验：2年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 期望职位：PHP程序员\n* 期望薪资：10k\n* 工作状态：在职\n\n**联系方式**\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n**工作经历**\n\n* 中普互联网金融-信息技术部（2016-6 ~ 2017-9）\n  * 主要项目1：\n    * 中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。\n    * 问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。\n  * 主要项目2：\n    * 中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen\n    * 问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。\n    * 解决：我将解决方案整理了一篇 RESTful API 的实践博文（https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\n  * 主要项目3：\n    * 友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。\n    * 问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。\n    * 解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。\n\n* 沈阳星乐科技（2016-01 ~ 2016-06）\n\n* 沈阳谊来网络科技（2015-07 ~ 2015-12）\n\n**技术能力**\n\n* 熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。\n* 单元测试：PHPUnit。\n* 开发环境：Docker（目前在用） & Vagrant（docker之前用）\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解 Python，Go。\n* 熟悉 HTTP 协议、REST、Web API。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n\n**技术文章**\n\n* 《超媒体驱动的 Web API》 https://cnbailian.github.io/2017/10/hypertext-driven/\n* 《Session 与 JWT》 https://cnbailian.github.io/2017/10/session%20and%20JWT/\n* 《RESTful API 实践》 https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\n\n**技术演讲**\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n**个人评价**\n\n个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。\n\n擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。\n\n**致谢**\n\n感谢您的阅读，期待有机会能与您共事。\n","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"resume/index.html","comments":1,"_id":"cjwq15l670009ki79s4rlu3qn","content":"<p><strong>个人信息</strong></p>\n<ul>\n<li>姓名：白联</li>\n<li>年龄：22</li>\n<li>工作经验：2年</li>\n<li>技术博客：<a href=\"https://cnbailian.github.io/\">https://cnbailian.github.io/</a></li>\n<li>GitHub：<a href=\"https://github.com/cnbailian\" target=\"_blank\" rel=\"external\">https://github.com/cnbailian</a></li>\n<li>期望职位：PHP程序员</li>\n<li>期望薪资：10k</li>\n<li>工作状态：在职</li>\n</ul>\n<p><strong>联系方式</strong></p>\n<ul>\n<li>手机号：15142556834</li>\n<li>邮箱：captainbailian@gmail.com</li>\n</ul>\n<p><strong>工作经历</strong></p>\n<ul>\n<li><p>中普互联网金融-信息技术部（2016-6 ~ 2017-9）</p>\n<ul>\n<li>主要项目1：<ul>\n<li>中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。</li>\n<li>问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。</li>\n</ul>\n</li>\n<li>主要项目2：<ul>\n<li>中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen</li>\n<li>问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。</li>\n<li>解决：我将解决方案整理了一篇 RESTful API 的实践博文（<a href=\"https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\">https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）</a></li>\n</ul>\n</li>\n<li>主要项目3：<ul>\n<li>友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。</li>\n<li>问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。</li>\n<li>解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>沈阳星乐科技（2016-01 ~ 2016-06）</p>\n</li>\n<li><p>沈阳谊来网络科技（2015-07 ~ 2015-12）</p>\n</li>\n</ul>\n<p><strong>技术能力</strong></p>\n<ul>\n<li>熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。</li>\n<li>单元测试：PHPUnit。</li>\n<li>开发环境：Docker（目前在用） &amp; Vagrant（docker之前用）</li>\n<li>熟悉前端技术：JS、CSS、HTML、VueJS。</li>\n<li>了解 Python，Go。</li>\n<li>熟悉 HTTP 协议、REST、Web API。</li>\n<li>了解 Chrome 扩展开发。</li>\n<li>熟悉 MySQL，基本数据库设计。</li>\n<li>熟悉 Linux 系统基本操作。</li>\n</ul>\n<p><strong>技术文章</strong></p>\n<ul>\n<li>《超媒体驱动的 Web API》 <a href=\"https://cnbailian.github.io/2017/10/hypertext-driven/\">https://cnbailian.github.io/2017/10/hypertext-driven/</a></li>\n<li>《Session 与 JWT》 <a href=\"https://cnbailian.github.io/2017/10/session%20and%20JWT/\">https://cnbailian.github.io/2017/10/session%20and%20JWT/</a></li>\n<li>《RESTful API 实践》 <a href=\"https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\">https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/</a></li>\n</ul>\n<p><strong>技术演讲</strong></p>\n<ul>\n<li>公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。</li>\n</ul>\n<p><strong>个人评价</strong></p>\n<p>个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。</p>\n<p>擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。</p>\n<p><strong>致谢</strong></p>\n<p>感谢您的阅读，期待有机会能与您共事。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>个人信息</strong></p>\n<ul>\n<li>姓名：白联</li>\n<li>年龄：22</li>\n<li>工作经验：2年</li>\n<li>技术博客：<a href=\"https://cnbailian.github.io/\">https://cnbailian.github.io/</a></li>\n<li>GitHub：<a href=\"https://github.com/cnbailian\" target=\"_blank\" rel=\"external\">https://github.com/cnbailian</a></li>\n<li>期望职位：PHP程序员</li>\n<li>期望薪资：10k</li>\n<li>工作状态：在职</li>\n</ul>\n<p><strong>联系方式</strong></p>\n<ul>\n<li>手机号：15142556834</li>\n<li>邮箱：captainbailian@gmail.com</li>\n</ul>\n<p><strong>工作经历</strong></p>\n<ul>\n<li><p>中普互联网金融-信息技术部（2016-6 ~ 2017-9）</p>\n<ul>\n<li>主要项目1：<ul>\n<li>中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。</li>\n<li>问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。</li>\n</ul>\n</li>\n<li>主要项目2：<ul>\n<li>中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen</li>\n<li>问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。</li>\n<li>解决：我将解决方案整理了一篇 RESTful API 的实践博文（<a href=\"https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\">https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）</a></li>\n</ul>\n</li>\n<li>主要项目3：<ul>\n<li>友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。</li>\n<li>问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。</li>\n<li>解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>沈阳星乐科技（2016-01 ~ 2016-06）</p>\n</li>\n<li><p>沈阳谊来网络科技（2015-07 ~ 2015-12）</p>\n</li>\n</ul>\n<p><strong>技术能力</strong></p>\n<ul>\n<li>熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。</li>\n<li>单元测试：PHPUnit。</li>\n<li>开发环境：Docker（目前在用） &amp; Vagrant（docker之前用）</li>\n<li>熟悉前端技术：JS、CSS、HTML、VueJS。</li>\n<li>了解 Python，Go。</li>\n<li>熟悉 HTTP 协议、REST、Web API。</li>\n<li>了解 Chrome 扩展开发。</li>\n<li>熟悉 MySQL，基本数据库设计。</li>\n<li>熟悉 Linux 系统基本操作。</li>\n</ul>\n<p><strong>技术文章</strong></p>\n<ul>\n<li>《超媒体驱动的 Web API》 <a href=\"https://cnbailian.github.io/2017/10/hypertext-driven/\">https://cnbailian.github.io/2017/10/hypertext-driven/</a></li>\n<li>《Session 与 JWT》 <a href=\"https://cnbailian.github.io/2017/10/session%20and%20JWT/\">https://cnbailian.github.io/2017/10/session%20and%20JWT/</a></li>\n<li>《RESTful API 实践》 <a href=\"https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\">https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/</a></li>\n</ul>\n<p><strong>技术演讲</strong></p>\n<ul>\n<li>公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。</li>\n</ul>\n<p><strong>个人评价</strong></p>\n<p>个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。</p>\n<p>擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。</p>\n<p><strong>致谢</strong></p>\n<p>感谢您的阅读，期待有机会能与您共事。</p>\n"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"tags/index.html","comments":1,"_id":"cjwq15l67000aki79t5c1t04y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Api安全 研究","_content":"\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","source":"_posts/Api安全研究.md","raw":"---\ntitle: Api安全 研究\n---\n\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","slug":"Api安全研究","published":1,"date":"2018-12-24T09:07:57.649Z","updated":"2018-12-24T09:07:57.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l5l0000ki79p378gmpv","content":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>\n<a id=\"more\"></a>  \n<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>","more":"<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>"},{"title":"JSON Schema","_content":"\n**JSON Schema 详解：未完待续**\n\n<!--more-->  \n\n## 第一篇：了解 JSON\n\n#### 介绍\n\nJSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《[Standard ECMA-262 3rd Edition - December 1999](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)》的一个子集，而后成为写入 RFC 文档：[RFC 4627](https://tools.ietf.org/html/rfc4627)，最新的 RFC 标准为：[RFC 8259](https://tools.ietf.org/html/rfc8259)。\n\nJSON 的官方 MIME 类型是 `application/json`，文件扩展名是 `.json`。\n\n#### 类型\n\n**两种结构化类型**：\n\n* Object：`名称/值`的集合（A collection of name/value pairs），在不同的语言中，被理解为 `object`，`record`，`struct`，`dictionary`，`hash table` 等等。\n    * 使用大括号`{`，`}`包裹`名称/值`的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用`:`分隔。`名称/值`之间使用`,`分隔。\n    * 格式示例：`{\"example\":\"string\"}`。\n* Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 `array`。\n    * 使用中括号`[`，`]`包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。\n    * 格式示例：`[0,\"1\",null,false,true,{},[]]`。\n\n**四种基本类型**：\n\n* 字符串（string）\n    * 字符串是 Unicode 字符组成的集合，使用双引号包裹（`\"`），反斜杠转义（`\\`）。\n    * 与 C 或 Java 的字符串相似。\n* 数值（number）\n    * 使用十进制，可以为负数或者小数。还可以用`e`或者`E`表示为指数形式。\n    * 数值也与 C 或 Java 的数值相似。\n* 布尔（boolean）\n    * `true` 或 `false`。\n* 空（null）\n    * `null`。\n\n**Tips**：\n\n* 值的是可以嵌套的。\n* 名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。\n* 符号中间允许空白字符。\n* JSON 没有限制必须以 `object` 或结构类型作为顶层类型。\n* 但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 `object` 作为顶层类型。\n* 上述的集合或列表（string，object，array）可以是空集或空列。\n\n#### 示例\n\n```\n# Object\n{\n    \"Image\": {\n        \"Width\":  800,\n        \"Height\": 600,\n        \"Title\":  \"View from 15th Floor\",\n        \"Thumbnail\": {\n            \"Url\":    \"http://www.example.com/image/481989943\",\n            \"Height\": 125,\n            \"Width\":  100\n        },\n        \"Animated\" : false,\n        \"IDs\": [116, 943, 234, 38793]\n    }\n}\n\n# Array\n[\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.7668,\n        \"Longitude\": -122.3959,\n        \"Address\":   \"\",\n        \"City\":      \"SAN FRANCISCO\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94107\",\n        \"Country\":   \"US\"\n    },\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.371991,\n        \"Longitude\": -122.026020,\n        \"Address\":   \"\",\n        \"City\":      \"SUNNYVALE\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94085\",\n        \"Country\":   \"US\"\n    }\n]\n\n# Only values\n\n\"Hello world!\"\n\n42\n\ntrue\n\nnull\n```\n\n## 第二篇：介绍\n\n#### 版本\n\n当前版本：[draft-07](http://json-schema.org/specification.html)。\n\n#### 简介\n\nJSON Schema 是一个用于**注释**和**验证** JSON documents 的词汇表。\n\nJSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。\n\n#### 用途\n\n* 对数据结构进行描述\n* 构建人机可读的文档\n* 校验数据\n\n#### 项目状态\n\n共有三个规范：\n\n* [JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n* [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/)\n* [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/)\n\n项目组正在努力使它们成为正式的 RFC 标准。\n\n*[draft-08](https://github.com/json-schema-org/json-schema-spec/milestone/6)*\n\n#### 如何应用\n\n可以用于生成模拟数据，确保接近真实数据。\n\n用于校验数据，实现自动化测试。\n\n多端共用同一份验证。\n\n## 第三篇：Core 规范\n\n#### 简介\n\n[JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n\n此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。\n\n#### 状态\n\n草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：[https://datatracker.ietf.org/doc/draft-handrews-json-schema/](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)。\n\n#### 概述\n\n**媒体类型**\n\nJSON 的媒体类型：[application/json](https://tools.ietf.org/html/rfc8259#section-1.2) 。\n\nJSON Schema 的媒体类型为 `application/schema+json`，它还有另外一种可选媒体类型用于提供额外的扩展功能：`application/schema-instance+json`。\n\n**验证**\n\nJSON Schema 描述了 `JSON 文档(JSON document)` 的结构，例如属性、长度限制等，程序可以以此判断 `实例(Instance)` 是否符合规范。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**注释**\n\nJSON Schema 可以对 `实例(Instance)` 添加注释。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**超媒体与链接**\n\nJSON Hyper-Schema 描述了  `JSON 文档(JSON document)` 的超文本结构，包括 `实例(Instance)` 中的资源链接关系等。\n\n规范与关键字在 [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/) 中定义。\n\n#### 定义\n\n**JSON Document**\n\n`JSON 文档(JSON document)` 是使用 `application/json` 媒体类型描述的资源。\n\n简言之就是 JSON 值。\n\n*JSON Schema 中， `JSON 值(JSON value)`、`JSON 文本(JSON text)`、`JSON 文档(JSON document)`是等义词。*\n\n*JSON Schema 也是 `JSON 文档(JSON document)`。*\n\n**Instance**\n\n`实例(Instance)` 是使用 JSON Schema 描述的 `JSON 文档(JSON document)`。\n\n**JSON Schema document**\n\n使用 `application/schema+json` 媒体类型描述的 `JSON 文档(JSON document)`，简称 schema。\n\n#### 关键字\n\n**$schema**\n\n`$schema` 关键字用于声明当前 `JSON 文档(JSON document)` 是 `JSON Schema document`。\n\n值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$id**\n\n`$id` 关键字用于定义 schema 基本的 URI，可用于 `$ref` 的引用标识，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$ref**\n\n`$ref` 关键字用于定义引用 schema，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\nURI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。\n\n如果有两个 schema 互相使用 `$ref` 进行引用，不应该陷入无限循环。\n\n**$comment**\n\n`$comment` 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。","source":"_posts/JSON Schema.md","raw":"---\ntitle: JSON Schema\n---\n\n**JSON Schema 详解：未完待续**\n\n<!--more-->  \n\n## 第一篇：了解 JSON\n\n#### 介绍\n\nJSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《[Standard ECMA-262 3rd Edition - December 1999](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)》的一个子集，而后成为写入 RFC 文档：[RFC 4627](https://tools.ietf.org/html/rfc4627)，最新的 RFC 标准为：[RFC 8259](https://tools.ietf.org/html/rfc8259)。\n\nJSON 的官方 MIME 类型是 `application/json`，文件扩展名是 `.json`。\n\n#### 类型\n\n**两种结构化类型**：\n\n* Object：`名称/值`的集合（A collection of name/value pairs），在不同的语言中，被理解为 `object`，`record`，`struct`，`dictionary`，`hash table` 等等。\n    * 使用大括号`{`，`}`包裹`名称/值`的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用`:`分隔。`名称/值`之间使用`,`分隔。\n    * 格式示例：`{\"example\":\"string\"}`。\n* Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 `array`。\n    * 使用中括号`[`，`]`包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。\n    * 格式示例：`[0,\"1\",null,false,true,{},[]]`。\n\n**四种基本类型**：\n\n* 字符串（string）\n    * 字符串是 Unicode 字符组成的集合，使用双引号包裹（`\"`），反斜杠转义（`\\`）。\n    * 与 C 或 Java 的字符串相似。\n* 数值（number）\n    * 使用十进制，可以为负数或者小数。还可以用`e`或者`E`表示为指数形式。\n    * 数值也与 C 或 Java 的数值相似。\n* 布尔（boolean）\n    * `true` 或 `false`。\n* 空（null）\n    * `null`。\n\n**Tips**：\n\n* 值的是可以嵌套的。\n* 名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。\n* 符号中间允许空白字符。\n* JSON 没有限制必须以 `object` 或结构类型作为顶层类型。\n* 但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 `object` 作为顶层类型。\n* 上述的集合或列表（string，object，array）可以是空集或空列。\n\n#### 示例\n\n```\n# Object\n{\n    \"Image\": {\n        \"Width\":  800,\n        \"Height\": 600,\n        \"Title\":  \"View from 15th Floor\",\n        \"Thumbnail\": {\n            \"Url\":    \"http://www.example.com/image/481989943\",\n            \"Height\": 125,\n            \"Width\":  100\n        },\n        \"Animated\" : false,\n        \"IDs\": [116, 943, 234, 38793]\n    }\n}\n\n# Array\n[\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.7668,\n        \"Longitude\": -122.3959,\n        \"Address\":   \"\",\n        \"City\":      \"SAN FRANCISCO\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94107\",\n        \"Country\":   \"US\"\n    },\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.371991,\n        \"Longitude\": -122.026020,\n        \"Address\":   \"\",\n        \"City\":      \"SUNNYVALE\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94085\",\n        \"Country\":   \"US\"\n    }\n]\n\n# Only values\n\n\"Hello world!\"\n\n42\n\ntrue\n\nnull\n```\n\n## 第二篇：介绍\n\n#### 版本\n\n当前版本：[draft-07](http://json-schema.org/specification.html)。\n\n#### 简介\n\nJSON Schema 是一个用于**注释**和**验证** JSON documents 的词汇表。\n\nJSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。\n\n#### 用途\n\n* 对数据结构进行描述\n* 构建人机可读的文档\n* 校验数据\n\n#### 项目状态\n\n共有三个规范：\n\n* [JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n* [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/)\n* [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/)\n\n项目组正在努力使它们成为正式的 RFC 标准。\n\n*[draft-08](https://github.com/json-schema-org/json-schema-spec/milestone/6)*\n\n#### 如何应用\n\n可以用于生成模拟数据，确保接近真实数据。\n\n用于校验数据，实现自动化测试。\n\n多端共用同一份验证。\n\n## 第三篇：Core 规范\n\n#### 简介\n\n[JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n\n此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。\n\n#### 状态\n\n草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：[https://datatracker.ietf.org/doc/draft-handrews-json-schema/](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)。\n\n#### 概述\n\n**媒体类型**\n\nJSON 的媒体类型：[application/json](https://tools.ietf.org/html/rfc8259#section-1.2) 。\n\nJSON Schema 的媒体类型为 `application/schema+json`，它还有另外一种可选媒体类型用于提供额外的扩展功能：`application/schema-instance+json`。\n\n**验证**\n\nJSON Schema 描述了 `JSON 文档(JSON document)` 的结构，例如属性、长度限制等，程序可以以此判断 `实例(Instance)` 是否符合规范。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**注释**\n\nJSON Schema 可以对 `实例(Instance)` 添加注释。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**超媒体与链接**\n\nJSON Hyper-Schema 描述了  `JSON 文档(JSON document)` 的超文本结构，包括 `实例(Instance)` 中的资源链接关系等。\n\n规范与关键字在 [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/) 中定义。\n\n#### 定义\n\n**JSON Document**\n\n`JSON 文档(JSON document)` 是使用 `application/json` 媒体类型描述的资源。\n\n简言之就是 JSON 值。\n\n*JSON Schema 中， `JSON 值(JSON value)`、`JSON 文本(JSON text)`、`JSON 文档(JSON document)`是等义词。*\n\n*JSON Schema 也是 `JSON 文档(JSON document)`。*\n\n**Instance**\n\n`实例(Instance)` 是使用 JSON Schema 描述的 `JSON 文档(JSON document)`。\n\n**JSON Schema document**\n\n使用 `application/schema+json` 媒体类型描述的 `JSON 文档(JSON document)`，简称 schema。\n\n#### 关键字\n\n**$schema**\n\n`$schema` 关键字用于声明当前 `JSON 文档(JSON document)` 是 `JSON Schema document`。\n\n值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$id**\n\n`$id` 关键字用于定义 schema 基本的 URI，可用于 `$ref` 的引用标识，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$ref**\n\n`$ref` 关键字用于定义引用 schema，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\nURI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。\n\n如果有两个 schema 互相使用 `$ref` 进行引用，不应该陷入无限循环。\n\n**$comment**\n\n`$comment` 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。","slug":"JSON Schema","published":1,"date":"2018-12-24T09:07:57.652Z","updated":"2019-06-10T06:53:57.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l610002ki7979gz1nv6","content":"<p><strong>JSON Schema 详解：未完待续</strong></p>\n<a id=\"more\"></a>  \n<h2 id=\"第一篇：了解-JSON\"><a href=\"#第一篇：了解-JSON\" class=\"headerlink\" title=\"第一篇：了解 JSON\"></a>第一篇：了解 JSON</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>JSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"external\">Standard ECMA-262 3rd Edition - December 1999</a>》的一个子集，而后成为写入 RFC 文档：<a href=\"https://tools.ietf.org/html/rfc4627\" target=\"_blank\" rel=\"external\">RFC 4627</a>，最新的 RFC 标准为：<a href=\"https://tools.ietf.org/html/rfc8259\" target=\"_blank\" rel=\"external\">RFC 8259</a>。</p>\n<p>JSON 的官方 MIME 类型是 <code>application/json</code>，文件扩展名是 <code>.json</code>。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><strong>两种结构化类型</strong>：</p>\n<ul>\n<li>Object：<code>名称/值</code>的集合（A collection of name/value pairs），在不同的语言中，被理解为 <code>object</code>，<code>record</code>，<code>struct</code>，<code>dictionary</code>，<code>hash table</code> 等等。<ul>\n<li>使用大括号<code>{</code>，<code>}</code>包裹<code>名称/值</code>的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用<code>:</code>分隔。<code>名称/值</code>之间使用<code>,</code>分隔。</li>\n<li>格式示例：<code>{&quot;example&quot;:&quot;string&quot;}</code>。</li>\n</ul>\n</li>\n<li>Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 <code>array</code>。<ul>\n<li>使用中括号<code>[</code>，<code>]</code>包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。</li>\n<li>格式示例：<code>[0,&quot;1&quot;,null,false,true,{},[]]</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>四种基本类型</strong>：</p>\n<ul>\n<li>字符串（string）<ul>\n<li>字符串是 Unicode 字符组成的集合，使用双引号包裹（<code>&quot;</code>），反斜杠转义（<code>\\</code>）。</li>\n<li>与 C 或 Java 的字符串相似。</li>\n</ul>\n</li>\n<li>数值（number）<ul>\n<li>使用十进制，可以为负数或者小数。还可以用<code>e</code>或者<code>E</code>表示为指数形式。</li>\n<li>数值也与 C 或 Java 的数值相似。</li>\n</ul>\n</li>\n<li>布尔（boolean）<ul>\n<li><code>true</code> 或 <code>false</code>。</li>\n</ul>\n</li>\n<li>空（null）<ul>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Tips</strong>：</p>\n<ul>\n<li>值的是可以嵌套的。</li>\n<li>名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。</li>\n<li>符号中间允许空白字符。</li>\n<li>JSON 没有限制必须以 <code>object</code> 或结构类型作为顶层类型。</li>\n<li>但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 <code>object</code> 作为顶层类型。</li>\n<li>上述的集合或列表（string，object，array）可以是空集或空列。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Object</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;Image&quot;: &#123;</div><div class=\"line\">        &quot;Width&quot;:  800,</div><div class=\"line\">        &quot;Height&quot;: 600,</div><div class=\"line\">        &quot;Title&quot;:  &quot;View from 15th Floor&quot;,</div><div class=\"line\">        &quot;Thumbnail&quot;: &#123;</div><div class=\"line\">            &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,</div><div class=\"line\">            &quot;Height&quot;: 125,</div><div class=\"line\">            &quot;Width&quot;:  100</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &quot;Animated&quot; : false,</div><div class=\"line\">        &quot;IDs&quot;: [116, 943, 234, 38793]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"># Array</div><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</div><div class=\"line\">        &quot;Latitude&quot;:  37.7668,</div><div class=\"line\">        &quot;Longitude&quot;: -122.3959,</div><div class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</div><div class=\"line\">        &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,</div><div class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</div><div class=\"line\">        &quot;Zip&quot;:       &quot;94107&quot;,</div><div class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</div><div class=\"line\">        &quot;Latitude&quot;:  37.371991,</div><div class=\"line\">        &quot;Longitude&quot;: -122.026020,</div><div class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</div><div class=\"line\">        &quot;City&quot;:      &quot;SUNNYVALE&quot;,</div><div class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</div><div class=\"line\">        &quot;Zip&quot;:       &quot;94085&quot;,</div><div class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"># Only values</div><div class=\"line\"></div><div class=\"line\">&quot;Hello world!&quot;</div><div class=\"line\"></div><div class=\"line\">42</div><div class=\"line\"></div><div class=\"line\">true</div><div class=\"line\"></div><div class=\"line\">null</div></pre></td></tr></table></figure>\n<h2 id=\"第二篇：介绍\"><a href=\"#第二篇：介绍\" class=\"headerlink\" title=\"第二篇：介绍\"></a>第二篇：介绍</h2><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><p>当前版本：<a href=\"http://json-schema.org/specification.html\" target=\"_blank\" rel=\"external\">draft-07</a>。</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>JSON Schema 是一个用于<strong>注释</strong>和<strong>验证</strong> JSON documents 的词汇表。</p>\n<p>JSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>对数据结构进行描述</li>\n<li>构建人机可读的文档</li>\n<li>校验数据</li>\n</ul>\n<h4 id=\"项目状态\"><a href=\"#项目状态\" class=\"headerlink\" title=\"项目状态\"></a>项目状态</h4><p>共有三个规范：</p>\n<ul>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"external\">JSON Schema (core)</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"external\">JSON Schema Validation</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"external\">JSON Hyper-Schema</a></li>\n</ul>\n<p>项目组正在努力使它们成为正式的 RFC 标准。</p>\n<p><em><a href=\"https://github.com/json-schema-org/json-schema-spec/milestone/6\" target=\"_blank\" rel=\"external\">draft-08</a></em></p>\n<h4 id=\"如何应用\"><a href=\"#如何应用\" class=\"headerlink\" title=\"如何应用\"></a>如何应用</h4><p>可以用于生成模拟数据，确保接近真实数据。</p>\n<p>用于校验数据，实现自动化测试。</p>\n<p>多端共用同一份验证。</p>\n<h2 id=\"第三篇：Core-规范\"><a href=\"#第三篇：Core-规范\" class=\"headerlink\" title=\"第三篇：Core 规范\"></a>第三篇：Core 规范</h2><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"external\">JSON Schema (core)</a></p>\n<p>此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：<a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"external\">https://datatracker.ietf.org/doc/draft-handrews-json-schema/</a>。</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><strong>媒体类型</strong></p>\n<p>JSON 的媒体类型：<a href=\"https://tools.ietf.org/html/rfc8259#section-1.2\" target=\"_blank\" rel=\"external\">application/json</a> 。</p>\n<p>JSON Schema 的媒体类型为 <code>application/schema+json</code>，它还有另外一种可选媒体类型用于提供额外的扩展功能：<code>application/schema-instance+json</code>。</p>\n<p><strong>验证</strong></p>\n<p>JSON Schema 描述了 <code>JSON 文档(JSON document)</code> 的结构，例如属性、长度限制等，程序可以以此判断 <code>实例(Instance)</code> 是否符合规范。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"external\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>注释</strong></p>\n<p>JSON Schema 可以对 <code>实例(Instance)</code> 添加注释。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"external\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>超媒体与链接</strong></p>\n<p>JSON Hyper-Schema 描述了  <code>JSON 文档(JSON document)</code> 的超文本结构，包括 <code>实例(Instance)</code> 中的资源链接关系等。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"external\">JSON Hyper-Schema</a> 中定义。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>JSON Document</strong></p>\n<p><code>JSON 文档(JSON document)</code> 是使用 <code>application/json</code> 媒体类型描述的资源。</p>\n<p>简言之就是 JSON 值。</p>\n<p><em>JSON Schema 中， <code>JSON 值(JSON value)</code>、<code>JSON 文本(JSON text)</code>、<code>JSON 文档(JSON document)</code>是等义词。</em></p>\n<p><em>JSON Schema 也是 <code>JSON 文档(JSON document)</code>。</em></p>\n<p><strong>Instance</strong></p>\n<p><code>实例(Instance)</code> 是使用 JSON Schema 描述的 <code>JSON 文档(JSON document)</code>。</p>\n<p><strong>JSON Schema document</strong></p>\n<p>使用 <code>application/schema+json</code> 媒体类型描述的 <code>JSON 文档(JSON document)</code>，简称 schema。</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p><strong>$schema</strong></p>\n<p><code>$schema</code> 关键字用于声明当前 <code>JSON 文档(JSON document)</code> 是 <code>JSON Schema document</code>。</p>\n<p>值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"external\">URI</a>。</p>\n<p><strong>$id</strong></p>\n<p><code>$id</code> 关键字用于定义 schema 基本的 URI，可用于 <code>$ref</code> 的引用标识，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"external\">URI</a>。</p>\n<p><strong>$ref</strong></p>\n<p><code>$ref</code> 关键字用于定义引用 schema，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"external\">URI</a>。</p>\n<p>URI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。</p>\n<p>如果有两个 schema 互相使用 <code>$ref</code> 进行引用，不应该陷入无限循环。</p>\n<p><strong>$comment</strong></p>\n<p><code>$comment</code> 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。</p>\n","site":{"data":{}},"excerpt":"<p><strong>JSON Schema 详解：未完待续</strong></p>","more":"<h2 id=\"第一篇：了解-JSON\"><a href=\"#第一篇：了解-JSON\" class=\"headerlink\" title=\"第一篇：了解 JSON\"></a>第一篇：了解 JSON</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>JSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"external\">Standard ECMA-262 3rd Edition - December 1999</a>》的一个子集，而后成为写入 RFC 文档：<a href=\"https://tools.ietf.org/html/rfc4627\" target=\"_blank\" rel=\"external\">RFC 4627</a>，最新的 RFC 标准为：<a href=\"https://tools.ietf.org/html/rfc8259\" target=\"_blank\" rel=\"external\">RFC 8259</a>。</p>\n<p>JSON 的官方 MIME 类型是 <code>application/json</code>，文件扩展名是 <code>.json</code>。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><strong>两种结构化类型</strong>：</p>\n<ul>\n<li>Object：<code>名称/值</code>的集合（A collection of name/value pairs），在不同的语言中，被理解为 <code>object</code>，<code>record</code>，<code>struct</code>，<code>dictionary</code>，<code>hash table</code> 等等。<ul>\n<li>使用大括号<code>{</code>，<code>}</code>包裹<code>名称/值</code>的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用<code>:</code>分隔。<code>名称/值</code>之间使用<code>,</code>分隔。</li>\n<li>格式示例：<code>{&quot;example&quot;:&quot;string&quot;}</code>。</li>\n</ul>\n</li>\n<li>Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 <code>array</code>。<ul>\n<li>使用中括号<code>[</code>，<code>]</code>包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。</li>\n<li>格式示例：<code>[0,&quot;1&quot;,null,false,true,{},[]]</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>四种基本类型</strong>：</p>\n<ul>\n<li>字符串（string）<ul>\n<li>字符串是 Unicode 字符组成的集合，使用双引号包裹（<code>&quot;</code>），反斜杠转义（<code>\\</code>）。</li>\n<li>与 C 或 Java 的字符串相似。</li>\n</ul>\n</li>\n<li>数值（number）<ul>\n<li>使用十进制，可以为负数或者小数。还可以用<code>e</code>或者<code>E</code>表示为指数形式。</li>\n<li>数值也与 C 或 Java 的数值相似。</li>\n</ul>\n</li>\n<li>布尔（boolean）<ul>\n<li><code>true</code> 或 <code>false</code>。</li>\n</ul>\n</li>\n<li>空（null）<ul>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Tips</strong>：</p>\n<ul>\n<li>值的是可以嵌套的。</li>\n<li>名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。</li>\n<li>符号中间允许空白字符。</li>\n<li>JSON 没有限制必须以 <code>object</code> 或结构类型作为顶层类型。</li>\n<li>但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 <code>object</code> 作为顶层类型。</li>\n<li>上述的集合或列表（string，object，array）可以是空集或空列。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Object</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;Image&quot;: &#123;</div><div class=\"line\">        &quot;Width&quot;:  800,</div><div class=\"line\">        &quot;Height&quot;: 600,</div><div class=\"line\">        &quot;Title&quot;:  &quot;View from 15th Floor&quot;,</div><div class=\"line\">        &quot;Thumbnail&quot;: &#123;</div><div class=\"line\">            &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,</div><div class=\"line\">            &quot;Height&quot;: 125,</div><div class=\"line\">            &quot;Width&quot;:  100</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &quot;Animated&quot; : false,</div><div class=\"line\">        &quot;IDs&quot;: [116, 943, 234, 38793]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"># Array</div><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</div><div class=\"line\">        &quot;Latitude&quot;:  37.7668,</div><div class=\"line\">        &quot;Longitude&quot;: -122.3959,</div><div class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</div><div class=\"line\">        &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,</div><div class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</div><div class=\"line\">        &quot;Zip&quot;:       &quot;94107&quot;,</div><div class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</div><div class=\"line\">        &quot;Latitude&quot;:  37.371991,</div><div class=\"line\">        &quot;Longitude&quot;: -122.026020,</div><div class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</div><div class=\"line\">        &quot;City&quot;:      &quot;SUNNYVALE&quot;,</div><div class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</div><div class=\"line\">        &quot;Zip&quot;:       &quot;94085&quot;,</div><div class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"># Only values</div><div class=\"line\"></div><div class=\"line\">&quot;Hello world!&quot;</div><div class=\"line\"></div><div class=\"line\">42</div><div class=\"line\"></div><div class=\"line\">true</div><div class=\"line\"></div><div class=\"line\">null</div></pre></td></tr></table></figure>\n<h2 id=\"第二篇：介绍\"><a href=\"#第二篇：介绍\" class=\"headerlink\" title=\"第二篇：介绍\"></a>第二篇：介绍</h2><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><p>当前版本：<a href=\"http://json-schema.org/specification.html\" target=\"_blank\" rel=\"external\">draft-07</a>。</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>JSON Schema 是一个用于<strong>注释</strong>和<strong>验证</strong> JSON documents 的词汇表。</p>\n<p>JSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>对数据结构进行描述</li>\n<li>构建人机可读的文档</li>\n<li>校验数据</li>\n</ul>\n<h4 id=\"项目状态\"><a href=\"#项目状态\" class=\"headerlink\" title=\"项目状态\"></a>项目状态</h4><p>共有三个规范：</p>\n<ul>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"external\">JSON Schema (core)</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"external\">JSON Schema Validation</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"external\">JSON Hyper-Schema</a></li>\n</ul>\n<p>项目组正在努力使它们成为正式的 RFC 标准。</p>\n<p><em><a href=\"https://github.com/json-schema-org/json-schema-spec/milestone/6\" target=\"_blank\" rel=\"external\">draft-08</a></em></p>\n<h4 id=\"如何应用\"><a href=\"#如何应用\" class=\"headerlink\" title=\"如何应用\"></a>如何应用</h4><p>可以用于生成模拟数据，确保接近真实数据。</p>\n<p>用于校验数据，实现自动化测试。</p>\n<p>多端共用同一份验证。</p>\n<h2 id=\"第三篇：Core-规范\"><a href=\"#第三篇：Core-规范\" class=\"headerlink\" title=\"第三篇：Core 规范\"></a>第三篇：Core 规范</h2><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"external\">JSON Schema (core)</a></p>\n<p>此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：<a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"external\">https://datatracker.ietf.org/doc/draft-handrews-json-schema/</a>。</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><strong>媒体类型</strong></p>\n<p>JSON 的媒体类型：<a href=\"https://tools.ietf.org/html/rfc8259#section-1.2\" target=\"_blank\" rel=\"external\">application/json</a> 。</p>\n<p>JSON Schema 的媒体类型为 <code>application/schema+json</code>，它还有另外一种可选媒体类型用于提供额外的扩展功能：<code>application/schema-instance+json</code>。</p>\n<p><strong>验证</strong></p>\n<p>JSON Schema 描述了 <code>JSON 文档(JSON document)</code> 的结构，例如属性、长度限制等，程序可以以此判断 <code>实例(Instance)</code> 是否符合规范。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"external\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>注释</strong></p>\n<p>JSON Schema 可以对 <code>实例(Instance)</code> 添加注释。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"external\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>超媒体与链接</strong></p>\n<p>JSON Hyper-Schema 描述了  <code>JSON 文档(JSON document)</code> 的超文本结构，包括 <code>实例(Instance)</code> 中的资源链接关系等。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"external\">JSON Hyper-Schema</a> 中定义。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>JSON Document</strong></p>\n<p><code>JSON 文档(JSON document)</code> 是使用 <code>application/json</code> 媒体类型描述的资源。</p>\n<p>简言之就是 JSON 值。</p>\n<p><em>JSON Schema 中， <code>JSON 值(JSON value)</code>、<code>JSON 文本(JSON text)</code>、<code>JSON 文档(JSON document)</code>是等义词。</em></p>\n<p><em>JSON Schema 也是 <code>JSON 文档(JSON document)</code>。</em></p>\n<p><strong>Instance</strong></p>\n<p><code>实例(Instance)</code> 是使用 JSON Schema 描述的 <code>JSON 文档(JSON document)</code>。</p>\n<p><strong>JSON Schema document</strong></p>\n<p>使用 <code>application/schema+json</code> 媒体类型描述的 <code>JSON 文档(JSON document)</code>，简称 schema。</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p><strong>$schema</strong></p>\n<p><code>$schema</code> 关键字用于声明当前 <code>JSON 文档(JSON document)</code> 是 <code>JSON Schema document</code>。</p>\n<p>值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"external\">URI</a>。</p>\n<p><strong>$id</strong></p>\n<p><code>$id</code> 关键字用于定义 schema 基本的 URI，可用于 <code>$ref</code> 的引用标识，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"external\">URI</a>。</p>\n<p><strong>$ref</strong></p>\n<p><code>$ref</code> 关键字用于定义引用 schema，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"external\">URI</a>。</p>\n<p>URI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。</p>\n<p>如果有两个 schema 互相使用 <code>$ref</code> 进行引用，不应该陷入无限循环。</p>\n<p><strong>$comment</strong></p>\n<p><code>$comment</code> 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。</p>"},{"title":"JWT 与 OAuth 2.0","_content":"**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","source":"_posts/JWT 与 OAuth 2.0.md","raw":"---\ntitle: JWT 与 OAuth 2.0\n---\n**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","slug":"JWT 与 OAuth 2.0","published":1,"date":"2018-12-24T09:07:57.652Z","updated":"2018-12-24T09:07:57.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l630003ki79e9h8rd9w","content":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>\n<a id=\"more\"></a>  \n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>\n","site":{"data":{}},"excerpt":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>"},{"title":"RESTful缓存方案","_content":"\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","source":"_posts/RESTful缓存方案.md","raw":"---\ntitle: RESTful缓存方案\n---\n\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","slug":"RESTful缓存方案","published":1,"date":"2018-12-24T09:07:57.654Z","updated":"2018-12-24T09:07:57.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l630004ki79p4m0y5n7","content":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>\n<a id=\"more\"></a>  \n<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>\n","site":{"data":{}},"excerpt":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>","more":"<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>"},{"title":"超媒体驱动的 Web API","_content":"\n**REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。**\n\n<!--more-->  \n\n### 超媒体的重要性\n\n超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。\n\n> Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。\n\n这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 **互联网规模（Internet-scale）** 的 **分布式** **超媒体** 系统的需求来进行分析。\n\n**超媒体是 REST 的基点之一。**\n\n### WEB API 中的超媒体\n\n超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《[REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。\n\n**关于超媒体与超文本，以下是Fielding博士在评论中的回复**\n\n> When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.\n\n### 超媒体的作用\n\n论文中给出的正式的超媒体的定义：\n\n> 超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。\n\n**超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力**。举个例子，HTML 的 <a> 标签：\n\n```\n<a href=\"http://www.baidu.com/\">点击我将跳转至百度</a>\n```\n\n这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\n```\n\n这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。\n\n> 超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。\n\n以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。\n\n> 通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。\n\n### Web API 存在的问题\n\n* Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。\n\n* 要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。\n\n* Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。\n\n### 解决方案\n\n目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。\n\n### 困惑-Web API的发展方向\n\n目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？\n\n### 总结\n\n嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。\n","source":"_posts/hypertext-driven.md","raw":"---\ntitle: 超媒体驱动的 Web API\n---\n\n**REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。**\n\n<!--more-->  \n\n### 超媒体的重要性\n\n超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。\n\n> Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。\n\n这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 **互联网规模（Internet-scale）** 的 **分布式** **超媒体** 系统的需求来进行分析。\n\n**超媒体是 REST 的基点之一。**\n\n### WEB API 中的超媒体\n\n超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《[REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。\n\n**关于超媒体与超文本，以下是Fielding博士在评论中的回复**\n\n> When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.\n\n### 超媒体的作用\n\n论文中给出的正式的超媒体的定义：\n\n> 超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。\n\n**超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力**。举个例子，HTML 的 <a> 标签：\n\n```\n<a href=\"http://www.baidu.com/\">点击我将跳转至百度</a>\n```\n\n这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\n```\n\n这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。\n\n> 超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。\n\n以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。\n\n> 通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。\n\n### Web API 存在的问题\n\n* Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。\n\n* 要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。\n\n* Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。\n\n### 解决方案\n\n目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。\n\n### 困惑-Web API的发展方向\n\n目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？\n\n### 总结\n\n嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。\n","slug":"hypertext-driven","published":1,"date":"2018-12-24T09:07:57.654Z","updated":"2018-12-24T09:07:57.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l640005ki79kcyym3bh","content":"<p><strong>REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。</strong></p>\n<a id=\"more\"></a>  \n<h3 id=\"超媒体的重要性\"><a href=\"#超媒体的重要性\" class=\"headerlink\" title=\"超媒体的重要性\"></a>超媒体的重要性</h3><p>超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。</p>\n<blockquote>\n<p>Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。</p>\n</blockquote>\n<p>这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 <strong>互联网规模（Internet-scale）</strong> 的 <strong>分布式</strong> <strong>超媒体</strong> 系统的需求来进行分析。</p>\n<p><strong>超媒体是 REST 的基点之一。</strong></p>\n<h3 id=\"WEB-API-中的超媒体\"><a href=\"#WEB-API-中的超媒体\" class=\"headerlink\" title=\"WEB API 中的超媒体\"></a>WEB API 中的超媒体</h3><p>超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《<a href=\"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\" target=\"_blank\" rel=\"external\">REST APIs must be hypertext-driven</a>》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。</p>\n<p><strong>关于超媒体与超文本，以下是Fielding博士在评论中的回复</strong></p>\n<blockquote>\n<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.</p>\n</blockquote>\n<h3 id=\"超媒体的作用\"><a href=\"#超媒体的作用\" class=\"headerlink\" title=\"超媒体的作用\"></a>超媒体的作用</h3><p>论文中给出的正式的超媒体的定义：</p>\n<blockquote>\n<p>超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。</p>\n</blockquote>\n<p><strong>超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力</strong>。举个例子，HTML 的 <a> 标签：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;点击我将跳转至百度&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Host: www.baidu.com</div></pre></td></tr></table></figure>\n<p>这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。</p>\n<blockquote>\n<p>超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。</p>\n</blockquote>\n<p>以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。</p>\n<blockquote>\n<p>通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。</p>\n</blockquote>\n<h3 id=\"Web-API-存在的问题\"><a href=\"#Web-API-存在的问题\" class=\"headerlink\" title=\"Web API 存在的问题\"></a>Web API 存在的问题</h3><ul>\n<li><p>Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。</p>\n</li>\n<li><p>要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。</p>\n</li>\n<li><p>Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。</p>\n<h3 id=\"困惑-Web-API的发展方向\"><a href=\"#困惑-Web-API的发展方向\" class=\"headerlink\" title=\"困惑-Web API的发展方向\"></a>困惑-Web API的发展方向</h3><p>目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。</p>\n","site":{"data":{}},"excerpt":"<p><strong>REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。</strong></p>","more":"<h3 id=\"超媒体的重要性\"><a href=\"#超媒体的重要性\" class=\"headerlink\" title=\"超媒体的重要性\"></a>超媒体的重要性</h3><p>超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。</p>\n<blockquote>\n<p>Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。</p>\n</blockquote>\n<p>这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 <strong>互联网规模（Internet-scale）</strong> 的 <strong>分布式</strong> <strong>超媒体</strong> 系统的需求来进行分析。</p>\n<p><strong>超媒体是 REST 的基点之一。</strong></p>\n<h3 id=\"WEB-API-中的超媒体\"><a href=\"#WEB-API-中的超媒体\" class=\"headerlink\" title=\"WEB API 中的超媒体\"></a>WEB API 中的超媒体</h3><p>超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《<a href=\"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\" target=\"_blank\" rel=\"external\">REST APIs must be hypertext-driven</a>》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。</p>\n<p><strong>关于超媒体与超文本，以下是Fielding博士在评论中的回复</strong></p>\n<blockquote>\n<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.</p>\n</blockquote>\n<h3 id=\"超媒体的作用\"><a href=\"#超媒体的作用\" class=\"headerlink\" title=\"超媒体的作用\"></a>超媒体的作用</h3><p>论文中给出的正式的超媒体的定义：</p>\n<blockquote>\n<p>超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。</p>\n</blockquote>\n<p><strong>超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力</strong>。举个例子，HTML 的 <a> 标签：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;点击我将跳转至百度&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Host: www.baidu.com</div></pre></td></tr></table></figure>\n<p>这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。</p>\n<blockquote>\n<p>超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。</p>\n</blockquote>\n<p>以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。</p>\n<blockquote>\n<p>通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。</p>\n</blockquote>\n<h3 id=\"Web-API-存在的问题\"><a href=\"#Web-API-存在的问题\" class=\"headerlink\" title=\"Web API 存在的问题\"></a>Web API 存在的问题</h3><ul>\n<li><p>Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。</p>\n</li>\n<li><p>要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。</p>\n</li>\n<li><p>Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。</p>\n<h3 id=\"困惑-Web-API的发展方向\"><a href=\"#困惑-Web-API的发展方向\" class=\"headerlink\" title=\"困惑-Web API的发展方向\"></a>困惑-Web API的发展方向</h3><p>目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。</p>"},{"title":"Session 与 JWT","_content":"\n**关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT**\n\n<!--more-->  \n\n### 知识点\n\n1. **无状态**\n\n\t* 关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。\n\n\t* 《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》\n\n\t* > 客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有**会话状态（session state）** 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。\n\n\t* 《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。\n\n2. **Cookie**\n\n\t* 说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。\n\n\t* > cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。\n\n\t* > 可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。\n\n\t* 以上是《HTTP权威指南》一书中对于 cookie 的解释。\n\n3. **Session ID**\n\n\t* 会话 cookie 就是现在人们常说的 session，他的表现形式通常为：\n\n\t* > 一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。\n\n\t* 恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是**使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法**。\n\n4. **JWT**\n\n\t* > JSON Web Token（JWT）是一种开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。\n\n\t* 这种格式有很多优点，我这里用于与 session ID 来比较的是它的**自成一体**。\n\n\t* > 自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。\n\n\t* 是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。\n\n### 比较\n\n在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，[《为什么 session 机制没有被 JWT 所取代?》](https://www.v2ex.com/t/381996)，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。\n\n### 无状态架构的取舍\n\n在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。\n\nFielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。\n\n> 这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。\n> 与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。\n\n*顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。*\n\n### Session ID 与 JWT 的取舍\n\n**Session ID**\n\n先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。\n\n* 可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。\n* 可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。\n* 可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。\n\n**JWT**\n\n再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。\n\n*额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。*\n\n**取舍**\n\n服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。\n\n### 总结\n\nsession ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。\n\n但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。\n","source":"_posts/session and JWT.md","raw":"---\ntitle: Session 与 JWT\n---\n\n**关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT**\n\n<!--more-->  \n\n### 知识点\n\n1. **无状态**\n\n\t* 关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。\n\n\t* 《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》\n\n\t* > 客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有**会话状态（session state）** 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。\n\n\t* 《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。\n\n2. **Cookie**\n\n\t* 说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。\n\n\t* > cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。\n\n\t* > 可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。\n\n\t* 以上是《HTTP权威指南》一书中对于 cookie 的解释。\n\n3. **Session ID**\n\n\t* 会话 cookie 就是现在人们常说的 session，他的表现形式通常为：\n\n\t* > 一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。\n\n\t* 恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是**使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法**。\n\n4. **JWT**\n\n\t* > JSON Web Token（JWT）是一种开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。\n\n\t* 这种格式有很多优点，我这里用于与 session ID 来比较的是它的**自成一体**。\n\n\t* > 自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。\n\n\t* 是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。\n\n### 比较\n\n在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，[《为什么 session 机制没有被 JWT 所取代?》](https://www.v2ex.com/t/381996)，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。\n\n### 无状态架构的取舍\n\n在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。\n\nFielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。\n\n> 这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。\n> 与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。\n\n*顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。*\n\n### Session ID 与 JWT 的取舍\n\n**Session ID**\n\n先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。\n\n* 可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。\n* 可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。\n* 可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。\n\n**JWT**\n\n再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。\n\n*额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。*\n\n**取舍**\n\n服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。\n\n### 总结\n\nsession ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。\n\n但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。\n","slug":"session and JWT","published":1,"date":"2018-12-24T09:07:57.654Z","updated":"2018-12-24T09:07:57.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l650006ki79rqbxq1sm","content":"<p><strong>关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT</strong></p>\n<a id=\"more\"></a>  \n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li><p><strong>无状态</strong></p>\n<ul>\n<li><p>关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。</p>\n</li>\n<li><p>《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》</p>\n</li>\n<li><blockquote>\n<p>客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有<strong>会话状态（session state）</strong> 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。</p>\n</blockquote>\n</li>\n<li><p>《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Cookie</strong></p>\n<ul>\n<li><p>说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。</p>\n</li>\n<li><blockquote>\n<p>cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。</p>\n</blockquote>\n</li>\n<li><p>以上是《HTTP权威指南》一书中对于 cookie 的解释。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Session ID</strong></p>\n<ul>\n<li><p>会话 cookie 就是现在人们常说的 session，他的表现形式通常为：</p>\n</li>\n<li><blockquote>\n<p>一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。</p>\n</blockquote>\n</li>\n<li><p>恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是<strong>使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>JWT</strong></p>\n<ul>\n<li><blockquote>\n<p>JSON Web Token（JWT）是一种开放标准（<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"external\">RFC 7519</a>），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。</p>\n</blockquote>\n</li>\n<li><p>这种格式有很多优点，我这里用于与 session ID 来比较的是它的<strong>自成一体</strong>。</p>\n</li>\n<li><blockquote>\n<p>自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。</p>\n</blockquote>\n</li>\n<li><p>是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，<a href=\"https://www.v2ex.com/t/381996\" target=\"_blank\" rel=\"external\">《为什么 session 机制没有被 JWT 所取代?》</a>，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。</p>\n<h3 id=\"无状态架构的取舍\"><a href=\"#无状态架构的取舍\" class=\"headerlink\" title=\"无状态架构的取舍\"></a>无状态架构的取舍</h3><p>在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。</p>\n<p>Fielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。</p>\n<blockquote>\n<p>这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。<br>与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。</p>\n</blockquote>\n<p><em>顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。</em></p>\n<h3 id=\"Session-ID-与-JWT-的取舍\"><a href=\"#Session-ID-与-JWT-的取舍\" class=\"headerlink\" title=\"Session ID 与 JWT 的取舍\"></a>Session ID 与 JWT 的取舍</h3><p><strong>Session ID</strong></p>\n<p>先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。</p>\n<ul>\n<li>可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。</li>\n<li>可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。</li>\n<li>可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。</li>\n</ul>\n<p><strong>JWT</strong></p>\n<p>再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。</p>\n<p><em>额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。</em></p>\n<p><strong>取舍</strong></p>\n<p>服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>session ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。</p>\n<p>但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。</p>\n","site":{"data":{}},"excerpt":"<p><strong>关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT</strong></p>","more":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li><p><strong>无状态</strong></p>\n<ul>\n<li><p>关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。</p>\n</li>\n<li><p>《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》</p>\n</li>\n<li><blockquote>\n<p>客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有<strong>会话状态（session state）</strong> 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。</p>\n</blockquote>\n</li>\n<li><p>《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Cookie</strong></p>\n<ul>\n<li><p>说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。</p>\n</li>\n<li><blockquote>\n<p>cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。</p>\n</blockquote>\n</li>\n<li><p>以上是《HTTP权威指南》一书中对于 cookie 的解释。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Session ID</strong></p>\n<ul>\n<li><p>会话 cookie 就是现在人们常说的 session，他的表现形式通常为：</p>\n</li>\n<li><blockquote>\n<p>一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。</p>\n</blockquote>\n</li>\n<li><p>恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是<strong>使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>JWT</strong></p>\n<ul>\n<li><blockquote>\n<p>JSON Web Token（JWT）是一种开放标准（<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"external\">RFC 7519</a>），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。</p>\n</blockquote>\n</li>\n<li><p>这种格式有很多优点，我这里用于与 session ID 来比较的是它的<strong>自成一体</strong>。</p>\n</li>\n<li><blockquote>\n<p>自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。</p>\n</blockquote>\n</li>\n<li><p>是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，<a href=\"https://www.v2ex.com/t/381996\" target=\"_blank\" rel=\"external\">《为什么 session 机制没有被 JWT 所取代?》</a>，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。</p>\n<h3 id=\"无状态架构的取舍\"><a href=\"#无状态架构的取舍\" class=\"headerlink\" title=\"无状态架构的取舍\"></a>无状态架构的取舍</h3><p>在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。</p>\n<p>Fielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。</p>\n<blockquote>\n<p>这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。<br>与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。</p>\n</blockquote>\n<p><em>顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。</em></p>\n<h3 id=\"Session-ID-与-JWT-的取舍\"><a href=\"#Session-ID-与-JWT-的取舍\" class=\"headerlink\" title=\"Session ID 与 JWT 的取舍\"></a>Session ID 与 JWT 的取舍</h3><p><strong>Session ID</strong></p>\n<p>先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。</p>\n<ul>\n<li>可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。</li>\n<li>可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。</li>\n<li>可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。</li>\n</ul>\n<p><strong>JWT</strong></p>\n<p>再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。</p>\n<p><em>额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。</em></p>\n<p><strong>取舍</strong></p>\n<p>服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>session ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。</p>\n<p>但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。</p>"},{"title":"RESTful API 实践","_content":"\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n由于不符合超媒体，现在是 HTTP API。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ...\n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求)\n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在\n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n","source":"_posts/RESTful API 实践.md","raw":"---\ntitle: RESTful API 实践\n---\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n由于不符合超媒体，现在是 HTTP API。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ...\n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求)\n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在\n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n","slug":"RESTful API 实践","published":1,"date":"2018-12-24T09:07:57.653Z","updated":"2018-12-24T09:07:57.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq15l69000bki79zt6unby0","content":"<p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<p>由于不符合超媒体，现在是 HTTP API。</p>\n<a id=\"more\"></a>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sortby=level&amp;order=asc</div></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sort=-type，created_at</div></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?offset=10 - 偏移量</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</div><div class=\"line\">\t......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?embed=department.name，job</div></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</div><div class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</div><div class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</div><div class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</div></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'message': 'Invalid Token'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'code' : 10010，</div><div class=\"line\">\t'message': 'Insufficient balance'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback_function(&#123;</div><div class=\"line\">\tstatus_code: 200，</div><div class=\"line\">\tnext_page: &quot;https://..&quot;，</div><div class=\"line\">\tresponse: &#123;</div><div class=\"line\">\t\t... 正常的 JSON 实体 ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求)</p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在</p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"external\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"external\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</div><div class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</div><div class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</div><div class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</div><div class=\"line\">它成为了现代 Web 架构的基础。</div><div class=\"line\"></div><div class=\"line\">出自[中文译版] 结论</div></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"external\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"external\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"external\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"external\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"external\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"external\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">HTTP缓存 这里主要是讲的Etag</a></p>\n","site":{"data":{}},"excerpt":"<p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<p>由于不符合超媒体，现在是 HTTP API。</p>","more":"<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sortby=level&amp;order=asc</div></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sort=-type，created_at</div></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?offset=10 - 偏移量</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</div><div class=\"line\">\t......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?embed=department.name，job</div></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</div><div class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</div><div class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</div><div class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</div></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'message': 'Invalid Token'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'code' : 10010，</div><div class=\"line\">\t'message': 'Insufficient balance'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback_function(&#123;</div><div class=\"line\">\tstatus_code: 200，</div><div class=\"line\">\tnext_page: &quot;https://..&quot;，</div><div class=\"line\">\tresponse: &#123;</div><div class=\"line\">\t\t... 正常的 JSON 实体 ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求)</p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在</p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"external\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"external\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</div><div class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</div><div class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</div><div class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</div><div class=\"line\">它成为了现代 Web 架构的基础。</div><div class=\"line\"></div><div class=\"line\">出自[中文译版] 结论</div></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"external\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"external\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"external\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"external\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"external\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"external\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">HTTP缓存 这里主要是讲的Etag</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}