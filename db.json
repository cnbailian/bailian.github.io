{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","path":"static/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","path":"static/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","path":"static/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","path":"static/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","path":"static/images/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.png","path":"static/images/gravatar.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","path":"static/js/meizi.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","path":"static/images/favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","path":"static/css/style.css","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-meizi/.gitignore","hash":"5163f3d9e05f8be9025633bac924c47c777b41e6","modified":1560153108780},{"_id":"themes/hexo-theme-meizi/_config.yml","hash":"ef6a08d5dae27813b0b7e7395f6c168b9aca7886","modified":1571648034794},{"_id":"themes/hexo-theme-meizi/bower.json","hash":"dedf03e9e405d4be38cebaa753fe23158e32b066","modified":1560153108781},{"_id":"themes/hexo-theme-meizi/gulpfile.js","hash":"805dbc9e619c0e4be563a8a32b39060fb7475655","modified":1560153108781},{"_id":"themes/hexo-theme-meizi/package.json","hash":"4a88f9f1450747b0b1c13d1f2500ef63a2383de8","modified":1560153108787},{"_id":"themes/hexo-theme-meizi/README.md","hash":"bd5f1ef099ca4f621c29f319165c6470b0cb7014","modified":1560153108781},{"_id":"source/_posts/Concurrency-and-scheduler-of-Go.md","hash":"8a451e978d1a2ae65c9f2b85454dd32b33987afd","modified":1574142832100},{"_id":"source/_posts/API-security.md","hash":"17cdb241b10da48c3b70d93a526b2ccf27908ec4","modified":1571648203545},{"_id":"source/_posts/JSON Schema.md","hash":"a6ad8e3a7db409ec5eb954755da2d2467fd603b8","modified":1560155024444},{"_id":"source/_posts/RESTful-API-Practice.md","hash":"e76bde82a42f3ba2bde6ef0f8ce19028742a35fe","modified":1571648309424},{"_id":"source/_posts/OAuth2.0-and-oauth2-server-package.md","hash":"d9ae98db0bf3d611ca4caafbc3f14afb372238dc","modified":1571648274590},{"_id":"source/_posts/RESTful-cache.md","hash":"0a53f8bf00989366ff4e04a16c4499490ec4235f","modified":1571648321521},{"_id":"source/_posts/hypertext-driven.md","hash":"3af33d64b3af86a6f94387ef67afb323e67c60e0","modified":1560154951898},{"_id":"source/_posts/chromeBox 大纲.dat","hash":"26d44ea5427717e9a087f0fb0e1c761b9ce8ce9a","modified":1545642477654},{"_id":"source/_posts/session-and-JWT.md","hash":"1c103327aae9148db4b1984f43f32f6653ac800b","modified":1571648332693},{"_id":"source/_posts/Vue-learning-route.md","hash":"b752d958b1d9e41c42643e48c7eeb91afe452793","modified":1571648352957},{"_id":"source/_posts/tpshop代码审计--续.dat","hash":"a364ec4317bbbf9bd2e355726344e0d9335de13c","modified":1545642477655},{"_id":"source/_posts/tpshop代码审计.dat","hash":"c6b836d318b4d08b294f94135262b27946d7959b","modified":1545642477655},{"_id":"source/about/index.md","hash":"7539f2171199054e8b27c92af950646e34df7926","modified":1572832135072},{"_id":"source/archive/index.md","hash":"fc18302dc4b2a347ac7969bab93eda360f3b7bd3","modified":1545642477656},{"_id":"source/links/index.md","hash":"49e30f19d6276ac9f7ddd5956d05c854ae37d99a","modified":1545642477656},{"_id":"source/resume/index.md","hash":"d8dc3a03d440b471ce53e0e743ddbe3249579a5e","modified":1573000997382},{"_id":"themes/hexo-theme-meizi/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1560153108775},{"_id":"themes/hexo-theme-meizi/.git/config","hash":"7b81e6fbe592203925fa7afb3503851de853853e","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1560153105558},{"_id":"source/tags/index.md","hash":"35867ca3284afb0c225bd922f41386fd8b21d8e8","modified":1545642477656},{"_id":"themes/hexo-theme-meizi/.git/index","hash":"7285a6064386b8b3a2fef119630b78626d376a79","modified":1560155345505},{"_id":"themes/hexo-theme-meizi/.git/packed-refs","hash":"972281fc35737309bbcc9b09cc6fbc570deaa255","modified":1560153108773},{"_id":"themes/hexo-theme-meizi/languages/zh-cn.yml","hash":"60767afef61e4ce6809071fccdc4e833b06863eb","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/layout/about.ejs","hash":"4323c21b553780269f2cac5d6e5a8f33d6243290","modified":1560153108785},{"_id":"themes/hexo-theme-meizi/layout/all-archives.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/links.ejs","hash":"1514d633dae3c5c5a76344afeaa0fbdf154c025c","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/index.ejs","hash":"b0d62a2f93de7917e67556f30dee33214d9b7d74","modified":1560153108786},{"_id":"themes/hexo-theme-meizi/layout/tags.ejs","hash":"17a1f47a1b54624645fcb182d4e275512e918386","modified":1560153108786},{"_id":"source/_posts/JWT-and-OAuth2.0.md","hash":"b7341c777d3add7255c09bde622f722a2cee08eb","modified":1571648248270},{"_id":"themes/hexo-theme-meizi/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1560153105560},{"_id":"themes/hexo-theme-meizi/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1560153105559},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1560153105560},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1560153105559},{"_id":"themes/hexo-theme-meizi/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1560153105561},{"_id":"themes/hexo-theme-meizi/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1560153105562},{"_id":"themes/hexo-theme-meizi/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1560153105557},{"_id":"themes/hexo-theme-meizi/.git/logs/HEAD","hash":"73566d03be4f63179ecae0a3123f0f80fc3fba6f","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/layout/_partial/about.ejs","hash":"a08ffc6ab76217d05facb9cc2b4fcc7ae5148a3e","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/layout/_partial/archive.ejs","hash":"8126fd297918132825fe3110f5ebb0efe2b9d024","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/layout/_partial/index.ejs","hash":"3d0bd9cc0b5f1660d74c63166c62155e76c92102","modified":1560155265716},{"_id":"themes/hexo-theme-meizi/layout/_partial/tags.ejs","hash":"b5121bf77d8da66cdb18c1d6269854951fd1c0e5","modified":1560153108785},{"_id":"themes/hexo-theme-meizi/layout/_partial/post.ejs","hash":"26c6d0915c9164a4eafe8118898cc4bdd120fec9","modified":1560153219752},{"_id":"themes/hexo-theme-meizi/layout/_partial/links.ejs","hash":"f70a0579a35f2815b919080ae643574e7156e59d","modified":1560153108785},{"_id":"themes/hexo-theme-meizi/scripts/helpers/func.js","hash":"9deec4d350f6baffae85f44c91097139c3fefe46","modified":1560153108787},{"_id":"themes/hexo-theme-meizi/source/_css/style.scss","hash":"3b7fd5a263afc20c60557326827c5bd0bfc75de8","modified":1560153108790},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1560153108791},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1560153108791},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1560153108792},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1560153108792},{"_id":"themes/hexo-theme-meizi/source/_images/.DS_Store","hash":"fdb1ed4f0bead0080922ca8622f7e774458c8140","modified":1572484707204},{"_id":"themes/hexo-theme-meizi/source/_images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1560153108792},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647768474},{"_id":"themes/hexo-theme-meizi/source/_js/meizi.js","hash":"e8e2709c6202af825f28a1fc413922c7297dd160","modified":1560153108793},{"_id":"themes/hexo-theme-meizi/source/_images/gravatar.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647777925},{"_id":"themes/hexo-theme-meizi/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1560153105560},{"_id":"themes/hexo-theme-meizi/.git/refs/heads/master","hash":"9e0459116ecb93cf28843d634c4f246e721004fd","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.idx","hash":"ddc8d023560997562e71b97d44a538fb0ed1e1f5","modified":1560153108762},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/duoshuo.ejs","hash":"fa58511057fb387b59771193b1d7eebfe9273c59","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/footer.ejs","hash":"fa6d3667d0bebd00475fd67c1426cd30c80e8ed3","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/header.ejs","hash":"f27ad620e4d3b036ede31a5068066581e0d35532","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/head.ejs","hash":"7a463f03d7fa36e44750f63ccf51ecf52bfde3c3","modified":1560153108783},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/pagination.ejs","hash":"244782d6b1fdc6bd71517709a0407272a33c7919","modified":1560153108784},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/scripts.ejs","hash":"c3138803ca03ea4b94aa620b626f1d9cfe477bb2","modified":1560153108784},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/sidebar.ejs","hash":"4ecc51d5c94ab12dab9c8516bb8bfcd720482fa1","modified":1560153108784},{"_id":"themes/hexo-theme-meizi/source/_css/include/_header.scss","hash":"30643e4b7b2fc920c3474ab79936afd619e521ac","modified":1560153108788},{"_id":"themes/hexo-theme-meizi/source/_css/include/_layout.scss","hash":"313456db88a9ffef298bce6f5041456b98f3f2a6","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/include/_core.scss","hash":"cc72e8ef196ada45f663ab94f0b5862bf0f60f43","modified":1560153108787},{"_id":"themes/hexo-theme-meizi/source/_css/include/_main.scss","hash":"f89d6f8c0225f60d958deb88c239ce2ba97528bb","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/include/_markdown.scss","hash":"2ee28dada07096cf1537652e3105d8e9216c88d3","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/include/_iconfont.scss","hash":"7de2c0a7dc1ae4f16eb2da1a4fdddd9a0a4acd74","modified":1560153108788},{"_id":"themes/hexo-theme-meizi/source/_css/include/_sidebar.scss","hash":"d9a9cd8d52ed2d8e3b23074f1c1e7f9b179eaaf4","modified":1560153108789},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_variables.scss","hash":"38138cafcc3b702b032bb576fa46815b2f0cff3f","modified":1560153108790},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_query.scss","hash":"b0c46b67d87e7548ccf0704bb43363f2cc6278bd","modified":1560153108790},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1560153108794},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1560153108794},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1560153108794},{"_id":"themes/hexo-theme-meizi/source/static/images/.DS_Store","hash":"fed247035d4674543b77b7f34dcf1d214dc0d729","modified":1572484707205},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1560153108795},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1560153108795},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647817605},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1560153108796},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1571647812337},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/disqus.ejs","hash":"e6658fa854c46077b797289599fb1158a05d47dd","modified":1560153108782},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/heads/master","hash":"73566d03be4f63179ecae0a3123f0f80fc3fba6f","modified":1560153108776},{"_id":"themes/hexo-theme-meizi/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1560153108775},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1560153108793},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/remotes/origin/HEAD","hash":"73566d03be4f63179ecae0a3123f0f80fc3fba6f","modified":1560153108775},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.pack","hash":"deb8601f46513acdf5c099767f143977c23340d2","modified":1560153108760},{"_id":"public/atom.xml","hash":"a566f2b74e0c56ec4b79684df76e74ffe53d0415","modified":1574142939697},{"_id":"public/about/index.html","hash":"1807dd00149ac51149e03c83ea4e46173eb0ce22","modified":1574142939711},{"_id":"public/archive/index.html","hash":"0caa9ecb60b98fbcee8e46bb5daf74bc3969cdfd","modified":1574142939711},{"_id":"public/links/index.html","hash":"b3c365d86f86375d10340731a5eb51b6b9360a4d","modified":1574142939711},{"_id":"public/resume/index.html","hash":"e8defa6cfaf8b0e31caf7e18abf2d4a1b8603dc2","modified":1574142939711},{"_id":"public/tags/index.html","hash":"2fbb63c1db125387be6d0e588bb91ee6f8482819","modified":1574142939711},{"_id":"public/2017/08/session-and-JWT/index.html","hash":"42b074aab9ad48ebb103c79b1f62bcdab18c72f3","modified":1574142939711},{"_id":"public/2017/04/hypertext-driven/index.html","hash":"5c5737573d9a31265d919c2e164af2c698e8b549","modified":1574142939711},{"_id":"public/2016/09/RESTful-cache/index.html","hash":"79a7fe3def97c0985a8d9f18679ff611786bb3ea","modified":1574142939711},{"_id":"public/2016/09/JWT-and-OAuth2.0/index.html","hash":"196d9919682914481b4976305025b71a5c56c896","modified":1574142939711},{"_id":"public/2016/07/API-security/index.html","hash":"4a1835d0639fb2ab11733206fb326d51af0cc133","modified":1574142939711},{"_id":"public/archives/2016/index.html","hash":"b50f2b88f45f56d565a1e6a4405bf7c6d1c4e366","modified":1574142939711},{"_id":"public/archives/2016/07/index.html","hash":"cfa8cce2525fc1583cf5a53ca1eaabc718814987","modified":1574142939712},{"_id":"public/archives/2016/09/index.html","hash":"20d9aaaec3f6ee0efe029e25c177588ff8f6ea8c","modified":1574142939712},{"_id":"public/archives/2016/10/index.html","hash":"1e2e171ad33ae6cc2a51cdd8bf9886982bb5361a","modified":1574142939712},{"_id":"public/archives/2017/index.html","hash":"3c2537f009592b864d55f0ebdc812f7f036ce4d0","modified":1574142939712},{"_id":"public/archives/2017/04/index.html","hash":"fa7c26c240c08cd8829485644afbce48931e80a2","modified":1574142939712},{"_id":"public/archives/2017/08/index.html","hash":"c6bfc5497d4850f088caf8f622840a420aa3a1ab","modified":1574142939712},{"_id":"public/archives/2018/index.html","hash":"15496d852bc95e8f6d85107695ac7756e06689ae","modified":1574142939712},{"_id":"public/archives/2018/11/index.html","hash":"75e139b5f3e4960424c3ac63914c90f194d43250","modified":1574142939712},{"_id":"public/archives/2018/12/index.html","hash":"6167946d72d259bad625d4c2fa963de849b1aabe","modified":1574142939712},{"_id":"public/archives/2019/index.html","hash":"7def6ae1c5cc4bd3a0bb6dce5982502f14e5029b","modified":1574142939712},{"_id":"public/archives/2019/03/index.html","hash":"2d2de2a88df391cb6bbd48543cee4bad2c0a069d","modified":1574142939713},{"_id":"public/archives/2019/04/index.html","hash":"9431102feba1c1f1a9483280b8d8b8c8f50538ea","modified":1574142939713},{"_id":"public/2019/04/Vue-learning-route/index.html","hash":"9a47448fdd4e23553681ebdc6a45394514997565","modified":1574142939713},{"_id":"public/2019/03/Concurrency-and-scheduler-of-Go/index.html","hash":"fbd319678b37306401459fae93e9b13e6aefe7fe","modified":1574142939713},{"_id":"public/2018/12/JSON Schema/index.html","hash":"25ae4c12cbbc56343844551180e515c14f411ca6","modified":1574142939713},{"_id":"public/2018/11/OAuth2.0-and-oauth2-server-package/index.html","hash":"60cfc2aa313bf3527ac8f8c611e07db9ddbead77","modified":1574142939713},{"_id":"public/2016/10/RESTful-API-Practice/index.html","hash":"2a9a9eed7adb862bfa20d20bc83ddf7fb234cf27","modified":1574142939713},{"_id":"public/archives/index.html","hash":"856870b3473cf423ab85579c93225ba9686c0dfc","modified":1574142939713},{"_id":"public/index.html","hash":"856870b3473cf423ab85579c93225ba9686c0dfc","modified":1574142939718},{"_id":"public/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1574142939721},{"_id":"public/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1574142939721},{"_id":"public/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1574142939721},{"_id":"public/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1574142939721},{"_id":"public/static/images/gravatar.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1574142939721},{"_id":"public/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1574142939723},{"_id":"public/static/images/favicon.png","hash":"ade0e3b17a11e49088518380eba0cf9ff9f85f69","modified":1574142939724},{"_id":"public/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1574142939728},{"_id":"public/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1574142939728}],"Category":[],"Data":[],"Page":[{"title":"关于我","layout":"about","_content":"\n<!-- 这里写你的简介 -->\n\n全栈程序员(伪)，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、RESTful规范，还接触过 Flutter，技术栈虽然多，但不是都精通，能称得上熟悉并感兴趣的也只有 Go 和 RESTful 了","source":"about/index.md","raw":"title: \"关于我\"\nlayout: \"about\"\n---\n\n<!-- 这里写你的简介 -->\n\n全栈程序员(伪)，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、RESTful规范，还接触过 Flutter，技术栈虽然多，但不是都精通，能称得上熟悉并感兴趣的也只有 Go 和 RESTful 了","date":"2019-11-04T01:48:55.072Z","updated":"2019-11-04T01:48:55.072Z","path":"about/index.html","comments":1,"_id":"ck35g29br0001yz79ane1k1cq","content":"<!-- 这里写你的简介 -->\n<p>全栈程序员(伪)，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、RESTful规范，还接触过 Flutter，技术栈虽然多，但不是都精通，能称得上熟悉并感兴趣的也只有 Go 和 RESTful 了</p>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的简介 -->\n<p>全栈程序员(伪)，技术栈很杂，包括但不限于前端、PHP、Go、Kubernetes、RESTful规范，还接触过 Flutter，技术栈虽然多，但不是都精通，能称得上熟悉并感兴趣的也只有 Go 和 RESTful 了</p>\n"},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"title: \"归档\"\nlayout: \"all-archives\"\n---","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"archive/index.html","comments":1,"_id":"ck35g29bt0003yz7907xi81tq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"友情链接","layout":"links","_content":"\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","source":"links/index.md","raw":"title: \"友情链接\"\nlayout: \"links\"\n---\n\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"links/index.html","comments":1,"_id":"ck35g29bv0005yz79hvtzmumf","content":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n"},{"title":"简历","layout":"resume","_content":"\n<!-- **个人信息**\n\n* 姓名：白联\n* 年龄：22\n* 工作经验：2年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 期望职位：PHP程序员\n* 期望薪资：10k\n* 工作状态：在职\n\n**联系方式**\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n**工作经历**\n\n* 中普互联网金融-信息技术部（2016-6 ~ 2017-9）\n  * 主要项目1：\n    * 中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。\n    * 问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。\n  * 主要项目2：\n    * 中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen\n    * 问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。\n    * 解决：我将解决方案整理了一篇 RESTful API 的实践博文（https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\n  * 主要项目3：\n    * 友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。\n    * 问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。\n    * 解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。\n\n* 沈阳星乐科技（2016-01 ~ 2016-06）\n\n* 沈阳谊来网络科技（2015-07 ~ 2015-12）\n\n**技术能力**\n\n* 熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。\n* 单元测试：PHPUnit。\n* 开发环境：Docker（目前在用） & Vagrant（docker之前用）\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解 Python，Go。\n* 熟悉 HTTP 协议、REST、Web API。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n\n**技术文章**\n\n* 《超媒体驱动的 Web API》 https://cnbailian.github.io/2017/10/hypertext-driven/\n* 《Session 与 JWT》 https://cnbailian.github.io/2017/10/session%20and%20JWT/\n* 《RESTful API 实践》 https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\n\n**技术演讲**\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n**个人评价**\n\n个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。\n\n擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。\n\n**致谢**\n\n感谢您的阅读，期待有机会能与您共事。 -->\n","source":"resume/index.md","raw":"title: \"简历\"\nlayout: \"resume\"\n---\n\n<!-- **个人信息**\n\n* 姓名：白联\n* 年龄：22\n* 工作经验：2年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 期望职位：PHP程序员\n* 期望薪资：10k\n* 工作状态：在职\n\n**联系方式**\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n**工作经历**\n\n* 中普互联网金融-信息技术部（2016-6 ~ 2017-9）\n  * 主要项目1：\n    * 中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。\n    * 问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。\n  * 主要项目2：\n    * 中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen\n    * 问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。\n    * 解决：我将解决方案整理了一篇 RESTful API 的实践博文（https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\n  * 主要项目3：\n    * 友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。\n    * 问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。\n    * 解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。\n\n* 沈阳星乐科技（2016-01 ~ 2016-06）\n\n* 沈阳谊来网络科技（2015-07 ~ 2015-12）\n\n**技术能力**\n\n* 熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。\n* 单元测试：PHPUnit。\n* 开发环境：Docker（目前在用） & Vagrant（docker之前用）\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解 Python，Go。\n* 熟悉 HTTP 协议、REST、Web API。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n\n**技术文章**\n\n* 《超媒体驱动的 Web API》 https://cnbailian.github.io/2017/10/hypertext-driven/\n* 《Session 与 JWT》 https://cnbailian.github.io/2017/10/session%20and%20JWT/\n* 《RESTful API 实践》 https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\n\n**技术演讲**\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n**个人评价**\n\n个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。\n\n擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。\n\n**致谢**\n\n感谢您的阅读，期待有机会能与您共事。 -->\n","date":"2019-11-06T00:43:17.382Z","updated":"2019-11-06T00:43:17.382Z","path":"resume/index.html","comments":1,"_id":"ck35g29bw0007yz79xxi9bjsl","content":"<!-- **个人信息**\n\n* 姓名：白联\n* 年龄：22\n* 工作经验：2年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 期望职位：PHP程序员\n* 期望薪资：10k\n* 工作状态：在职\n\n**联系方式**\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n**工作经历**\n\n* 中普互联网金融-信息技术部（2016-6 ~ 2017-9）\n  * 主要项目1：\n    * 中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。\n    * 问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。\n  * 主要项目2：\n    * 中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen\n    * 问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。\n    * 解决：我将解决方案整理了一篇 RESTful API 的实践博文（https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\n  * 主要项目3：\n    * 友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。\n    * 问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。\n    * 解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。\n\n* 沈阳星乐科技（2016-01 ~ 2016-06）\n\n* 沈阳谊来网络科技（2015-07 ~ 2015-12）\n\n**技术能力**\n\n* 熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。\n* 单元测试：PHPUnit。\n* 开发环境：Docker（目前在用） & Vagrant（docker之前用）\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解 Python，Go。\n* 熟悉 HTTP 协议、REST、Web API。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n\n**技术文章**\n\n* 《超媒体驱动的 Web API》 https://cnbailian.github.io/2017/10/hypertext-driven/\n* 《Session 与 JWT》 https://cnbailian.github.io/2017/10/session%20and%20JWT/\n* 《RESTful API 实践》 https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\n\n**技术演讲**\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n**个人评价**\n\n个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。\n\n擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。\n\n**致谢**\n\n感谢您的阅读，期待有机会能与您共事。 -->\n","site":{"data":{}},"excerpt":"","more":"<!-- **个人信息**\n\n* 姓名：白联\n* 年龄：22\n* 工作经验：2年\n* 技术博客：https://cnbailian.github.io/\n* GitHub：https://github.com/cnbailian\n* 期望职位：PHP程序员\n* 期望薪资：10k\n* 工作状态：在职\n\n**联系方式**\n\n* 手机号：15142556834\n* 邮箱：captainbailian@gmail.com\n\n**工作经历**\n\n* 中普互联网金融-信息技术部（2016-6 ~ 2017-9）\n  * 主要项目1：\n    * 中普金服：主要负责微信端开发，2人协作开发，与前端配合。负责与服务器端接口对接，部分模块设计。\n    * 问题与解决：时间紧，一定时限内完成整个系统，产品-测试都要包括在内。加班一个月左右解决。\n  * 主要项目2：\n    * 中普车房网：负责全部接口方面开发，包括接口架构，文档编写，与 APP 端的沟通协作等。框架选择：Lumen\n    * 问题：首次设计 RESTful API，碰到也解决了很多问题，API 的安全性，文档的编写，分页实现等等。\n    * 解决：我将解决方案整理了一篇 RESTful API 的实践博文（https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/）\n  * 主要项目3：\n    * 友毒 APP 接口开发，独立完成。框架选择：根据 Slim 修改，更适合 API 开发的框架。\n    * 问题：RESTful API 对于资源的整合，经过与 APP 端开发人员的交流，认为不应该出现一个 APP 页面请求多次接口的情况出现。\n    * 解决：在 GraphQL 与 API Gateway 中选择了 API 网关，使用 Go 开发了简单的资源整合网关。\n\n* 沈阳星乐科技（2016-01 ~ 2016-06）\n\n* 沈阳谊来网络科技（2015-07 ~ 2015-12）\n\n**技术能力**\n\n* 熟练PHP，熟悉各类框架：Laravel、Slim、CI等，使用 Composer 包管理，遵守 PSR 编码规范。\n* 单元测试：PHPUnit。\n* 开发环境：Docker（目前在用） & Vagrant（docker之前用）\n* 熟悉前端技术：JS、CSS、HTML、VueJS。\n* 了解 Python，Go。\n* 熟悉 HTTP 协议、REST、Web API。\n* 了解 Chrome 扩展开发。\n* 熟悉 MySQL，基本数据库设计。\n* 熟悉 Linux 系统基本操作。\n\n**技术文章**\n\n* 《超媒体驱动的 Web API》 https://cnbailian.github.io/2017/10/hypertext-driven/\n* 《Session 与 JWT》 https://cnbailian.github.io/2017/10/session%20and%20JWT/\n* 《RESTful API 实践》 https://cnbailian.github.io/2017/10/RESTful%20API%20%E5%AE%9E%E8%B7%B5/\n\n**技术演讲**\n\n* 公司内部做过关于 REST 的技术演讲，主要分享 REST 与 web API 的发展史。\n\n**个人评价**\n\n个人比较擅长 RESTful API 开发，但其他方面也没有什么短板。\n\n擅长框架是 Laravel，喜欢 Laravel 的优雅，方便。\n\n**致谢**\n\n感谢您的阅读，期待有机会能与您共事。 -->\n"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---","date":"2018-12-24T09:07:57.656Z","updated":"2018-12-24T09:07:57.656Z","path":"tags/index.html","comments":1,"_id":"ck35g29by0009yz79chzbvkxi","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Go 的并发性与调度器","date":"2019-03-06T12:12:19.000Z","_content":"\n本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。\n\n<!--more-->  \n\n### 你真的了解并发吗？\n\n相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 `go` 关键字，就可以轻松的实现并发。但是，你真正的了解**并发**吗？\n\n并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指**同一时刻的请求量**，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。*高并发在这里还有个可能的概念是：**同时应对许多请求所使用的技术**，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。*\n\n并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。\n\n下面，让我们看看 Go 语言编程中，“并发”这个词的概念。\n\n### Go 语言中的并发性\n\nGo 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：\n\n* 为什么要有并发？\n* 什么是并发？\n* 这个想法源自哪里？\n* 并发有什么好处？\n* 我该如何使用它？\n\n面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：[《Go Concurrency Patterns》](https://www.youtube.com/watch?v=f6kdp27TYZs)，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。\n\n简单的总结一下并发在 Go 语言编程中的概念：\n\n**“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。**\n\n在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个[素数筛选程序](https://play.golang.org/p/9U22NfrXeq)来理解 Go 的并发编程：\n\n```go\n// A concurrent prime sieve\n\npackage main\n\n// Send the sequence 2, 3, 4, ... to channel 'ch'.\nfunc Generate(ch chan<- int) {\n\tfor i := 2; ; i++ {\n\t\tch <- i // Send 'i' to channel 'ch'.\n\t}\n}\n\n// Copy the values from channel 'in' to channel 'out',\n// removing those divisible by 'prime'.\nfunc Filter(in <-chan int, out chan<- int, prime int) {\n\tfor {\n\t\ti := <-in // Receive value from 'in'.\n\t\tif i%prime != 0 {\n\t\t\tout <- i // Send 'i' to 'out'.\n\t\t}\n\t}\n}\n\n// The prime sieve: Daisy-chain Filter processes.\nfunc main() {\n\tch := make(chan int) // Create a new channel.\n\tgo Generate(ch)      // Launch Generate goroutine.\n\tfor i := 0; i < 10; i++ {\n\t\tprime := <-ch\n\t\tprint(prime, \"\\n\")\n\t\tch1 := make(chan int)\n\t\tgo Filter(ch, ch1, prime)\n\t\tch = ch1\n\t}\n}\n```\n\n它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、[**通过通信共享内存**](https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes)的理念，而且非常优雅。\n\n在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。\n\n通过下面的 gif 动画能清晰的看到程序运行过程：\n\n![primesieve](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif)\n\n### 并发不是并行\n\n#### Go 的并行\n\n只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？\n\n我们需要明确一个观点：**并发不是为了效率，并发的程序不一定可以并行。**还是上面素数的例子，这段代码是并发的，但不完全是并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。\n\n#### 正交概念\n\n*正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。*\n\n在广义概念上来讲，并发与并行是**正交概念**，对于 Go 语言的并发性来讲也是如此。\n\n#### 《Concurrency is not Parallelism》\n\n同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。\n\n这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：\n\n**并行是指同时能执行多个事情。**\n\n**并发关乎结构，是一种结构化程序的方式。**\n\n**并行关乎执行，表述的是程序的运行状态。**\n\n### Go 语言是如何支持并发的？\n\n上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。\n\n我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。\n\n#### 模型演化过程\n\n在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在[**《Scalable Go Scheduler Design Doc》**](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit)中指出了该模型在并发伸缩性方面的问题：\n\n> 1. 所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。\n> 2. 当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；\n> 3. M 用到的 `mCache` 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；\n> 4. 由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。\n\n并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：\n\n![gpm-nino](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg)\n\n#### G-P-M 模型\n\n那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：\n\n* G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。\n* P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 >= P的数量），由用户设置的 GOMAXPROCS 决定。\n* M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。\n\n接下来了解这套模型的基本调度，在调度过程中还有一个 [*work-stealing*](http://supertech.csail.mit.edu/papers/steal.pdf) 的算法：\n\n* 每个 P 维护一个本地队列；\n* 当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；\n* 当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；\n* 如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。\n\nGo 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。\n\n### Goroutine 调度器的深入\n\n让我们深入的了解一下 goroutine 调度器。\n\n#### 调度器解决了什么问题？\n\n##### 阻塞问题\n\n> 如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。\n\nGo 在执行阻塞的系统调用时会调用 `entersyscallblock` ，然后通过 `handoffp` 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 `pidle` 链表，等待有需要时被取出。\n\n如果是调用的 `entersyscall`，会将 P 的状态置为 `_Psyscall`。监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现是 `_Psyscall` 状态，就会调用 `handoffp` 来释放。\n\n##### 抢占调度\n\n在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。\n\n于是 Dmitry Vyukov 提出了[《Go Preemptive Scheduler Design Doc》](https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit), 并在1.2版本中引入了初级的抢占。\n\n监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现运行时间超出 `forcePreemptNS` 限制（10ms）的 P，就会通过 `preemptone` 发起抢占。\n\n##### Goroutine 的负载均衡\n\n> 内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。\n\n这部分的实现是在 M 的启动函数 `mstart` 中 `schedule` 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。\n\n#### 调度器相关源码\n\n调度器部分的代码主要集中在 `src/runtime/runtime2.go` 与 `src/runtime/proc.go` 这两个文件中。\n\n调度器的4个基本结构：g、m、p、schedt，都在 `runtime2.go` 中，`schedt` 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 `pidle`，空闲的 M 链表 `midle` 等等。\n\n调度器的具体实现函数都在 `proc.go` 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 `main` 中的代码放入 `main goroutine` 中运行，这时还会启动监控系统 `sysmon`。\n\n更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。\n\n### 结束语\n\n看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。\n\n### 参考文章\n\n[《Go Concurrency Patterns》](https://talks.golang.org/2012/concurrency.slide#1)\n\n[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)\n\n[《go-under-the-hood》](https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md)\n\n[《也谈goroutine调度器》](https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/)\n\n[《Goroutine浅析》](https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/)","source":"_posts/Concurrency-and-scheduler-of-Go.md","raw":"---\ntitle: Go 的并发性与调度器\ndate: 2019/03/06 20:12:19\n---\n\n本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。\n\n<!--more-->  \n\n### 你真的了解并发吗？\n\n相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 `go` 关键字，就可以轻松的实现并发。但是，你真正的了解**并发**吗？\n\n并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指**同一时刻的请求量**，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。*高并发在这里还有个可能的概念是：**同时应对许多请求所使用的技术**，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。*\n\n并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。\n\n下面，让我们看看 Go 语言编程中，“并发”这个词的概念。\n\n### Go 语言中的并发性\n\nGo 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：\n\n* 为什么要有并发？\n* 什么是并发？\n* 这个想法源自哪里？\n* 并发有什么好处？\n* 我该如何使用它？\n\n面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：[《Go Concurrency Patterns》](https://www.youtube.com/watch?v=f6kdp27TYZs)，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。\n\n简单的总结一下并发在 Go 语言编程中的概念：\n\n**“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。**\n\n在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个[素数筛选程序](https://play.golang.org/p/9U22NfrXeq)来理解 Go 的并发编程：\n\n```go\n// A concurrent prime sieve\n\npackage main\n\n// Send the sequence 2, 3, 4, ... to channel 'ch'.\nfunc Generate(ch chan<- int) {\n\tfor i := 2; ; i++ {\n\t\tch <- i // Send 'i' to channel 'ch'.\n\t}\n}\n\n// Copy the values from channel 'in' to channel 'out',\n// removing those divisible by 'prime'.\nfunc Filter(in <-chan int, out chan<- int, prime int) {\n\tfor {\n\t\ti := <-in // Receive value from 'in'.\n\t\tif i%prime != 0 {\n\t\t\tout <- i // Send 'i' to 'out'.\n\t\t}\n\t}\n}\n\n// The prime sieve: Daisy-chain Filter processes.\nfunc main() {\n\tch := make(chan int) // Create a new channel.\n\tgo Generate(ch)      // Launch Generate goroutine.\n\tfor i := 0; i < 10; i++ {\n\t\tprime := <-ch\n\t\tprint(prime, \"\\n\")\n\t\tch1 := make(chan int)\n\t\tgo Filter(ch, ch1, prime)\n\t\tch = ch1\n\t}\n}\n```\n\n它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、[**通过通信共享内存**](https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes)的理念，而且非常优雅。\n\n在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。\n\n通过下面的 gif 动画能清晰的看到程序运行过程：\n\n![primesieve](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif)\n\n### 并发不是并行\n\n#### Go 的并行\n\n只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？\n\n我们需要明确一个观点：**并发不是为了效率，并发的程序不一定可以并行。**还是上面素数的例子，这段代码是并发的，但不完全是并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。\n\n#### 正交概念\n\n*正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。*\n\n在广义概念上来讲，并发与并行是**正交概念**，对于 Go 语言的并发性来讲也是如此。\n\n#### 《Concurrency is not Parallelism》\n\n同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。\n\n这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：\n\n**并行是指同时能执行多个事情。**\n\n**并发关乎结构，是一种结构化程序的方式。**\n\n**并行关乎执行，表述的是程序的运行状态。**\n\n### Go 语言是如何支持并发的？\n\n上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。\n\n我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。\n\n#### 模型演化过程\n\n在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在[**《Scalable Go Scheduler Design Doc》**](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit)中指出了该模型在并发伸缩性方面的问题：\n\n> 1. 所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。\n> 2. 当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；\n> 3. M 用到的 `mCache` 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；\n> 4. 由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。\n\n并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：\n\n![gpm-nino](https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg)\n\n#### G-P-M 模型\n\n那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：\n\n* G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。\n* P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 >= P的数量），由用户设置的 GOMAXPROCS 决定。\n* M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。\n\n接下来了解这套模型的基本调度，在调度过程中还有一个 [*work-stealing*](http://supertech.csail.mit.edu/papers/steal.pdf) 的算法：\n\n* 每个 P 维护一个本地队列；\n* 当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；\n* 当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；\n* 如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。\n\nGo 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。\n\n### Goroutine 调度器的深入\n\n让我们深入的了解一下 goroutine 调度器。\n\n#### 调度器解决了什么问题？\n\n##### 阻塞问题\n\n> 如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。\n\nGo 在执行阻塞的系统调用时会调用 `entersyscallblock` ，然后通过 `handoffp` 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 `pidle` 链表，等待有需要时被取出。\n\n如果是调用的 `entersyscall`，会将 P 的状态置为 `_Psyscall`。监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现是 `_Psyscall` 状态，就会调用 `handoffp` 来释放。\n\n##### 抢占调度\n\n在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。\n\n于是 Dmitry Vyukov 提出了[《Go Preemptive Scheduler Design Doc》](https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit), 并在1.2版本中引入了初级的抢占。\n\n监控线程 `sysmon` 会通过 `retake` 循环所有的 P，发现运行时间超出 `forcePreemptNS` 限制（10ms）的 P，就会通过 `preemptone` 发起抢占。\n\n##### Goroutine 的负载均衡\n\n> 内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。\n\n这部分的实现是在 M 的启动函数 `mstart` 中 `schedule` 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。\n\n#### 调度器相关源码\n\n调度器部分的代码主要集中在 `src/runtime/runtime2.go` 与 `src/runtime/proc.go` 这两个文件中。\n\n调度器的4个基本结构：g、m、p、schedt，都在 `runtime2.go` 中，`schedt` 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 `pidle`，空闲的 M 链表 `midle` 等等。\n\n调度器的具体实现函数都在 `proc.go` 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 `main` 中的代码放入 `main goroutine` 中运行，这时还会启动监控系统 `sysmon`。\n\n更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。\n\n### 结束语\n\n看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。\n\n### 参考文章\n\n[《Go Concurrency Patterns》](https://talks.golang.org/2012/concurrency.slide#1)\n\n[《Concurrency is not Parallelism》](https://talks.golang.org/2012/waza.slide#1)\n\n[《go-under-the-hood》](https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md)\n\n[《也谈goroutine调度器》](https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/)\n\n[《Goroutine浅析》](https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/)","slug":"Concurrency-and-scheduler-of-Go","published":1,"updated":"2019-11-19T05:53:52.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29bm0000yz79j1u3gxgp","content":"<p>本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。</p>\n<a id=\"more\"></a>  \n<h3 id=\"你真的了解并发吗？\"><a href=\"#你真的了解并发吗？\" class=\"headerlink\" title=\"你真的了解并发吗？\"></a>你真的了解并发吗？</h3><p>相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 <code>go</code> 关键字，就可以轻松的实现并发。但是，你真正的了解<strong>并发</strong>吗？</p>\n<p>并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指<strong>同一时刻的请求量</strong>，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。<em>高并发在这里还有个可能的概念是：<strong>同时应对许多请求所使用的技术</strong>，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。</em></p>\n<p>并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。</p>\n<p>下面，让我们看看 Go 语言编程中，“并发”这个词的概念。</p>\n<h3 id=\"Go-语言中的并发性\"><a href=\"#Go-语言中的并发性\" class=\"headerlink\" title=\"Go 语言中的并发性\"></a>Go 语言中的并发性</h3><p>Go 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：</p>\n<ul>\n<li>为什么要有并发？</li>\n<li>什么是并发？</li>\n<li>这个想法源自哪里？</li>\n<li>并发有什么好处？</li>\n<li>我该如何使用它？</li>\n</ul>\n<p>面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：<a href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a>，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。</p>\n<p>简单的总结一下并发在 Go 语言编程中的概念：</p>\n<p><strong>“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。</strong></p>\n<p>在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个<a href=\"https://play.golang.org/p/9U22NfrXeq\" target=\"_blank\" rel=\"noopener\">素数筛选程序</a>来理解 Go 的并发编程：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A concurrent prime sieve</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Generate</span><span class=\"params\">(ch <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; ; i++ &#123;</span><br><span class=\"line\">\t\tch &lt;- i <span class=\"comment\">// Send 'i' to channel 'ch'.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Copy the values from channel 'in' to channel 'out',</span></span><br><span class=\"line\"><span class=\"comment\">// removing those divisible by 'prime'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Filter</span><span class=\"params\">(in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, out <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, prime <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\ti := &lt;-in <span class=\"comment\">// Receive value from 'in'.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i%prime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tout &lt;- i <span class=\"comment\">// Send 'i' to 'out'.</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The prime sieve: Daisy-chain Filter processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// Create a new channel.</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> Generate(ch)      <span class=\"comment\">// Launch Generate goroutine.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tprime := &lt;-ch</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(prime, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t\tch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> Filter(ch, ch1, prime)</span><br><span class=\"line\">\t\tch = ch1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、<a href=\"https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes\" target=\"_blank\" rel=\"noopener\"><strong>通过通信共享内存</strong></a>的理念，而且非常优雅。</p>\n<p>在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。</p>\n<p>通过下面的 gif 动画能清晰的看到程序运行过程：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif\" alt=\"primesieve\"></p>\n<h3 id=\"并发不是并行\"><a href=\"#并发不是并行\" class=\"headerlink\" title=\"并发不是并行\"></a>并发不是并行</h3><h4 id=\"Go-的并行\"><a href=\"#Go-的并行\" class=\"headerlink\" title=\"Go 的并行\"></a>Go 的并行</h4><p>只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？</p>\n<p>我们需要明确一个观点：<strong>并发不是为了效率，并发的程序不一定可以并行。</strong>还是上面素数的例子，这段代码是并发的，但不完全是并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。</p>\n<h4 id=\"正交概念\"><a href=\"#正交概念\" class=\"headerlink\" title=\"正交概念\"></a>正交概念</h4><p><em>正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。</em></p>\n<p>在广义概念上来讲，并发与并行是<strong>正交概念</strong>，对于 Go 语言的并发性来讲也是如此。</p>\n<h4 id=\"《Concurrency-is-not-Parallelism》\"><a href=\"#《Concurrency-is-not-Parallelism》\" class=\"headerlink\" title=\"《Concurrency is not Parallelism》\"></a>《Concurrency is not Parallelism》</h4><p>同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲<a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a>，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。</p>\n<p>这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：</p>\n<p><strong>并行是指同时能执行多个事情。</strong></p>\n<p><strong>并发关乎结构，是一种结构化程序的方式。</strong></p>\n<p><strong>并行关乎执行，表述的是程序的运行状态。</strong></p>\n<h3 id=\"Go-语言是如何支持并发的？\"><a href=\"#Go-语言是如何支持并发的？\" class=\"headerlink\" title=\"Go 语言是如何支持并发的？\"></a>Go 语言是如何支持并发的？</h3><p>上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。</p>\n<p>我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。</p>\n<h4 id=\"模型演化过程\"><a href=\"#模型演化过程\" class=\"headerlink\" title=\"模型演化过程\"></a>模型演化过程</h4><p>在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit\" target=\"_blank\" rel=\"noopener\"><strong>《Scalable Go Scheduler Design Doc》</strong></a>中指出了该模型在并发伸缩性方面的问题：</p>\n<blockquote>\n<ol>\n<li>所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。</li>\n<li>当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；</li>\n<li>M 用到的 <code>mCache</code> 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；</li>\n<li>由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。</li>\n</ol>\n</blockquote>\n<p>并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg\" alt=\"gpm-nino\"></p>\n<h4 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h4><p>那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：</p>\n<ul>\n<li>G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。</li>\n<li>P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 &gt;= P的数量），由用户设置的 GOMAXPROCS 决定。</li>\n<li>M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。</li>\n</ul>\n<p>接下来了解这套模型的基本调度，在调度过程中还有一个 <a href=\"http://supertech.csail.mit.edu/papers/steal.pdf\" target=\"_blank\" rel=\"noopener\"><em>work-stealing</em></a> 的算法：</p>\n<ul>\n<li>每个 P 维护一个本地队列；</li>\n<li>当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；</li>\n<li>当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；</li>\n<li>如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。</li>\n</ul>\n<p>Go 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。</p>\n<h3 id=\"Goroutine-调度器的深入\"><a href=\"#Goroutine-调度器的深入\" class=\"headerlink\" title=\"Goroutine 调度器的深入\"></a>Goroutine 调度器的深入</h3><p>让我们深入的了解一下 goroutine 调度器。</p>\n<h4 id=\"调度器解决了什么问题？\"><a href=\"#调度器解决了什么问题？\" class=\"headerlink\" title=\"调度器解决了什么问题？\"></a>调度器解决了什么问题？</h4><h5 id=\"阻塞问题\"><a href=\"#阻塞问题\" class=\"headerlink\" title=\"阻塞问题\"></a>阻塞问题</h5><blockquote>\n<p>如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。</p>\n</blockquote>\n<p>Go 在执行阻塞的系统调用时会调用 <code>entersyscallblock</code> ，然后通过 <code>handoffp</code> 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 <code>pidle</code> 链表，等待有需要时被取出。</p>\n<p>如果是调用的 <code>entersyscall</code>，会将 P 的状态置为 <code>_Psyscall</code>。监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现是 <code>_Psyscall</code> 状态，就会调用 <code>handoffp</code> 来释放。</p>\n<h5 id=\"抢占调度\"><a href=\"#抢占调度\" class=\"headerlink\" title=\"抢占调度\"></a>抢占调度</h5><p>在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。</p>\n<p>于是 Dmitry Vyukov 提出了<a href=\"https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit\" target=\"_blank\" rel=\"noopener\">《Go Preemptive Scheduler Design Doc》</a>, 并在1.2版本中引入了初级的抢占。</p>\n<p>监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现运行时间超出 <code>forcePreemptNS</code> 限制（10ms）的 P，就会通过 <code>preemptone</code> 发起抢占。</p>\n<h5 id=\"Goroutine-的负载均衡\"><a href=\"#Goroutine-的负载均衡\" class=\"headerlink\" title=\"Goroutine 的负载均衡\"></a>Goroutine 的负载均衡</h5><blockquote>\n<p>内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。</p>\n</blockquote>\n<p>这部分的实现是在 M 的启动函数 <code>mstart</code> 中 <code>schedule</code> 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。</p>\n<h4 id=\"调度器相关源码\"><a href=\"#调度器相关源码\" class=\"headerlink\" title=\"调度器相关源码\"></a>调度器相关源码</h4><p>调度器部分的代码主要集中在 <code>src/runtime/runtime2.go</code> 与 <code>src/runtime/proc.go</code> 这两个文件中。</p>\n<p>调度器的4个基本结构：g、m、p、schedt，都在 <code>runtime2.go</code> 中，<code>schedt</code> 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 <code>pidle</code>，空闲的 M 链表 <code>midle</code> 等等。</p>\n<p>调度器的具体实现函数都在 <code>proc.go</code> 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 <code>main</code> 中的代码放入 <code>main goroutine</code> 中运行，这时还会启动监控系统 <code>sysmon</code>。</p>\n<p>更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://talks.golang.org/2012/concurrency.slide#1\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a></p>\n<p><a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a></p>\n<p><a href=\"https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md\" target=\"_blank\" rel=\"noopener\">《go-under-the-hood》</a></p>\n<p><a href=\"https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/\" target=\"_blank\" rel=\"noopener\">《也谈goroutine调度器》</a></p>\n<p><a href=\"https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">《Goroutine浅析》</a></p>\n","site":{"data":{}},"excerpt":"<p>本篇文章是我对 Go 语言并发性的理解总结，适合初步了解并发，对 Go 语言的并发编程与调度器原理有兴趣的读者。</p>","more":"<h3 id=\"你真的了解并发吗？\"><a href=\"#你真的了解并发吗？\" class=\"headerlink\" title=\"你真的了解并发吗？\"></a>你真的了解并发吗？</h3><p>相信读者都对并发有着一定的理解，也都对 Go 语言感兴趣，Go 最吸引人的地方可能就是它的内建并发支持，使用 <code>go</code> 关键字，就可以轻松的实现并发。但是，你真正的了解<strong>并发</strong>吗？</p>\n<p>并发这个词，你去问编程领域中不同的人，会给出不同的答案。对于 WEB 领域的开发人员来说，并发通常是指<strong>同一时刻的请求量</strong>，WEB 领域的面试官经常会问到的问题：“做过多少并发的项目？”或“接触过高并发的项目吗？”就是应用的这个概念。<em>高并发在这里还有个可能的概念是：<strong>同时应对许多请求所使用的技术</strong>，这通常与分布式、并行等概念挂钩，需要结合上下文语境来判断。</em></p>\n<p>并发是一个有趣的词，因为它对编程领域中的不同人员意味着不同的事情，在广义概念下，有着许多狭义概念。除了“并发”之外，你可能还听过“并行”、“多线程”、“异步”等词汇，有些人认为这些词意思相同，而其他人则在每个词之间划清界限。</p>\n<p>下面，让我们看看 Go 语言编程中，“并发”这个词的概念。</p>\n<h3 id=\"Go-语言中的并发性\"><a href=\"#Go-语言中的并发性\" class=\"headerlink\" title=\"Go 语言中的并发性\"></a>Go 语言中的并发性</h3><p>Go 语言的并发性并不是 WEB 领域的并发概念，很多人对此有所混淆。在 Go 语言发布之初，大家对 Go 的并发特性都有所疑问：</p>\n<ul>\n<li>为什么要有并发？</li>\n<li>什么是并发？</li>\n<li>这个想法源自哪里？</li>\n<li>并发有什么好处？</li>\n<li>我该如何使用它？</li>\n</ul>\n<p>面对这些问题，Rob Pike（Go 语言作者之一）在2012年的 Google I/O 上做了一次精彩的演讲：<a href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a>，在这场演讲中，他回答了上述问题，并通过详细的示例讲解了 goroutine、channel 与 select 的使用，建议大家都去看一看这场演讲。</p>\n<p>简单的总结一下并发在 Go 语言编程中的概念：</p>\n<p><strong>“并发是一种将程序分解成小片段独立执行的程度设计方法”，它是一种结构化程序的方式，独立执行计算的组合。</strong></p>\n<p>在上述的演讲中可以看出，Go 语言推荐使用并发，我们也应该遵循这种编程方式。对于程序员来说，代码更有说服力，我们可以通过这个<a href=\"https://play.golang.org/p/9U22NfrXeq\" target=\"_blank\" rel=\"noopener\">素数筛选程序</a>来理解 Go 的并发编程：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A concurrent prime sieve</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Generate</span><span class=\"params\">(ch <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; ; i++ &#123;</span><br><span class=\"line\">\t\tch &lt;- i <span class=\"comment\">// Send 'i' to channel 'ch'.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Copy the values from channel 'in' to channel 'out',</span></span><br><span class=\"line\"><span class=\"comment\">// removing those divisible by 'prime'.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Filter</span><span class=\"params\">(in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, out <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, prime <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\ti := &lt;-in <span class=\"comment\">// Receive value from 'in'.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i%prime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tout &lt;- i <span class=\"comment\">// Send 'i' to 'out'.</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The prime sieve: Daisy-chain Filter processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// Create a new channel.</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> Generate(ch)      <span class=\"comment\">// Launch Generate goroutine.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tprime := &lt;-ch</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(prime, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t\tch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> Filter(ch, ch1, prime)</span><br><span class=\"line\">\t\tch = ch1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它并不是复杂度最低的算法，特别是寻找大素数方面，但却是最能体现 Go 并发编程、<a href=\"https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes\" target=\"_blank\" rel=\"noopener\"><strong>通过通信共享内存</strong></a>的理念，而且非常优雅。</p>\n<p>在这段代码中，通过 goroutine 的组合，实现一层层的筛选器，筛选器之间通过 channel 通信，每一个筛选器就是一个素数，每个给 main goroutine 通信的内容也是素数，简直精妙。</p>\n<p>通过下面的 gif 动画能清晰的看到程序运行过程：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9fqvjfg30l40c2qek.gif\" alt=\"primesieve\"></p>\n<h3 id=\"并发不是并行\"><a href=\"#并发不是并行\" class=\"headerlink\" title=\"并发不是并行\"></a>并发不是并行</h3><h4 id=\"Go-的并行\"><a href=\"#Go-的并行\" class=\"headerlink\" title=\"Go 的并行\"></a>Go 的并行</h4><p>只需要 GOMAXPROCS 的值大于1，就可以让 Go 程序在多核机器上实现以并行的形式运行。但并发的程序一定可以并行吗？</p>\n<p>我们需要明确一个观点：<strong>并发不是为了效率，并发的程序不一定可以并行。</strong>还是上面素数的例子，这段代码是并发的，但不完全是并行，因为它的每一个执行片段都需要上一个片段的筛选与通信。</p>\n<h4 id=\"正交概念\"><a href=\"#正交概念\" class=\"headerlink\" title=\"正交概念\"></a>正交概念</h4><p><em>正交概念：从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来。</em></p>\n<p>在广义概念上来讲，并发与并行是<strong>正交概念</strong>，对于 Go 语言的并发性来讲也是如此。</p>\n<h4 id=\"《Concurrency-is-not-Parallelism》\"><a href=\"#《Concurrency-is-not-Parallelism》\" class=\"headerlink\" title=\"《Concurrency is not Parallelism》\"></a>《Concurrency is not Parallelism》</h4><p>同样，在 Go 语言发布之初，有很多人混淆了并发与并行的概念，对此，Rob Pike 发表了另一篇演讲<a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a>，通过地鼠烧书的比喻与简单负载均衡器的示例，详细的阐述了并发与并行的区别。</p>\n<p>这里不再复述地鼠例子，只是简单的总结，感兴趣的建议去看演讲：</p>\n<p><strong>并行是指同时能执行多个事情。</strong></p>\n<p><strong>并发关乎结构，是一种结构化程序的方式。</strong></p>\n<p><strong>并行关乎执行，表述的是程序的运行状态。</strong></p>\n<h3 id=\"Go-语言是如何支持并发的？\"><a href=\"#Go-语言是如何支持并发的？\" class=\"headerlink\" title=\"Go 语言是如何支持并发的？\"></a>Go 语言是如何支持并发的？</h3><p>上面一直在讲 Go 语言的并发性，接下来看下 Go 语言是如何做到的并发支持。</p>\n<p>我们在使用 Go 编写并发程序的过程中，无需关心线程的维护、调度等一系列问题，只需要关心程序结构的分解与组合、goroutine 之间的通信就可以写出良好的并发程序，这全部都要依赖于 Go 语言内建的 G-P-M 模型。</p>\n<h4 id=\"模型演化过程\"><a href=\"#模型演化过程\" class=\"headerlink\" title=\"模型演化过程\"></a>模型演化过程</h4><p>在 Go 语言1.0版本时，只有 G-M 模型，Google 工程师 Dmitry Vyukov 在<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit\" target=\"_blank\" rel=\"noopener\"><strong>《Scalable Go Scheduler Design Doc》</strong></a>中指出了该模型在并发伸缩性方面的问题：</p>\n<blockquote>\n<ol>\n<li>所有对 G 的操作：创建、重新调用等由单个全局锁(Sched.Lock)保护，浪费时间。</li>\n<li>当 M 阻塞时，G 需要传递给别的 M 执行，这导致调度延迟增大以及额外的性能损耗；</li>\n<li>M 用到的 <code>mCache</code> 属于内核线程，当 M 阻塞后相应的内存资源仍被占用，导致内存占用过高；</li>\n<li>由于 syscall 导致 M 的阻塞和恢复，导致了额外性能损耗。</li>\n</ol>\n</blockquote>\n<p>并且亲自下场，重新设计、改进了 Go scheduler，在 Go1.1 版本中实现了 G-P-M 模型：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85w9rofpbj30yg0lcgn5.jpg\" alt=\"gpm-nino\"></p>\n<h4 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h4><p>那么这套模型与调度是怎样的呢？先来简单的说一下 G、P、M 的定义：</p>\n<ul>\n<li>G：表示 Goroutine，G 存储了 goroutine 执行的栈信息，状态，任务函数，可重用。</li>\n<li>P：Processor，表示逻辑处理器，拥有一个本地队列。对于 G 来说，P 相当于 CPU 内核，只有进入到 P 的队列中，才可以被调度。对于 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等。P 的数量就是程序可最大可并行的 G 的数量（前提：物理CPU核数 &gt;= P的数量），由用户设置的 GOMAXPROCS 决定。</li>\n<li>M：Machine，是对系统线程的抽象，是真正执行计算的部分。M 在绑定 P 后会在队列中获取 G，切换到 G 的执行栈并执行 G 的函数。M 数量不定，但同时只有 P 个 M 在执行，为了防止创建过多系统线程导致系统调度出现问题，目前默认最大限制10000个。</li>\n</ul>\n<p>接下来了解这套模型的基本调度，在调度过程中还有一个 <a href=\"http://supertech.csail.mit.edu/papers/steal.pdf\" target=\"_blank\" rel=\"noopener\"><em>work-stealing</em></a> 的算法：</p>\n<ul>\n<li>每个 P 维护一个本地队列；</li>\n<li>当一个 G 被创建后，放入当前 P 的本地队列中，如果队列已满，放入全局队列；</li>\n<li>当 M 执行完一个 G 后，会在 当前 P 的队列中取出新的 G，队列为空则在全局队列中加锁获取；</li>\n<li>如果全局队列也为空，则去其他的 P 的队列中偷出一半的 G，放入自己的本地队列。</li>\n</ul>\n<p>Go 语言就是凭借着这套优秀的并发模型与调度，实现了内建的并发支持。</p>\n<h3 id=\"Goroutine-调度器的深入\"><a href=\"#Goroutine-调度器的深入\" class=\"headerlink\" title=\"Goroutine 调度器的深入\"></a>Goroutine 调度器的深入</h3><p>让我们深入的了解一下 goroutine 调度器。</p>\n<h4 id=\"调度器解决了什么问题？\"><a href=\"#调度器解决了什么问题？\" class=\"headerlink\" title=\"调度器解决了什么问题？\"></a>调度器解决了什么问题？</h4><h5 id=\"阻塞问题\"><a href=\"#阻塞问题\" class=\"headerlink\" title=\"阻塞问题\"></a>阻塞问题</h5><blockquote>\n<p>如果任务G陷入到阻塞的系统调用中，内核线程M将一起阻塞，于是实际的运行线程少了一个。更严重的，如果所有M都阻塞了，那些本可以运行的任务G将没有系统资源运行。</p>\n</blockquote>\n<p>Go 在执行阻塞的系统调用时会调用 <code>entersyscallblock</code> ，然后通过 <code>handoffp</code> 解绑 M 对应的 P。如果此时 P 的本地队列中还有 G，P 会去寻找别的 M 或创建新的 M 继续执行，若本地队列为空，则进入 <code>pidle</code> 链表，等待有需要时被取出。</p>\n<p>如果是调用的 <code>entersyscall</code>，会将 P 的状态置为 <code>_Psyscall</code>。监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现是 <code>_Psyscall</code> 状态，就会调用 <code>handoffp</code> 来释放。</p>\n<h5 id=\"抢占调度\"><a href=\"#抢占调度\" class=\"headerlink\" title=\"抢占调度\"></a>抢占调度</h5><p>在 Go1.1 版本中，是没有抢占调度的，当前 G 只有涉及到锁操作，读写 channel 才会触发切换。若没有抢占机制，同一个 M 上的其他任务 G 有可能会长时间执行不到，甚至会被死循环锁住。</p>\n<p>于是 Dmitry Vyukov 提出了<a href=\"https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit\" target=\"_blank\" rel=\"noopener\">《Go Preemptive Scheduler Design Doc》</a>, 并在1.2版本中引入了初级的抢占。</p>\n<p>监控线程 <code>sysmon</code> 会通过 <code>retake</code> 循环所有的 P，发现运行时间超出 <code>forcePreemptNS</code> 限制（10ms）的 P，就会通过 <code>preemptone</code> 发起抢占。</p>\n<h5 id=\"Goroutine-的负载均衡\"><a href=\"#Goroutine-的负载均衡\" class=\"headerlink\" title=\"Goroutine 的负载均衡\"></a>Goroutine 的负载均衡</h5><blockquote>\n<p>内核线程M不是从全局任务队列中得到G，而是从M本地维护的G缓存中获取任务。如果某个M的G执行完了，而别的M还有很多G，这时如果G不能切换将造成CPU的浪费。</p>\n</blockquote>\n<p>这部分的实现是在 M 的启动函数 <code>mstart</code> 中 <code>schedule</code> 的调用来实现，它会先查找本地队列，然后查找全局队列，最后是随机偷取其他 P 的一半 G，直到取到 G 或停掉 M。为了防止全局队列被“饿死”，每61次调度，会先在全局队列中查找。</p>\n<h4 id=\"调度器相关源码\"><a href=\"#调度器相关源码\" class=\"headerlink\" title=\"调度器相关源码\"></a>调度器相关源码</h4><p>调度器部分的代码主要集中在 <code>src/runtime/runtime2.go</code> 与 <code>src/runtime/proc.go</code> 这两个文件中。</p>\n<p>调度器的4个基本结构：g、m、p、schedt，都在 <code>runtime2.go</code> 中，<code>schedt</code> 可能有些陌生，它是调度器的核心结构，也是全局资源池，用来存储 G 的全局队列，空闲的 P 链表 <code>pidle</code>，空闲的 M 链表 <code>midle</code> 等等。</p>\n<p>调度器的具体实现函数都在 <code>proc.go</code> 中，用户的所有代码都是运行在 goroutine 中，Go 在运行时会将 <code>main</code> 中的代码放入 <code>main goroutine</code> 中运行，这时还会启动监控系统 <code>sysmon</code>。</p>\n<p>更多关于调度器的细节，例如加锁，与 GC 的交互等，需要通过进一步的阅读源码来了解。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>看到这里，相信大家对“并发”会有全新的认识，本文旨在讲清 Go 语言的并发性，在以后的 Go 语言编程过程中，希望更倾向于并发编程。并发编程不仅结构清晰，通常来说也会更容易并行运行，使得程序运行效率提高。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://talks.golang.org/2012/concurrency.slide#1\" target=\"_blank\" rel=\"noopener\">《Go Concurrency Patterns》</a></p>\n<p><a href=\"https://talks.golang.org/2012/waza.slide#1\" target=\"_blank\" rel=\"noopener\">《Concurrency is not Parallelism》</a></p>\n<p><a href=\"https://github.com/changkun/go-under-the-hood/blob/master/book/part2runtime/ch06sched/basic.md\" target=\"_blank\" rel=\"noopener\">《go-under-the-hood》</a></p>\n<p><a href=\"https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/\" target=\"_blank\" rel=\"noopener\">《也谈goroutine调度器》</a></p>\n<p><a href=\"https://ninokop.github.io/2017/12/10/Goroutine%E6%B5%85%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">《Goroutine浅析》</a></p>"},{"title":"Api安全 研究","date":"2016-07-13T12:46:25.000Z","_content":"\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","source":"_posts/API-security.md","raw":"---\ntitle: Api安全 研究\ndate: 2016/7/13 20:46:25\n---\n\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","slug":"API-security","published":1,"updated":"2019-10-21T08:56:43.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29bs0002yz79xk093cz7","content":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>\n<a id=\"more\"></a>  \n<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'data' : &#123;</span><br><span class=\"line\">\t\t'id' : 1</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t'time' : 14000000000,,</span><br><span class=\"line\">\t'token' : 'xxxxxxxxxx',</span><br><span class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></span><br><span class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></span><br><span class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</span><br><span class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></span><br><span class=\"line\">$total = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></span><br><span class=\"line\">$cycle = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></span><br><span class=\"line\">$blackTime = <span class=\"number\">600</span>;</span><br><span class=\"line\"><span class=\"comment\">// 验证黑名单</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</span><br><span class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></span><br><span class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></span><br><span class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></span><br><span class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></span><br><span class=\"line\">      $start = $k;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 存储访问记录</span></span><br><span class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</span><br><span class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>","more":"<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'data' : &#123;</span><br><span class=\"line\">\t\t'id' : 1</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t'time' : 14000000000,,</span><br><span class=\"line\">\t'token' : 'xxxxxxxxxx',</span><br><span class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></span><br><span class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></span><br><span class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</span><br><span class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></span><br><span class=\"line\">$total = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></span><br><span class=\"line\">$cycle = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></span><br><span class=\"line\">$blackTime = <span class=\"number\">600</span>;</span><br><span class=\"line\"><span class=\"comment\">// 验证黑名单</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</span><br><span class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></span><br><span class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></span><br><span class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></span><br><span class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></span><br><span class=\"line\">      $start = $k;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</span><br><span class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 存储访问记录</span></span><br><span class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</span><br><span class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</span><br></pre></td></tr></table></figure></p>"},{"title":"JSON Schema","date":"2018-12-01T11:18:17.000Z","_content":"\n**JSON Schema 详解：未完待续**\n\n<!--more-->  \n\n## 第一篇：了解 JSON\n\n#### 介绍\n\nJSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《[Standard ECMA-262 3rd Edition - December 1999](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)》的一个子集，而后成为写入 RFC 文档：[RFC 4627](https://tools.ietf.org/html/rfc4627)，最新的 RFC 标准为：[RFC 8259](https://tools.ietf.org/html/rfc8259)。\n\nJSON 的官方 MIME 类型是 `application/json`，文件扩展名是 `.json`。\n\n#### 类型\n\n**两种结构化类型**：\n\n* Object：`名称/值`的集合（A collection of name/value pairs），在不同的语言中，被理解为 `object`，`record`，`struct`，`dictionary`，`hash table` 等等。\n    * 使用大括号`{`，`}`包裹`名称/值`的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用`:`分隔。`名称/值`之间使用`,`分隔。\n    * 格式示例：`{\"example\":\"string\"}`。\n* Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 `array`。\n    * 使用中括号`[`，`]`包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。\n    * 格式示例：`[0,\"1\",null,false,true,{},[]]`。\n\n**四种基本类型**：\n\n* 字符串（string）\n    * 字符串是 Unicode 字符组成的集合，使用双引号包裹（`\"`），反斜杠转义（`\\`）。\n    * 与 C 或 Java 的字符串相似。\n* 数值（number）\n    * 使用十进制，可以为负数或者小数。还可以用`e`或者`E`表示为指数形式。\n    * 数值也与 C 或 Java 的数值相似。\n* 布尔（boolean）\n    * `true` 或 `false`。\n* 空（null）\n    * `null`。\n\n**Tips**：\n\n* 值的是可以嵌套的。\n* 名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。\n* 符号中间允许空白字符。\n* JSON 没有限制必须以 `object` 或结构类型作为顶层类型。\n* 但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 `object` 作为顶层类型。\n* 上述的集合或列表（string，object，array）可以是空集或空列。\n\n#### 示例\n\n```\n# Object\n{\n    \"Image\": {\n        \"Width\":  800,\n        \"Height\": 600,\n        \"Title\":  \"View from 15th Floor\",\n        \"Thumbnail\": {\n            \"Url\":    \"http://www.example.com/image/481989943\",\n            \"Height\": 125,\n            \"Width\":  100\n        },\n        \"Animated\" : false,\n        \"IDs\": [116, 943, 234, 38793]\n    }\n}\n\n# Array\n[\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.7668,\n        \"Longitude\": -122.3959,\n        \"Address\":   \"\",\n        \"City\":      \"SAN FRANCISCO\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94107\",\n        \"Country\":   \"US\"\n    },\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.371991,\n        \"Longitude\": -122.026020,\n        \"Address\":   \"\",\n        \"City\":      \"SUNNYVALE\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94085\",\n        \"Country\":   \"US\"\n    }\n]\n\n# Only values\n\n\"Hello world!\"\n\n42\n\ntrue\n\nnull\n```\n\n## 第二篇：介绍\n\n#### 版本\n\n当前版本：[draft-07](http://json-schema.org/specification.html)。\n\n#### 简介\n\nJSON Schema 是一个用于**注释**和**验证** JSON documents 的词汇表。\n\nJSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。\n\n#### 用途\n\n* 对数据结构进行描述\n* 构建人机可读的文档\n* 校验数据\n\n#### 项目状态\n\n共有三个规范：\n\n* [JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n* [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/)\n* [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/)\n\n项目组正在努力使它们成为正式的 RFC 标准。\n\n*[draft-08](https://github.com/json-schema-org/json-schema-spec/milestone/6)*\n\n#### 如何应用\n\n可以用于生成模拟数据，确保接近真实数据。\n\n用于校验数据，实现自动化测试。\n\n多端共用同一份验证。\n\n## 第三篇：Core 规范\n\n#### 简介\n\n[JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n\n此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。\n\n#### 状态\n\n草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：[https://datatracker.ietf.org/doc/draft-handrews-json-schema/](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)。\n\n#### 概述\n\n**媒体类型**\n\nJSON 的媒体类型：[application/json](https://tools.ietf.org/html/rfc8259#section-1.2) 。\n\nJSON Schema 的媒体类型为 `application/schema+json`，它还有另外一种可选媒体类型用于提供额外的扩展功能：`application/schema-instance+json`。\n\n**验证**\n\nJSON Schema 描述了 `JSON 文档(JSON document)` 的结构，例如属性、长度限制等，程序可以以此判断 `实例(Instance)` 是否符合规范。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**注释**\n\nJSON Schema 可以对 `实例(Instance)` 添加注释。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**超媒体与链接**\n\nJSON Hyper-Schema 描述了  `JSON 文档(JSON document)` 的超文本结构，包括 `实例(Instance)` 中的资源链接关系等。\n\n规范与关键字在 [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/) 中定义。\n\n#### 定义\n\n**JSON Document**\n\n`JSON 文档(JSON document)` 是使用 `application/json` 媒体类型描述的资源。\n\n简言之就是 JSON 值。\n\n*JSON Schema 中， `JSON 值(JSON value)`、`JSON 文本(JSON text)`、`JSON 文档(JSON document)`是等义词。*\n\n*JSON Schema 也是 `JSON 文档(JSON document)`。*\n\n**Instance**\n\n`实例(Instance)` 是使用 JSON Schema 描述的 `JSON 文档(JSON document)`。\n\n**JSON Schema document**\n\n使用 `application/schema+json` 媒体类型描述的 `JSON 文档(JSON document)`，简称 schema。\n\n#### 关键字\n\n**$schema**\n\n`$schema` 关键字用于声明当前 `JSON 文档(JSON document)` 是 `JSON Schema document`。\n\n值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$id**\n\n`$id` 关键字用于定义 schema 基本的 URI，可用于 `$ref` 的引用标识，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$ref**\n\n`$ref` 关键字用于定义引用 schema，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\nURI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。\n\n如果有两个 schema 互相使用 `$ref` 进行引用，不应该陷入无限循环。\n\n**$comment**\n\n`$comment` 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。","source":"_posts/JSON Schema.md","raw":"---\ntitle: JSON Schema\ndate: 2018/12/1 19:18:17\n---\n\n**JSON Schema 详解：未完待续**\n\n<!--more-->  \n\n## 第一篇：了解 JSON\n\n#### 介绍\n\nJSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《[Standard ECMA-262 3rd Edition - December 1999](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)》的一个子集，而后成为写入 RFC 文档：[RFC 4627](https://tools.ietf.org/html/rfc4627)，最新的 RFC 标准为：[RFC 8259](https://tools.ietf.org/html/rfc8259)。\n\nJSON 的官方 MIME 类型是 `application/json`，文件扩展名是 `.json`。\n\n#### 类型\n\n**两种结构化类型**：\n\n* Object：`名称/值`的集合（A collection of name/value pairs），在不同的语言中，被理解为 `object`，`record`，`struct`，`dictionary`，`hash table` 等等。\n    * 使用大括号`{`，`}`包裹`名称/值`的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用`:`分隔。`名称/值`之间使用`,`分隔。\n    * 格式示例：`{\"example\":\"string\"}`。\n* Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 `array`。\n    * 使用中括号`[`，`]`包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。\n    * 格式示例：`[0,\"1\",null,false,true,{},[]]`。\n\n**四种基本类型**：\n\n* 字符串（string）\n    * 字符串是 Unicode 字符组成的集合，使用双引号包裹（`\"`），反斜杠转义（`\\`）。\n    * 与 C 或 Java 的字符串相似。\n* 数值（number）\n    * 使用十进制，可以为负数或者小数。还可以用`e`或者`E`表示为指数形式。\n    * 数值也与 C 或 Java 的数值相似。\n* 布尔（boolean）\n    * `true` 或 `false`。\n* 空（null）\n    * `null`。\n\n**Tips**：\n\n* 值的是可以嵌套的。\n* 名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。\n* 符号中间允许空白字符。\n* JSON 没有限制必须以 `object` 或结构类型作为顶层类型。\n* 但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 `object` 作为顶层类型。\n* 上述的集合或列表（string，object，array）可以是空集或空列。\n\n#### 示例\n\n```\n# Object\n{\n    \"Image\": {\n        \"Width\":  800,\n        \"Height\": 600,\n        \"Title\":  \"View from 15th Floor\",\n        \"Thumbnail\": {\n            \"Url\":    \"http://www.example.com/image/481989943\",\n            \"Height\": 125,\n            \"Width\":  100\n        },\n        \"Animated\" : false,\n        \"IDs\": [116, 943, 234, 38793]\n    }\n}\n\n# Array\n[\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.7668,\n        \"Longitude\": -122.3959,\n        \"Address\":   \"\",\n        \"City\":      \"SAN FRANCISCO\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94107\",\n        \"Country\":   \"US\"\n    },\n    {\n        \"precision\": \"zip\",\n        \"Latitude\":  37.371991,\n        \"Longitude\": -122.026020,\n        \"Address\":   \"\",\n        \"City\":      \"SUNNYVALE\",\n        \"State\":     \"CA\",\n        \"Zip\":       \"94085\",\n        \"Country\":   \"US\"\n    }\n]\n\n# Only values\n\n\"Hello world!\"\n\n42\n\ntrue\n\nnull\n```\n\n## 第二篇：介绍\n\n#### 版本\n\n当前版本：[draft-07](http://json-schema.org/specification.html)。\n\n#### 简介\n\nJSON Schema 是一个用于**注释**和**验证** JSON documents 的词汇表。\n\nJSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。\n\n#### 用途\n\n* 对数据结构进行描述\n* 构建人机可读的文档\n* 校验数据\n\n#### 项目状态\n\n共有三个规范：\n\n* [JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n* [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/)\n* [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/)\n\n项目组正在努力使它们成为正式的 RFC 标准。\n\n*[draft-08](https://github.com/json-schema-org/json-schema-spec/milestone/6)*\n\n#### 如何应用\n\n可以用于生成模拟数据，确保接近真实数据。\n\n用于校验数据，实现自动化测试。\n\n多端共用同一份验证。\n\n## 第三篇：Core 规范\n\n#### 简介\n\n[JSON Schema (core)](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)\n\n此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。\n\n#### 状态\n\n草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：[https://datatracker.ietf.org/doc/draft-handrews-json-schema/](https://datatracker.ietf.org/doc/draft-handrews-json-schema/)。\n\n#### 概述\n\n**媒体类型**\n\nJSON 的媒体类型：[application/json](https://tools.ietf.org/html/rfc8259#section-1.2) 。\n\nJSON Schema 的媒体类型为 `application/schema+json`，它还有另外一种可选媒体类型用于提供额外的扩展功能：`application/schema-instance+json`。\n\n**验证**\n\nJSON Schema 描述了 `JSON 文档(JSON document)` 的结构，例如属性、长度限制等，程序可以以此判断 `实例(Instance)` 是否符合规范。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**注释**\n\nJSON Schema 可以对 `实例(Instance)` 添加注释。\n\n规范与关键字在 [JSON Schema Validation](https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/) 中定义。\n\n**超媒体与链接**\n\nJSON Hyper-Schema 描述了  `JSON 文档(JSON document)` 的超文本结构，包括 `实例(Instance)` 中的资源链接关系等。\n\n规范与关键字在 [JSON Hyper-Schema](https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/) 中定义。\n\n#### 定义\n\n**JSON Document**\n\n`JSON 文档(JSON document)` 是使用 `application/json` 媒体类型描述的资源。\n\n简言之就是 JSON 值。\n\n*JSON Schema 中， `JSON 值(JSON value)`、`JSON 文本(JSON text)`、`JSON 文档(JSON document)`是等义词。*\n\n*JSON Schema 也是 `JSON 文档(JSON document)`。*\n\n**Instance**\n\n`实例(Instance)` 是使用 JSON Schema 描述的 `JSON 文档(JSON document)`。\n\n**JSON Schema document**\n\n使用 `application/schema+json` 媒体类型描述的 `JSON 文档(JSON document)`，简称 schema。\n\n#### 关键字\n\n**$schema**\n\n`$schema` 关键字用于声明当前 `JSON 文档(JSON document)` 是 `JSON Schema document`。\n\n值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$id**\n\n`$id` 关键字用于定义 schema 基本的 URI，可用于 `$ref` 的引用标识，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\n**$ref**\n\n`$ref` 关键字用于定义引用 schema，值必须是 [URI](https://tools.ietf.org/html/rfc3986)。\n\nURI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。\n\n如果有两个 schema 互相使用 `$ref` 进行引用，不应该陷入无限循环。\n\n**$comment**\n\n`$comment` 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。","slug":"JSON Schema","published":1,"updated":"2019-06-10T08:23:44.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29bu0004yz79swvs1u50","content":"<p><strong>JSON Schema 详解：未完待续</strong></p>\n<a id=\"more\"></a>  \n<h2 id=\"第一篇：了解-JSON\"><a href=\"#第一篇：了解-JSON\" class=\"headerlink\" title=\"第一篇：了解 JSON\"></a>第一篇：了解 JSON</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>JSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"noopener\">Standard ECMA-262 3rd Edition - December 1999</a>》的一个子集，而后成为写入 RFC 文档：<a href=\"https://tools.ietf.org/html/rfc4627\" target=\"_blank\" rel=\"noopener\">RFC 4627</a>，最新的 RFC 标准为：<a href=\"https://tools.ietf.org/html/rfc8259\" target=\"_blank\" rel=\"noopener\">RFC 8259</a>。</p>\n<p>JSON 的官方 MIME 类型是 <code>application/json</code>，文件扩展名是 <code>.json</code>。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><strong>两种结构化类型</strong>：</p>\n<ul>\n<li>Object：<code>名称/值</code>的集合（A collection of name/value pairs），在不同的语言中，被理解为 <code>object</code>，<code>record</code>，<code>struct</code>，<code>dictionary</code>，<code>hash table</code> 等等。<ul>\n<li>使用大括号<code>{</code>，<code>}</code>包裹<code>名称/值</code>的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用<code>:</code>分隔。<code>名称/值</code>之间使用<code>,</code>分隔。</li>\n<li>格式示例：<code>{&quot;example&quot;:&quot;string&quot;}</code>。</li>\n</ul>\n</li>\n<li>Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 <code>array</code>。<ul>\n<li>使用中括号<code>[</code>，<code>]</code>包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。</li>\n<li>格式示例：<code>[0,&quot;1&quot;,null,false,true,{},[]]</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>四种基本类型</strong>：</p>\n<ul>\n<li>字符串（string）<ul>\n<li>字符串是 Unicode 字符组成的集合，使用双引号包裹（<code>&quot;</code>），反斜杠转义（<code>\\</code>）。</li>\n<li>与 C 或 Java 的字符串相似。</li>\n</ul>\n</li>\n<li>数值（number）<ul>\n<li>使用十进制，可以为负数或者小数。还可以用<code>e</code>或者<code>E</code>表示为指数形式。</li>\n<li>数值也与 C 或 Java 的数值相似。</li>\n</ul>\n</li>\n<li>布尔（boolean）<ul>\n<li><code>true</code> 或 <code>false</code>。</li>\n</ul>\n</li>\n<li>空（null）<ul>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Tips</strong>：</p>\n<ul>\n<li>值的是可以嵌套的。</li>\n<li>名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。</li>\n<li>符号中间允许空白字符。</li>\n<li>JSON 没有限制必须以 <code>object</code> 或结构类型作为顶层类型。</li>\n<li>但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 <code>object</code> 作为顶层类型。</li>\n<li>上述的集合或列表（string，object，array）可以是空集或空列。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;Image&quot;: &#123;</span><br><span class=\"line\">        &quot;Width&quot;:  800,</span><br><span class=\"line\">        &quot;Height&quot;: 600,</span><br><span class=\"line\">        &quot;Title&quot;:  &quot;View from 15th Floor&quot;,</span><br><span class=\"line\">        &quot;Thumbnail&quot;: &#123;</span><br><span class=\"line\">            &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,</span><br><span class=\"line\">            &quot;Height&quot;: 125,</span><br><span class=\"line\">            &quot;Width&quot;:  100</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;Animated&quot; : false,</span><br><span class=\"line\">        &quot;IDs&quot;: [116, 943, 234, 38793]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># Array</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.7668,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.3959,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94107&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.371991,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.026020,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SUNNYVALE&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94085&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"># Only values</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;Hello world!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">42</span><br><span class=\"line\"></span><br><span class=\"line\">true</span><br><span class=\"line\"></span><br><span class=\"line\">null</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二篇：介绍\"><a href=\"#第二篇：介绍\" class=\"headerlink\" title=\"第二篇：介绍\"></a>第二篇：介绍</h2><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><p>当前版本：<a href=\"http://json-schema.org/specification.html\" target=\"_blank\" rel=\"noopener\">draft-07</a>。</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>JSON Schema 是一个用于<strong>注释</strong>和<strong>验证</strong> JSON documents 的词汇表。</p>\n<p>JSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>对数据结构进行描述</li>\n<li>构建人机可读的文档</li>\n<li>校验数据</li>\n</ul>\n<h4 id=\"项目状态\"><a href=\"#项目状态\" class=\"headerlink\" title=\"项目状态\"></a>项目状态</h4><p>共有三个规范：</p>\n<ul>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a></li>\n</ul>\n<p>项目组正在努力使它们成为正式的 RFC 标准。</p>\n<p><em><a href=\"https://github.com/json-schema-org/json-schema-spec/milestone/6\" target=\"_blank\" rel=\"noopener\">draft-08</a></em></p>\n<h4 id=\"如何应用\"><a href=\"#如何应用\" class=\"headerlink\" title=\"如何应用\"></a>如何应用</h4><p>可以用于生成模拟数据，确保接近真实数据。</p>\n<p>用于校验数据，实现自动化测试。</p>\n<p>多端共用同一份验证。</p>\n<h2 id=\"第三篇：Core-规范\"><a href=\"#第三篇：Core-规范\" class=\"headerlink\" title=\"第三篇：Core 规范\"></a>第三篇：Core 规范</h2><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></p>\n<p>此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：<a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">https://datatracker.ietf.org/doc/draft-handrews-json-schema/</a>。</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><strong>媒体类型</strong></p>\n<p>JSON 的媒体类型：<a href=\"https://tools.ietf.org/html/rfc8259#section-1.2\" target=\"_blank\" rel=\"noopener\">application/json</a> 。</p>\n<p>JSON Schema 的媒体类型为 <code>application/schema+json</code>，它还有另外一种可选媒体类型用于提供额外的扩展功能：<code>application/schema-instance+json</code>。</p>\n<p><strong>验证</strong></p>\n<p>JSON Schema 描述了 <code>JSON 文档(JSON document)</code> 的结构，例如属性、长度限制等，程序可以以此判断 <code>实例(Instance)</code> 是否符合规范。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>注释</strong></p>\n<p>JSON Schema 可以对 <code>实例(Instance)</code> 添加注释。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>超媒体与链接</strong></p>\n<p>JSON Hyper-Schema 描述了  <code>JSON 文档(JSON document)</code> 的超文本结构，包括 <code>实例(Instance)</code> 中的资源链接关系等。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a> 中定义。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>JSON Document</strong></p>\n<p><code>JSON 文档(JSON document)</code> 是使用 <code>application/json</code> 媒体类型描述的资源。</p>\n<p>简言之就是 JSON 值。</p>\n<p><em>JSON Schema 中， <code>JSON 值(JSON value)</code>、<code>JSON 文本(JSON text)</code>、<code>JSON 文档(JSON document)</code>是等义词。</em></p>\n<p><em>JSON Schema 也是 <code>JSON 文档(JSON document)</code>。</em></p>\n<p><strong>Instance</strong></p>\n<p><code>实例(Instance)</code> 是使用 JSON Schema 描述的 <code>JSON 文档(JSON document)</code>。</p>\n<p><strong>JSON Schema document</strong></p>\n<p>使用 <code>application/schema+json</code> 媒体类型描述的 <code>JSON 文档(JSON document)</code>，简称 schema。</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p><strong>$schema</strong></p>\n<p><code>$schema</code> 关键字用于声明当前 <code>JSON 文档(JSON document)</code> 是 <code>JSON Schema document</code>。</p>\n<p>值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$id</strong></p>\n<p><code>$id</code> 关键字用于定义 schema 基本的 URI，可用于 <code>$ref</code> 的引用标识，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$ref</strong></p>\n<p><code>$ref</code> 关键字用于定义引用 schema，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p>URI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。</p>\n<p>如果有两个 schema 互相使用 <code>$ref</code> 进行引用，不应该陷入无限循环。</p>\n<p><strong>$comment</strong></p>\n<p><code>$comment</code> 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。</p>\n","site":{"data":{}},"excerpt":"<p><strong>JSON Schema 详解：未完待续</strong></p>","more":"<h2 id=\"第一篇：了解-JSON\"><a href=\"#第一篇：了解-JSON\" class=\"headerlink\" title=\"第一篇：了解 JSON\"></a>第一篇：了解 JSON</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>JSON（JavaScriptObjectNotation） 是一种轻量级、基于文本、不限语言的数据交换格式，源自 ECMAScript，《<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"noopener\">Standard ECMA-262 3rd Edition - December 1999</a>》的一个子集，而后成为写入 RFC 文档：<a href=\"https://tools.ietf.org/html/rfc4627\" target=\"_blank\" rel=\"noopener\">RFC 4627</a>，最新的 RFC 标准为：<a href=\"https://tools.ietf.org/html/rfc8259\" target=\"_blank\" rel=\"noopener\">RFC 8259</a>。</p>\n<p>JSON 的官方 MIME 类型是 <code>application/json</code>，文件扩展名是 <code>.json</code>。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><strong>两种结构化类型</strong>：</p>\n<ul>\n<li>Object：<code>名称/值</code>的集合（A collection of name/value pairs），在不同的语言中，被理解为 <code>object</code>，<code>record</code>，<code>struct</code>，<code>dictionary</code>，<code>hash table</code> 等等。<ul>\n<li>使用大括号<code>{</code>，<code>}</code>包裹<code>名称/值</code>的集合，名称是字符串类型，值可以是以上任意类型。名称与值使用<code>:</code>分隔。<code>名称/值</code>之间使用<code>,</code>分隔。</li>\n<li>格式示例：<code>{&quot;example&quot;:&quot;string&quot;}</code>。</li>\n</ul>\n</li>\n<li>Array：值的有序列表（An ordered list of values），在大部分语言中，被理解为 <code>array</code>。<ul>\n<li>使用中括号<code>[</code>，<code>]</code>包裹值的列表，值可以是以上任意类型。值与值之间使用`,``分隔。</li>\n<li>格式示例：<code>[0,&quot;1&quot;,null,false,true,{},[]]</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>四种基本类型</strong>：</p>\n<ul>\n<li>字符串（string）<ul>\n<li>字符串是 Unicode 字符组成的集合，使用双引号包裹（<code>&quot;</code>），反斜杠转义（<code>\\</code>）。</li>\n<li>与 C 或 Java 的字符串相似。</li>\n</ul>\n</li>\n<li>数值（number）<ul>\n<li>使用十进制，可以为负数或者小数。还可以用<code>e</code>或者<code>E</code>表示为指数形式。</li>\n<li>数值也与 C 或 Java 的数值相似。</li>\n</ul>\n</li>\n<li>布尔（boolean）<ul>\n<li><code>true</code> 或 <code>false</code>。</li>\n</ul>\n</li>\n<li>空（null）<ul>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Tips</strong>：</p>\n<ul>\n<li>值的是可以嵌套的。</li>\n<li>名称是字符串类型，也就是说可以是任意 Unicode 字符，但是不推荐使用英文以外的语言，虽然 JSON 允许，但是有些使用 JSON 的语言可能不支持。</li>\n<li>符号中间允许空白字符。</li>\n<li>JSON 没有限制必须以 <code>object</code> 或结构类型作为顶层类型。</li>\n<li>但是某些语言解析某种类型会更加方便，比如给 ios 最好是使用 <code>object</code> 作为顶层类型。</li>\n<li>上述的集合或列表（string，object，array）可以是空集或空列。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;Image&quot;: &#123;</span><br><span class=\"line\">        &quot;Width&quot;:  800,</span><br><span class=\"line\">        &quot;Height&quot;: 600,</span><br><span class=\"line\">        &quot;Title&quot;:  &quot;View from 15th Floor&quot;,</span><br><span class=\"line\">        &quot;Thumbnail&quot;: &#123;</span><br><span class=\"line\">            &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,</span><br><span class=\"line\">            &quot;Height&quot;: 125,</span><br><span class=\"line\">            &quot;Width&quot;:  100</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;Animated&quot; : false,</span><br><span class=\"line\">        &quot;IDs&quot;: [116, 943, 234, 38793]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># Array</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.7668,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.3959,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94107&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;precision&quot;: &quot;zip&quot;,</span><br><span class=\"line\">        &quot;Latitude&quot;:  37.371991,</span><br><span class=\"line\">        &quot;Longitude&quot;: -122.026020,</span><br><span class=\"line\">        &quot;Address&quot;:   &quot;&quot;,</span><br><span class=\"line\">        &quot;City&quot;:      &quot;SUNNYVALE&quot;,</span><br><span class=\"line\">        &quot;State&quot;:     &quot;CA&quot;,</span><br><span class=\"line\">        &quot;Zip&quot;:       &quot;94085&quot;,</span><br><span class=\"line\">        &quot;Country&quot;:   &quot;US&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"># Only values</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;Hello world!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">42</span><br><span class=\"line\"></span><br><span class=\"line\">true</span><br><span class=\"line\"></span><br><span class=\"line\">null</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二篇：介绍\"><a href=\"#第二篇：介绍\" class=\"headerlink\" title=\"第二篇：介绍\"></a>第二篇：介绍</h2><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><p>当前版本：<a href=\"http://json-schema.org/specification.html\" target=\"_blank\" rel=\"noopener\">draft-07</a>。</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>JSON Schema 是一个用于<strong>注释</strong>和<strong>验证</strong> JSON documents 的词汇表。</p>\n<p>JSON Schema 本身也是基于 JSON 格式，并且提供了一系列的规范，用于描述 JSON 数据的结构，旨在定义 JSON 数据的验证，文档，超链接导航和交互控制。</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>对数据结构进行描述</li>\n<li>构建人机可读的文档</li>\n<li>校验数据</li>\n</ul>\n<h4 id=\"项目状态\"><a href=\"#项目状态\" class=\"headerlink\" title=\"项目状态\"></a>项目状态</h4><p>共有三个规范：</p>\n<ul>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a></li>\n</ul>\n<p>项目组正在努力使它们成为正式的 RFC 标准。</p>\n<p><em><a href=\"https://github.com/json-schema-org/json-schema-spec/milestone/6\" target=\"_blank\" rel=\"noopener\">draft-08</a></em></p>\n<h4 id=\"如何应用\"><a href=\"#如何应用\" class=\"headerlink\" title=\"如何应用\"></a>如何应用</h4><p>可以用于生成模拟数据，确保接近真实数据。</p>\n<p>用于校验数据，实现自动化测试。</p>\n<p>多端共用同一份验证。</p>\n<h2 id=\"第三篇：Core-规范\"><a href=\"#第三篇：Core-规范\" class=\"headerlink\" title=\"第三篇：Core 规范\"></a>第三篇：Core 规范</h2><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">JSON Schema (core)</a></p>\n<p>此规范主要是定义了核心术语、机制，包括引用其他 JSON Schema，以及正在使用的词汇表。</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>草案目前于2018年03月19日最后更新，到期时间2018年09月20日，ietf地址：<a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema/\" target=\"_blank\" rel=\"noopener\">https://datatracker.ietf.org/doc/draft-handrews-json-schema/</a>。</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><strong>媒体类型</strong></p>\n<p>JSON 的媒体类型：<a href=\"https://tools.ietf.org/html/rfc8259#section-1.2\" target=\"_blank\" rel=\"noopener\">application/json</a> 。</p>\n<p>JSON Schema 的媒体类型为 <code>application/schema+json</code>，它还有另外一种可选媒体类型用于提供额外的扩展功能：<code>application/schema-instance+json</code>。</p>\n<p><strong>验证</strong></p>\n<p>JSON Schema 描述了 <code>JSON 文档(JSON document)</code> 的结构，例如属性、长度限制等，程序可以以此判断 <code>实例(Instance)</code> 是否符合规范。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>注释</strong></p>\n<p>JSON Schema 可以对 <code>实例(Instance)</code> 添加注释。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-validation/\" target=\"_blank\" rel=\"noopener\">JSON Schema Validation</a> 中定义。</p>\n<p><strong>超媒体与链接</strong></p>\n<p>JSON Hyper-Schema 描述了  <code>JSON 文档(JSON document)</code> 的超文本结构，包括 <code>实例(Instance)</code> 中的资源链接关系等。</p>\n<p>规范与关键字在 <a href=\"https://datatracker.ietf.org/doc/draft-handrews-json-schema-hyperschema/\" target=\"_blank\" rel=\"noopener\">JSON Hyper-Schema</a> 中定义。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>JSON Document</strong></p>\n<p><code>JSON 文档(JSON document)</code> 是使用 <code>application/json</code> 媒体类型描述的资源。</p>\n<p>简言之就是 JSON 值。</p>\n<p><em>JSON Schema 中， <code>JSON 值(JSON value)</code>、<code>JSON 文本(JSON text)</code>、<code>JSON 文档(JSON document)</code>是等义词。</em></p>\n<p><em>JSON Schema 也是 <code>JSON 文档(JSON document)</code>。</em></p>\n<p><strong>Instance</strong></p>\n<p><code>实例(Instance)</code> 是使用 JSON Schema 描述的 <code>JSON 文档(JSON document)</code>。</p>\n<p><strong>JSON Schema document</strong></p>\n<p>使用 <code>application/schema+json</code> 媒体类型描述的 <code>JSON 文档(JSON document)</code>，简称 schema。</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p><strong>$schema</strong></p>\n<p><code>$schema</code> 关键字用于声明当前 <code>JSON 文档(JSON document)</code> 是 <code>JSON Schema document</code>。</p>\n<p>值可以是 JSON Schema 版本的标识符，也是资源的位置，但必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$id</strong></p>\n<p><code>$id</code> 关键字用于定义 schema 基本的 URI，可用于 <code>$ref</code> 的引用标识，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p><strong>$ref</strong></p>\n<p><code>$ref</code> 关键字用于定义引用 schema，值必须是 <a href=\"https://tools.ietf.org/html/rfc3986\" target=\"_blank\" rel=\"noopener\">URI</a>。</p>\n<p>URI 只是标识符，不是网络定位器。如果 URI 是可以访问的 URL，不应该去下载。</p>\n<p>如果有两个 schema 互相使用 <code>$ref</code> 进行引用，不应该陷入无限循环。</p>\n<p><strong>$comment</strong></p>\n<p><code>$comment</code> 用于 schema 开发人员对文档进行注释，不需要展示给最终用户看。</p>"},{"title":"RESTful API 实践","date":"2016-10-11T11:18:17.000Z","_content":"\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n由于不符合超媒体，现在是 HTTP API。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ...\n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求)\n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在\n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n","source":"_posts/RESTful-API-Practice.md","raw":"---\ntitle: RESTful API 实践\ndate: 2016/10/11 19:18:17\n---\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n由于不符合超媒体，现在是 HTTP API。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ...\n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求)\n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在\n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n","slug":"RESTful-API-Practice","published":1,"updated":"2019-10-21T08:58:29.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29bw0006yz79bjd5a81z","content":"<p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<p>由于不符合超媒体，现在是 HTTP API。</p>\n<a id=\"more\"></a>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sortby=level&amp;order=asc</span><br></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sort=-type，created_at</span><br></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?offset=10 - 偏移量</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?embed=department.name，job</span><br></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</span><br><span class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</span><br><span class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</span><br></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'message': 'Invalid Token'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'code' : 10010，</span><br><span class=\"line\">\t'message': 'Insufficient balance'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback_function(&#123;</span><br><span class=\"line\">\tstatus_code: 200，</span><br><span class=\"line\">\tnext_page: &quot;https://..&quot;，</span><br><span class=\"line\">\tresponse: &#123;</span><br><span class=\"line\">\t\t... 正常的 JSON 实体 ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求)</p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在</p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"noopener\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"noopener\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</span><br><span class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</span><br><span class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</span><br><span class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</span><br><span class=\"line\">它成为了现代 Web 架构的基础。</span><br><span class=\"line\"></span><br><span class=\"line\">出自[中文译版] 结论</span><br></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"noopener\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"noopener\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"noopener\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"noopener\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"noopener\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"noopener\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">HTTP缓存 这里主要是讲的Etag</a></p>\n","site":{"data":{}},"excerpt":"<p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<p>由于不符合超媒体，现在是 HTTP API。</p>","more":"<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sortby=level&amp;order=asc</span><br></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?sort=-type，created_at</span><br></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?offset=10 - 偏移量</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</span><br><span class=\"line\">?limit=10 - 返回数量</span><br></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?embed=department.name，job</span><br></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</span><br><span class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</span><br><span class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</span><br><span class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</span><br></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'message': 'Invalid Token'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t'code' : 10010，</span><br><span class=\"line\">\t'message': 'Insufficient balance'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback_function(&#123;</span><br><span class=\"line\">\tstatus_code: 200，</span><br><span class=\"line\">\tnext_page: &quot;https://..&quot;，</span><br><span class=\"line\">\tresponse: &#123;</span><br><span class=\"line\">\t\t... 正常的 JSON 实体 ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求)</p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在</p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"noopener\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"noopener\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"noopener\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</span><br><span class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</span><br><span class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</span><br><span class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</span><br><span class=\"line\">它成为了现代 Web 架构的基础。</span><br><span class=\"line\"></span><br><span class=\"line\">出自[中文译版] 结论</span><br></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"noopener\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"noopener\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"noopener\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"noopener\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"noopener\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"noopener\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"noopener\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"noopener\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">HTTP缓存 这里主要是讲的Etag</a></p>"},{"title":"OAuth2.0 与 oauth2-server 库的使用","date":"2018-11-22T12:08:09.000Z","_content":"\n[OAuth2.0](https://en.wikipedia.org/wiki/OAuth) 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。\n\n[league/oauth2-server](https://github.com/thephpleague/oauth2-server) 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。\n\n本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。\n\n<!--more-->  \n\n## 术语\n\n了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。\n\n**OAuth2.0 定义了四个角色**\n\n1. **Client**：客户端，第三方应用程序。\n2. **Resource Owner**：资源所有者，授权 Client 访问其帐户的用户。\n3. **Authorization server**：授权服务器，服务商专用于处理用户授权认证的服务器。\n4. **Resource server**：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。\n\n**oauth2-server**\n\n1. **Access token**：用于访问受保护资源的令牌。\n2. **Authorization code**：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。\n3. **Scope**：授予应用程序的权限范围。\n4. **JWT**：[Json Web Token](https://tools.ietf.org/html/rfc7519) 是一种用于安全传输的数据传输格式。\n\n\n## 运行流程\n![flowchart.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg)\n\n\n## 安装\n\n推荐使用 [Composer](https://getcomposer.org/) 进行安装：\n\n```string\ncomposer require league/oauth2-server\n```\n\n根据[授权模式](#授权模式)的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。\n\n*本文发布时，版本号为7.3.1。*\n\n\n\n**生成公钥与私钥**\n\n公钥与私钥用于签名和验证传输的 [JWT](https://tools.ietf.org/html/rfc7519)，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。\n\n*oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。*\n\n生成私钥，在终端中运行：\n\n```string\nopenssl genrsa -out private.key 2048\n```\n\n使用私钥提取私钥：\n\n```string\nopenssl rsa -in private.key -pubout -out public.key\n```\n\n私钥必须保密于授权服务器中，并将公钥分发给资源服务器。\n\n\n\n**生成加密密钥**\n\n加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，`string` 或 `defuse/php-encryption` 库的对象。\n\n*加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。*\n\n生成字符串密钥，在终端中输入：\n\n```string\nphp -r 'echo base64_encode(random_bytes(32)), PHP_EOL;'\n```\n\n生成对象，在项目根目录的终端中输入：\n\n```string\nvendor/bin/generate-defuse-key\n```\n\n将获得的内容，传入 AuthorizationServer：\n\n```php\nuse \\Defuse\\Crypto\\Key;\n$server = new AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKeyPath,\n    Key::loadFromAsciiSafeString($encryptionKey) //传入加密密钥\n);\n```\n\n\n\n**PHP版本支持**\n\n- PHP 7.0\n- PHP 7.1\n- PHP 7.2\n\n\n\n## 授权模式\n\nOAuth2.0 定义了四种授权模式，以应对不同情况时的授权。\n\n1. 授权码模式\n2. 隐式授权模式\n3. 密码模式\n4. 客户端模式\n\n\n\n## 客户端类型 \n\n* 保密的：\n\t* 客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）\n* 公开的：\n\t* 客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）\n\n\n\n## 选用哪种授权模式？\n\n如果客户端是保密的，应使用[授权码模式](#授权码模式)。\n\n如果客户端是公开的，应使用[隐式授权模式](#隐式授权模式)。\n\n如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用[密码模式](#密码模式)。\n\n如果客户端是以自己的名义，不与用户产生关系，应使用[客户端模式](#客户端模式)。\n\n\n## 预先注册\n\n客户端需要预先在授权服务器进行注册，用以获取 `client_id` 与 `client_secret`，也可以在注册是预先设定好 `redirect_uri`，以便于之后可以使用默认的 `redirect_uri`。\n\n\n## 授权码模式\n\n授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。\n\n#### 流程\n\n**第一部分（用户可见）**\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n *  `response_type`：授权类型，必选项，值固定为：`code`\n *   `client_id`：客户端ID，必选项\n *  `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n *  `scope`：权限范围，可选项，以空格分隔\n *  `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n* `code`：授权码(Authorization code)\n* `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序\n\n**第二部分（用户不可见）**\n\n客户端已得到授权，通过 `POST` 请求向授权服务器获取访问令牌(access token)：\n\n* `grant_type`：授权模式，值固定为：`authorization_code`\n* `client_id`：客户端ID\n* `client_secret`：客户端 secret\n* `redirect_uri`：使用与第一部分请求相同的 URI\n* `code`：第一部分所获的的授权码，要注意URL解码\n\n授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：\n\n* `token_type`：令牌类型，值固定为：`Bearer`\n\n* `expires_in`：访问令牌的存活时间\n\n* `access_token`：访问令牌\n\n* `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n\n#### 使用 oauth2-server 实现\n\n##### 初始化\n\nOAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 [Interfaces](#Interfaces) 与 [Traits](#Traits) 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 [Repositories](#Repositories) 与 [Entities](#Entities)。\n\n##### 初始化 server\n\n```php\n// 初始化存储库\n$clientRepository = new ClientRepository(); // Interface: ClientRepositoryInterface\n$scopeRepository = new ScopeRepository(); // Interface: ScopeRepositoryInterface\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n$authCodeRepository = new AuthCodeRepository(); // Interface: AuthCodeRepositoryInterface\n$refreshTokenRepository = new RefreshTokenRepository(); // Interface: RefreshTokenRepositoryInterface\n$userRepository = new UserRepository(); //Interface: UserRepositoryInterface\n\n// 私钥与加密密钥\n$privateKey = 'file://path/to/private.key';\n//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码\n$encryptionKey = 'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'; // 加密密钥字符串\n// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入\n\n// 初始化 server\n$server = new \\League\\OAuth2\\Server\\AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKey,\n    $encryptionKey\n);\n```\n\n##### 初始化授权码类型\n\n```php\n// 授权码授权类型初始化\n$grant = new \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(\n    $authCodeRepository,\n    $refreshTokenRepository,\n    new \\DateInterval('PT10M') // 设置授权码过期时间为10分钟\n);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将授权码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：https://example.com/authorize?response_type=code&client_id={client_id}&redirect_uri={redirect_uri}&scope{scope}&state={state})：\n\n```php\n$app->get('/authorize', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n        // 验证 HTTP 请求，并返回 authRequest 对象\n        $authRequest = $server->validateAuthorizationRequest($request);\n        // 此时应将 authRequest 对象序列化后存在当前会话(session)中\n        $_SESSION['authRequest'] = serialize($authRequest);\n        // 然后将用户重定向至登录入口或在当前地址直接响应登录页面\n        return $response->getBody()->write(file_get_contents(\"login.html\"));\n        \n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n        \n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n        \n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n客户端通过授权码请求访问令牌：\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 隐式授权模式\n\n隐式授权相当于是授权码模式的简化版本：\n\n#### 流程(用户可见)\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n* `response_type`：授权类型，必选项，值固定为：`token`\n* `client_id`：客户端ID，必选项\n* `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n* `scope`：权限范围，可选项，以空格分隔\n* `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序\n\n整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。\n\n*此模式下没有刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将隐式授权类型添加进 server\n$server->enableGrantType(\n    new ImplicitGrant(new \\DateInterval('PT1H')),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n\t      // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n\t\t\t\t// 设置用户实体(userEntity)\n\t\t    $authRequest->setUser(new UserEntity(1));\n\t\t\t\t// 设置权限范围\n\t\t\t\t$authRequest->setScopes(['basic'])\n\t\t\t\t// true = 批准，false = 拒绝\n\t\t    $authRequest->setAuthorizationApproved(true);\n\t\t\t\t// 完成后重定向至客户端请求重定向地址\n\t\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n## 密码模式\n\n密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。\n\n*OAuth2 协议规定此模式不需要传 `client_id` & `client_secret`，但 oauth-server 库需要*\n\n#### 流程\n\n客户端要求用户提供授权凭据，通常是账号密码\n\n然后，客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`password`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `username`：用户账号\n- `password`：用户密码\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\PasswordGrant(\n     $userRepository,\n     $refreshTokenRepository\n);\n\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将密码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 客户端模式\n\n客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`client_credentials`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n\n*此模式下无需刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将客户端授权类型添加进 server\n$server->enableGrantType(\n    new \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 刷新访问令牌(access token)\n\n访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`refresh_token`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `refresh_token`：刷新令牌\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 新的刷新令牌过期时间1个月\n\n// 将刷新访问令牌添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 新的访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 资源服务器验证访问令牌\n\noauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。\n\n客户端需要在 `HTTP Header` 中使用 `Authorization` 传入访问令牌，如果通过，中间件将会在 `request` 中加入对应数据：\n\n* `oauth_access_token_id`：访问令牌 id\n* `oauth_client_id`: 客户端id\n* `oauth_user_id`：用户id\n* `oauth_scopes`：权限范围\n\n授权不通过，则抛出 `OAuthServerException::accessDenied` 异常。\n\n```php\n// 初始化\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n\n// 授权服务器分发的公钥\n$publicKeyPath = 'file://path/to/public.key';\n        \n// 创建 ResourceServer\n$server = new \\League\\OAuth2\\Server\\ResourceServer(\n    $accessTokenRepository,\n    $publicKeyPath\n);\n\n// 中间件\nnew \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);\n```\n\n如果所用路由不支持中间件，可自行实现，符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可 ：\n\n```php\ntry {\n\t$request = $server->validateAuthenticatedRequest($request);\n} catch (OAuthServerException $exception) {\n\treturn $exception->generateHttpResponse($response);\n} catch (\\Exception $exception) {\n\treturn (new OAuthServerException($exception->getMessage(), 0, 'unknown_error', 500))->generateHttpResponse($response);\n}\n```\n\n\n\n## oauth2-server 实现\n\noauth2-server 的实现需要我们手动创建 [Repositories](#Repositories) 与 [Entities](#Entities)，下面展示一个项目目录示例：\n\n```\n- Entities\n\t- AccessTokenEntity.php\n\t- AuthCodeEntity.php\n\t- ClientEntity.php\n\t- RefreshTokenEntity.php\n\t- ScopeEntity.php\n\t- UserEntity.php\n- Repositories\n\t- AccessTokenRepository.php\n\t- AuthCodeRepository.php\n\t- ClientRepository.php\n\t- RefreshTokenRepository.php\n\t- ScopeRepository.php\n\t- UserRepository.php\n```\n\n### Repositories\n\nRepositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 [Interfaces](#Interfaces) 来定义所需要实现的方法。\n\n```php\nclass AccessTokenRepository implements AccessTokenRepositoryInterface\n{\n    /**\n     * @return AccessTokenEntityInterface\n     */\n    public function getNewToken(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)\n    {\n        // 创建新访问令牌时调用方法\n        // 需要返回 AccessTokenEntityInterface 对象\n        // 需要在返回前，向 AccessTokenEntity 传入参数中对应属性\n        // 示例代码：\n        $accessToken = new AccessTokenEntity();\n        $accessToken->setClient($clientEntity);\n        foreach ($scopes as $scope) {\n            $accessToken->addScope($scope);\n        }\n        $accessToken->setUserIdentifier($userIdentifier);\n\n        return $accessToken;\n    }\n\n    public function persistNewAccessToken(AccessTokenEntityInterface $accessTokenEntity)\n    {\n\t\t// 创建新访问令牌时调用此方法\n        // 可以用于持久化存储访问令牌，持久化数据库自行选择\n        // 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：\n        // $accessTokenEntity->getIdentifier(); // 获得令牌唯一标识符\n        // $accessTokenEntity->getExpiryDateTime(); // 获得令牌过期时间\n        // $accessTokenEntity->getUserIdentifier(); // 获得用户标识符\n        // $accessTokenEntity->getScopes(); // 获得权限范围\n        // $accessTokenEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAccessToken($tokenId)\n    {\n\t\t// 使用刷新令牌创建新的访问令牌时调用此方法\n        // 参数为原访问令牌的唯一标识符\n        // 可将其在持久化存储中过期\n    }\n\n    public function isAccessTokenRevoked($tokenId)\n    {\n        // 资源服务器验证访问令牌时将调用此方法\n        // 用于验证访问令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass AuthCodeRepository implements AuthCodeRepositoryInterface\n{\n    /**\n     * @return AuthCodeEntityInterface\n     */\n    public function getNewAuthCode()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 AuthCodeEntityInterface 对象\n        return new AuthCodeEntity();\n    }\n\n    public function persistNewAuthCode(AuthCodeEntityInterface $authCodeEntity)\n    {\n\t\t// 创建新授权码时调用此方法\n        // 可以用于持久化存储授权码，持久化数据库自行选择\n        // 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：\n        // $authCodeEntity->getIdentifier(); // 获得授权码唯一标识符\n        // $authCodeEntity->getExpiryDateTime(); // 获得授权码过期时间\n        // $authCodeEntity->getUserIdentifier(); // 获得用户标识符\n        // $authCodeEntity->getScopes(); // 获得权限范围\n        // $authCodeEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAuthCode($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 可以在此时将授权码从持久化数据库中删除\n        // 参数为授权码唯一标识符\n    }\n\n    public function isAuthCodeRevoked($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 用于验证授权码是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ClientRepository implements ClientRepositoryInterface\n{\n    /**\n     * @return ClientEntityInterface\n     */\n    public function getClientEntity($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)\n    {\n        // 获取客户端对象时调用方法，用于验证客户端\n        // 需要返回 ClientEntityInterface 对象\n        // $clientIdentifier 客户端唯一标识符\n        // $grantType 代表授权类型，根据类型不同，验证方式也不同\n        // $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的\n        // $mustValidateSecret 代表是否需要验证客户端密钥\n        $client = new ClientEntity();\n        $client->setIdentifier($clientIdentifier);\n\n        return $client;\n    }\n}\n```\n\n```php\nclass RefreshTokenRepository implements RefreshTokenRepositoryInterface\n{\n    /**\n     * @return RefreshTokenEntityInterface\n     */\n    public function getNewRefreshToken()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 RefreshTokenEntityInterface 对象\n        return new RefreshTokenEntity();\n    }\n\n    public function persistNewRefreshToken(RefreshTokenEntityInterface $refreshTokenEntity)\n    {\n\t\t// 创建新刷新令牌时调用此方法\n        // 用于持久化存储授刷新令牌\n        // 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：\n        // $refreshTokenEntity->getIdentifier(); // 获得刷新令牌唯一标识符\n        // $refreshTokenEntity->getExpiryDateTime(); // 获得刷新令牌过期时间\n        // $refreshTokenEntity->getAccessToken()->getIdentifier(); // 获得访问令牌标识符\n    }\n\n    public function revokeRefreshToken($tokenId)\n    {\n\t\t// 当使用刷新令牌获取访问令牌时调用此方法\n        // 原刷新令牌将删除，创建新的刷新令牌\n        // 参数为原刷新令牌唯一标识\n        // 可在此删除原刷新令牌\n    }\n\n    public function isRefreshTokenRevoked($tokenId)\n    {\n        // 当使用刷新令牌获取访问令牌时调用此方法\n        // 用于验证刷新令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ScopeRepository implements ScopeRepositoryInterface\n{\n    /**\n     * @return ScopeEntityInterface\n     */\n    public function getScopeEntityByIdentifier($identifier)\n    {\n        // 验证权限是否在权限范围中会调用此方法\n        // 参数为单个权限标识符\n        // ......\n        // 验证成功则返回 ScopeEntityInterface 对象\n        $scope = new ScopeEntity();\n        $scope->setIdentifier($identifier);\n\n        return $scope;\n    }\n\n    public function finalizeScopes(\n        array $scopes,\n        $grantType,\n        ClientEntityInterface $clientEntity,\n        $userIdentifier = null\n    ) {\n        // 在创建授权码与访问令牌前会调用此方法\n        // 用于验证权限范围、授权类型、客户端、用户是否匹配\n        // 可整合进项目自身的权限控制中\n        // 必须返回 ScopeEntityInterface 对象可用的 scope 数组\n        // 示例：\n        // $scope = new ScopeEntity();\n        // $scope->setIdentifier('example');\n        // $scopes[] = $scope;\n\n        return $scopes;\n    }\n}\n```\n\n```php\nclass UserRepository implements UserRepositoryInterface\n{\n    /**\n     * @return UserEntityInterface\n     */\n    public function getUserEntityByUserCredentials(\n        $username,\n        $password,\n        $grantType,\n        ClientEntityInterface $clientEntity\n    ) {\n        // 验证用户时调用此方法\n        // 用于验证用户信息是否符合\n        // 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)\n        // 验证成功返回 UserEntityInterface 对象\n        $user = new UserEntity();\n        $user->setIdentifier(1);\n\n        return $user;\n    }\n}\n```\n\n\n\n### Entities\n\nEntities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 [Interfaces](#Interfaces) 来定义需要实现的方法，同时提供了 [Traits](#Traits) 帮助我们实现，可以选择使用，有需要时也可以重写。\n\n```php\nclass AccessTokenEntity implements AccessTokenEntityInterface\n{\n    use AccessTokenTrait, TokenEntityTrait, EntityTrait;\n}\n```\n\n```php\nclass AuthCodeEntity implements AuthCodeEntityInterface\n{\n    use EntityTrait, TokenEntityTrait, AuthCodeTrait;\n}\n```\n\n```php\nclass ClientEntity implements ClientEntityInterface\n{\n    use EntityTrait, ClientTrait;\n}\n```\n\n```php\nclass RefreshTokenEntity implements RefreshTokenEntityInterface\n{\n    use RefreshTokenTrait, EntityTrait;\n}\n```\n\n```php\nclass ScopeEntity implements ScopeEntityInterface\n{\n    use EntityTrait;\n\t\n    // 没有 Trait 实现这个方法，需要自行实现\n    // oauth2-server 项目的测试代码的实现例子\n    public function jsonSerialize()\n    {\n        return $this->getIdentifier();\n    }\n}\n```\n\n```php\nclass UserEntity implements UserEntityInterface\n{\n    use EntityTrait;\n}\n```\n\n### Interfaces\n\n**Repositories**\n\n* League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php\n\n**Entities**\n\n* League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\TokenInterface.php\n* League\\OAuth2\\Server\\Entities\\UserEntityInterface.php\n\n### Traits\n\n* League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php\n\n\n\n## 事件\n\noauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。\n\n##### client.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'client.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n客户端身份验证未通过时触发此事件。你可以在客户端尝试 `n` 次失败后禁止它一段时间内的再次尝试。\n\n##### user.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'user.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 `n` 次后禁止用户再次尝试。\n\n\n\n## 参考文章\n\n《oauth2-server 官方文档》(https://oauth2.thephpleague.com/)\n\n《理解OAuth 2.0》-阮一峰（http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）","source":"_posts/OAuth2.0-and-oauth2-server-package.md","raw":"---\ntitle: OAuth2.0 与 oauth2-server 库的使用\ndate: 2018/11/22 20:08:09\n---\n\n[OAuth2.0](https://en.wikipedia.org/wiki/OAuth) 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。\n\n[league/oauth2-server](https://github.com/thephpleague/oauth2-server) 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。\n\n本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。\n\n<!--more-->  \n\n## 术语\n\n了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。\n\n**OAuth2.0 定义了四个角色**\n\n1. **Client**：客户端，第三方应用程序。\n2. **Resource Owner**：资源所有者，授权 Client 访问其帐户的用户。\n3. **Authorization server**：授权服务器，服务商专用于处理用户授权认证的服务器。\n4. **Resource server**：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。\n\n**oauth2-server**\n\n1. **Access token**：用于访问受保护资源的令牌。\n2. **Authorization code**：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。\n3. **Scope**：授予应用程序的权限范围。\n4. **JWT**：[Json Web Token](https://tools.ietf.org/html/rfc7519) 是一种用于安全传输的数据传输格式。\n\n\n## 运行流程\n![flowchart.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg)\n\n\n## 安装\n\n推荐使用 [Composer](https://getcomposer.org/) 进行安装：\n\n```string\ncomposer require league/oauth2-server\n```\n\n根据[授权模式](#授权模式)的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。\n\n*本文发布时，版本号为7.3.1。*\n\n\n\n**生成公钥与私钥**\n\n公钥与私钥用于签名和验证传输的 [JWT](https://tools.ietf.org/html/rfc7519)，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。\n\n*oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。*\n\n生成私钥，在终端中运行：\n\n```string\nopenssl genrsa -out private.key 2048\n```\n\n使用私钥提取私钥：\n\n```string\nopenssl rsa -in private.key -pubout -out public.key\n```\n\n私钥必须保密于授权服务器中，并将公钥分发给资源服务器。\n\n\n\n**生成加密密钥**\n\n加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，`string` 或 `defuse/php-encryption` 库的对象。\n\n*加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。*\n\n生成字符串密钥，在终端中输入：\n\n```string\nphp -r 'echo base64_encode(random_bytes(32)), PHP_EOL;'\n```\n\n生成对象，在项目根目录的终端中输入：\n\n```string\nvendor/bin/generate-defuse-key\n```\n\n将获得的内容，传入 AuthorizationServer：\n\n```php\nuse \\Defuse\\Crypto\\Key;\n$server = new AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKeyPath,\n    Key::loadFromAsciiSafeString($encryptionKey) //传入加密密钥\n);\n```\n\n\n\n**PHP版本支持**\n\n- PHP 7.0\n- PHP 7.1\n- PHP 7.2\n\n\n\n## 授权模式\n\nOAuth2.0 定义了四种授权模式，以应对不同情况时的授权。\n\n1. 授权码模式\n2. 隐式授权模式\n3. 密码模式\n4. 客户端模式\n\n\n\n## 客户端类型 \n\n* 保密的：\n\t* 客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）\n* 公开的：\n\t* 客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）\n\n\n\n## 选用哪种授权模式？\n\n如果客户端是保密的，应使用[授权码模式](#授权码模式)。\n\n如果客户端是公开的，应使用[隐式授权模式](#隐式授权模式)。\n\n如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用[密码模式](#密码模式)。\n\n如果客户端是以自己的名义，不与用户产生关系，应使用[客户端模式](#客户端模式)。\n\n\n## 预先注册\n\n客户端需要预先在授权服务器进行注册，用以获取 `client_id` 与 `client_secret`，也可以在注册是预先设定好 `redirect_uri`，以便于之后可以使用默认的 `redirect_uri`。\n\n\n## 授权码模式\n\n授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。\n\n#### 流程\n\n**第一部分（用户可见）**\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n *  `response_type`：授权类型，必选项，值固定为：`code`\n *   `client_id`：客户端ID，必选项\n *  `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n *  `scope`：权限范围，可选项，以空格分隔\n *  `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n* `code`：授权码(Authorization code)\n* `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序\n\n**第二部分（用户不可见）**\n\n客户端已得到授权，通过 `POST` 请求向授权服务器获取访问令牌(access token)：\n\n* `grant_type`：授权模式，值固定为：`authorization_code`\n* `client_id`：客户端ID\n* `client_secret`：客户端 secret\n* `redirect_uri`：使用与第一部分请求相同的 URI\n* `code`：第一部分所获的的授权码，要注意URL解码\n\n授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：\n\n* `token_type`：令牌类型，值固定为：`Bearer`\n\n* `expires_in`：访问令牌的存活时间\n\n* `access_token`：访问令牌\n\n* `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n\n#### 使用 oauth2-server 实现\n\n##### 初始化\n\nOAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 [Interfaces](#Interfaces) 与 [Traits](#Traits) 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 [Repositories](#Repositories) 与 [Entities](#Entities)。\n\n##### 初始化 server\n\n```php\n// 初始化存储库\n$clientRepository = new ClientRepository(); // Interface: ClientRepositoryInterface\n$scopeRepository = new ScopeRepository(); // Interface: ScopeRepositoryInterface\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n$authCodeRepository = new AuthCodeRepository(); // Interface: AuthCodeRepositoryInterface\n$refreshTokenRepository = new RefreshTokenRepository(); // Interface: RefreshTokenRepositoryInterface\n$userRepository = new UserRepository(); //Interface: UserRepositoryInterface\n\n// 私钥与加密密钥\n$privateKey = 'file://path/to/private.key';\n//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码\n$encryptionKey = 'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'; // 加密密钥字符串\n// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入\n\n// 初始化 server\n$server = new \\League\\OAuth2\\Server\\AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKey,\n    $encryptionKey\n);\n```\n\n##### 初始化授权码类型\n\n```php\n// 授权码授权类型初始化\n$grant = new \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(\n    $authCodeRepository,\n    $refreshTokenRepository,\n    new \\DateInterval('PT10M') // 设置授权码过期时间为10分钟\n);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将授权码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：https://example.com/authorize?response_type=code&client_id={client_id}&redirect_uri={redirect_uri}&scope{scope}&state={state})：\n\n```php\n$app->get('/authorize', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n        // 验证 HTTP 请求，并返回 authRequest 对象\n        $authRequest = $server->validateAuthorizationRequest($request);\n        // 此时应将 authRequest 对象序列化后存在当前会话(session)中\n        $_SESSION['authRequest'] = serialize($authRequest);\n        // 然后将用户重定向至登录入口或在当前地址直接响应登录页面\n        return $response->getBody()->write(file_get_contents(\"login.html\"));\n        \n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n        \n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n        \n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n客户端通过授权码请求访问令牌：\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 隐式授权模式\n\n隐式授权相当于是授权码模式的简化版本：\n\n#### 流程(用户可见)\n\n用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 `GET query` 传入：\n\n* `response_type`：授权类型，必选项，值固定为：`token`\n* `client_id`：客户端ID，必选项\n* `redirect_uri`：重定向URI，可选项，不填写时默认预先注册的重定向URI\n* `scope`：权限范围，可选项，以空格分隔\n* `state`：[CSRF](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证\n\n用户选择是否给予客户端授权\n\n假设用户给予授权，授权服务器将用户导向客户端事先指定的 `redirect_uri`，并将以下参数通过 `GET query` 传入：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `state`：请求中发送的 `state`，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序\n\n整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。\n\n*此模式下没有刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将隐式授权类型添加进 server\n$server->enableGrantType(\n    new ImplicitGrant(new \\DateInterval('PT1H')),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n    try {\n        // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n        // 设置用户实体(userEntity)\n        $authRequest->setUser(new UserEntity(1));\n        // 设置权限范围\n        $authRequest->setScopes(['basic'])\n        // true = 批准，false = 拒绝\n        $authRequest->setAuthorizationApproved(true);\n        // 完成后重定向至客户端请求重定向地址\n\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        // 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n此时展示给用户的是这样的页面：\n![qq-oauth.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg)\n\n用户提交登录后，设置好用户实体(userEntity)：\n\n```\n$app->post('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n   \n    try {\n\t      // 在会话(session)中取出 authRequest 对象\n        $authRequest = unserialize($_SESSION['authRequest']);\n\t\t\t\t// 设置用户实体(userEntity)\n\t\t    $authRequest->setUser(new UserEntity(1));\n\t\t\t\t// 设置权限范围\n\t\t\t\t$authRequest->setScopes(['basic'])\n\t\t\t\t// true = 批准，false = 拒绝\n\t\t    $authRequest->setAuthorizationApproved(true);\n\t\t\t\t// 完成后重定向至客户端请求重定向地址\n\t\t    return $server->completeAuthorizationRequest($authRequest, $response);\n    } catch (OAuthServerException $exception) {\n        // 可以捕获 OAuthServerException，将其转为 HTTP 响应\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n    \t// 其他异常\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n## 密码模式\n\n密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。\n\n*OAuth2 协议规定此模式不需要传 `client_id` & `client_secret`，但 oauth-server 库需要*\n\n#### 流程\n\n客户端要求用户提供授权凭据，通常是账号密码\n\n然后，客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`password`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `username`：用户账号\n- `password`：用户密码\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\PasswordGrant(\n     $userRepository,\n     $refreshTokenRepository\n);\n\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 设置刷新令牌过期时间1个月\n\n// 将密码授权类型添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 客户端模式\n\n客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`client_credentials`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n\n*此模式下无需刷新令牌(refresh token)的返回。*\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n// 将客户端授权类型添加进 server\n$server->enableGrantType(\n    new \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),\n    new \\DateInterval('PT1H') // 设置访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n*注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可。*\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 刷新访问令牌(access token)\n\n访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。\n\n#### 流程\n\n客户端发送 `POST` 请求至授权服务器，携带以下参数：\n\n- `grant_type`：授权类型，必选项，值固定为：`refresh_token`\n- `client_id`：客户端ID，必选项\n- `client_secret`：客户端 secret\n- `scope`：权限范围，可选项，以空格分隔\n- `refresh_token`：刷新令牌\n\n授权服务器响应以下内容：\n\n- `token_type`：令牌类型，值固定为：`Bearer`\n- `expires_in`：访问令牌的存活时间\n- `access_token`：访问令牌\n- `refresh_token`：刷新令牌，访问令牌过期后，使用刷新令牌重新获取\n\n\n\n#### 使用 oauth2-server 实现\n\n**[初始化 server](#初始化)**\n\n##### 初始化授权码类型\n\n```php\n$grant = new \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);\n$grant->setRefreshTokenTTL(new \\DateInterval('P1M')); // 新的刷新令牌过期时间1个月\n\n// 将刷新访问令牌添加进 server\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('PT1H') // 新的访问令牌过期时间1小时\n);\n```\n\n*[DateInterval](http://php.net/manual/zh/class.dateinterval.php)*\n\n\n\n##### 使用\n\n```php\n$app->post('/access_token', function (ServerRequestInterface $request, ResponseInterface $response) use ($server) {\n\n    try {\n        // 这里只需要这一行就可以，具体的判断在 Repositories 中\n        return $server->respondToAccessTokenRequest($request, $response);\n    } catch (\\League\\OAuth2\\Server\\Exception\\OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (\\Exception $exception) {\n        $body = new Stream(fopen('php://temp', 'r+'));\n        $body->write($exception->getMessage());\n        return $response->withStatus(500)->withBody($body);\n    }\n});\n```\n\n\n\n## 资源服务器验证访问令牌\n\noauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。\n\n客户端需要在 `HTTP Header` 中使用 `Authorization` 传入访问令牌，如果通过，中间件将会在 `request` 中加入对应数据：\n\n* `oauth_access_token_id`：访问令牌 id\n* `oauth_client_id`: 客户端id\n* `oauth_user_id`：用户id\n* `oauth_scopes`：权限范围\n\n授权不通过，则抛出 `OAuthServerException::accessDenied` 异常。\n\n```php\n// 初始化\n$accessTokenRepository = new AccessTokenRepository(); // Interface: AccessTokenRepositoryInterface\n\n// 授权服务器分发的公钥\n$publicKeyPath = 'file://path/to/public.key';\n        \n// 创建 ResourceServer\n$server = new \\League\\OAuth2\\Server\\ResourceServer(\n    $accessTokenRepository,\n    $publicKeyPath\n);\n\n// 中间件\nnew \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);\n```\n\n如果所用路由不支持中间件，可自行实现，符合[PSR-7](https://www.php-fig.org/psr/psr-7/)规范即可 ：\n\n```php\ntry {\n\t$request = $server->validateAuthenticatedRequest($request);\n} catch (OAuthServerException $exception) {\n\treturn $exception->generateHttpResponse($response);\n} catch (\\Exception $exception) {\n\treturn (new OAuthServerException($exception->getMessage(), 0, 'unknown_error', 500))->generateHttpResponse($response);\n}\n```\n\n\n\n## oauth2-server 实现\n\noauth2-server 的实现需要我们手动创建 [Repositories](#Repositories) 与 [Entities](#Entities)，下面展示一个项目目录示例：\n\n```\n- Entities\n\t- AccessTokenEntity.php\n\t- AuthCodeEntity.php\n\t- ClientEntity.php\n\t- RefreshTokenEntity.php\n\t- ScopeEntity.php\n\t- UserEntity.php\n- Repositories\n\t- AccessTokenRepository.php\n\t- AuthCodeRepository.php\n\t- ClientRepository.php\n\t- RefreshTokenRepository.php\n\t- ScopeRepository.php\n\t- UserRepository.php\n```\n\n### Repositories\n\nRepositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 [Interfaces](#Interfaces) 来定义所需要实现的方法。\n\n```php\nclass AccessTokenRepository implements AccessTokenRepositoryInterface\n{\n    /**\n     * @return AccessTokenEntityInterface\n     */\n    public function getNewToken(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)\n    {\n        // 创建新访问令牌时调用方法\n        // 需要返回 AccessTokenEntityInterface 对象\n        // 需要在返回前，向 AccessTokenEntity 传入参数中对应属性\n        // 示例代码：\n        $accessToken = new AccessTokenEntity();\n        $accessToken->setClient($clientEntity);\n        foreach ($scopes as $scope) {\n            $accessToken->addScope($scope);\n        }\n        $accessToken->setUserIdentifier($userIdentifier);\n\n        return $accessToken;\n    }\n\n    public function persistNewAccessToken(AccessTokenEntityInterface $accessTokenEntity)\n    {\n\t\t// 创建新访问令牌时调用此方法\n        // 可以用于持久化存储访问令牌，持久化数据库自行选择\n        // 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：\n        // $accessTokenEntity->getIdentifier(); // 获得令牌唯一标识符\n        // $accessTokenEntity->getExpiryDateTime(); // 获得令牌过期时间\n        // $accessTokenEntity->getUserIdentifier(); // 获得用户标识符\n        // $accessTokenEntity->getScopes(); // 获得权限范围\n        // $accessTokenEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAccessToken($tokenId)\n    {\n\t\t// 使用刷新令牌创建新的访问令牌时调用此方法\n        // 参数为原访问令牌的唯一标识符\n        // 可将其在持久化存储中过期\n    }\n\n    public function isAccessTokenRevoked($tokenId)\n    {\n        // 资源服务器验证访问令牌时将调用此方法\n        // 用于验证访问令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass AuthCodeRepository implements AuthCodeRepositoryInterface\n{\n    /**\n     * @return AuthCodeEntityInterface\n     */\n    public function getNewAuthCode()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 AuthCodeEntityInterface 对象\n        return new AuthCodeEntity();\n    }\n\n    public function persistNewAuthCode(AuthCodeEntityInterface $authCodeEntity)\n    {\n\t\t// 创建新授权码时调用此方法\n        // 可以用于持久化存储授权码，持久化数据库自行选择\n        // 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：\n        // $authCodeEntity->getIdentifier(); // 获得授权码唯一标识符\n        // $authCodeEntity->getExpiryDateTime(); // 获得授权码过期时间\n        // $authCodeEntity->getUserIdentifier(); // 获得用户标识符\n        // $authCodeEntity->getScopes(); // 获得权限范围\n        // $authCodeEntity->getClient()->getIdentifier(); // 获得客户端标识符\n    }\n\n    public function revokeAuthCode($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 可以在此时将授权码从持久化数据库中删除\n        // 参数为授权码唯一标识符\n    }\n\n    public function isAuthCodeRevoked($codeId)\n    {\n\t\t// 当使用授权码获取访问令牌时调用此方法\n        // 用于验证授权码是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ClientRepository implements ClientRepositoryInterface\n{\n    /**\n     * @return ClientEntityInterface\n     */\n    public function getClientEntity($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)\n    {\n        // 获取客户端对象时调用方法，用于验证客户端\n        // 需要返回 ClientEntityInterface 对象\n        // $clientIdentifier 客户端唯一标识符\n        // $grantType 代表授权类型，根据类型不同，验证方式也不同\n        // $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的\n        // $mustValidateSecret 代表是否需要验证客户端密钥\n        $client = new ClientEntity();\n        $client->setIdentifier($clientIdentifier);\n\n        return $client;\n    }\n}\n```\n\n```php\nclass RefreshTokenRepository implements RefreshTokenRepositoryInterface\n{\n    /**\n     * @return RefreshTokenEntityInterface\n     */\n    public function getNewRefreshToken()\n    {\n        // 创建新授权码时调用方法\n        // 需要返回 RefreshTokenEntityInterface 对象\n        return new RefreshTokenEntity();\n    }\n\n    public function persistNewRefreshToken(RefreshTokenEntityInterface $refreshTokenEntity)\n    {\n\t\t// 创建新刷新令牌时调用此方法\n        // 用于持久化存储授刷新令牌\n        // 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：\n        // $refreshTokenEntity->getIdentifier(); // 获得刷新令牌唯一标识符\n        // $refreshTokenEntity->getExpiryDateTime(); // 获得刷新令牌过期时间\n        // $refreshTokenEntity->getAccessToken()->getIdentifier(); // 获得访问令牌标识符\n    }\n\n    public function revokeRefreshToken($tokenId)\n    {\n\t\t// 当使用刷新令牌获取访问令牌时调用此方法\n        // 原刷新令牌将删除，创建新的刷新令牌\n        // 参数为原刷新令牌唯一标识\n        // 可在此删除原刷新令牌\n    }\n\n    public function isRefreshTokenRevoked($tokenId)\n    {\n        // 当使用刷新令牌获取访问令牌时调用此方法\n        // 用于验证刷新令牌是否已被删除\n        // return true 已删除，false 未删除\n        return false;\n    }\n}\n```\n\n```php\nclass ScopeRepository implements ScopeRepositoryInterface\n{\n    /**\n     * @return ScopeEntityInterface\n     */\n    public function getScopeEntityByIdentifier($identifier)\n    {\n        // 验证权限是否在权限范围中会调用此方法\n        // 参数为单个权限标识符\n        // ......\n        // 验证成功则返回 ScopeEntityInterface 对象\n        $scope = new ScopeEntity();\n        $scope->setIdentifier($identifier);\n\n        return $scope;\n    }\n\n    public function finalizeScopes(\n        array $scopes,\n        $grantType,\n        ClientEntityInterface $clientEntity,\n        $userIdentifier = null\n    ) {\n        // 在创建授权码与访问令牌前会调用此方法\n        // 用于验证权限范围、授权类型、客户端、用户是否匹配\n        // 可整合进项目自身的权限控制中\n        // 必须返回 ScopeEntityInterface 对象可用的 scope 数组\n        // 示例：\n        // $scope = new ScopeEntity();\n        // $scope->setIdentifier('example');\n        // $scopes[] = $scope;\n\n        return $scopes;\n    }\n}\n```\n\n```php\nclass UserRepository implements UserRepositoryInterface\n{\n    /**\n     * @return UserEntityInterface\n     */\n    public function getUserEntityByUserCredentials(\n        $username,\n        $password,\n        $grantType,\n        ClientEntityInterface $clientEntity\n    ) {\n        // 验证用户时调用此方法\n        // 用于验证用户信息是否符合\n        // 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)\n        // 验证成功返回 UserEntityInterface 对象\n        $user = new UserEntity();\n        $user->setIdentifier(1);\n\n        return $user;\n    }\n}\n```\n\n\n\n### Entities\n\nEntities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 [Interfaces](#Interfaces) 来定义需要实现的方法，同时提供了 [Traits](#Traits) 帮助我们实现，可以选择使用，有需要时也可以重写。\n\n```php\nclass AccessTokenEntity implements AccessTokenEntityInterface\n{\n    use AccessTokenTrait, TokenEntityTrait, EntityTrait;\n}\n```\n\n```php\nclass AuthCodeEntity implements AuthCodeEntityInterface\n{\n    use EntityTrait, TokenEntityTrait, AuthCodeTrait;\n}\n```\n\n```php\nclass ClientEntity implements ClientEntityInterface\n{\n    use EntityTrait, ClientTrait;\n}\n```\n\n```php\nclass RefreshTokenEntity implements RefreshTokenEntityInterface\n{\n    use RefreshTokenTrait, EntityTrait;\n}\n```\n\n```php\nclass ScopeEntity implements ScopeEntityInterface\n{\n    use EntityTrait;\n\t\n    // 没有 Trait 实现这个方法，需要自行实现\n    // oauth2-server 项目的测试代码的实现例子\n    public function jsonSerialize()\n    {\n        return $this->getIdentifier();\n    }\n}\n```\n\n```php\nclass UserEntity implements UserEntityInterface\n{\n    use EntityTrait;\n}\n```\n\n### Interfaces\n\n**Repositories**\n\n* League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php\n\n* League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php\n\n**Entities**\n\n* League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php\n* League\\OAuth2\\Server\\Entities\\TokenInterface.php\n* League\\OAuth2\\Server\\Entities\\UserEntityInterface.php\n\n### Traits\n\n* League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php\n* League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php\n\n\n\n## 事件\n\noauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。\n\n##### client.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'client.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n客户端身份验证未通过时触发此事件。你可以在客户端尝试 `n` 次失败后禁止它一段时间内的再次尝试。\n\n##### user.authentication.failed\n\n```php\n$server->getEmitter()->addListener(\n    'user.authentication.failed',\n    function (\\League\\OAuth2\\Server\\RequestEvent $event) {\n        // do something\n    }\n);\n```\n\n用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 `n` 次后禁止用户再次尝试。\n\n\n\n## 参考文章\n\n《oauth2-server 官方文档》(https://oauth2.thephpleague.com/)\n\n《理解OAuth 2.0》-阮一峰（http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）","slug":"OAuth2.0-and-oauth2-server-package","published":1,"updated":"2019-10-21T08:57:54.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29bx0008yz79dcc721sa","content":"<p><a href=\"https://en.wikipedia.org/wiki/OAuth\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a> 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。</p>\n<p><a href=\"https://github.com/thephpleague/oauth2-server\" target=\"_blank\" rel=\"noopener\">league/oauth2-server</a> 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。</p>\n<p>本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。</p>\n<a id=\"more\"></a>  \n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。</p>\n<p><strong>OAuth2.0 定义了四个角色</strong></p>\n<ol>\n<li><strong>Client</strong>：客户端，第三方应用程序。</li>\n<li><strong>Resource Owner</strong>：资源所有者，授权 Client 访问其帐户的用户。</li>\n<li><strong>Authorization server</strong>：授权服务器，服务商专用于处理用户授权认证的服务器。</li>\n<li><strong>Resource server</strong>：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。</li>\n</ol>\n<p><strong>oauth2-server</strong></p>\n<ol>\n<li><strong>Access token</strong>：用于访问受保护资源的令牌。</li>\n<li><strong>Authorization code</strong>：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。</li>\n<li><strong>Scope</strong>：授予应用程序的权限范围。</li>\n<li><strong>JWT</strong>：<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">Json Web Token</a> 是一种用于安全传输的数据传输格式。</li>\n</ol>\n<h2 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h2><p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg\" alt=\"flowchart.png\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>推荐使用 <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">Composer</a> 进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require league/oauth2-server</span><br></pre></td></tr></table></figure>\n<p>根据<a href=\"#授权模式\">授权模式</a>的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。</p>\n<p><em>本文发布时，版本号为7.3.1。</em></p>\n<p><strong>生成公钥与私钥</strong></p>\n<p>公钥与私钥用于签名和验证传输的 <a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">JWT</a>，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。</p>\n<p><em>oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。</em></p>\n<p>生成私钥，在终端中运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out private.key 2048</span><br></pre></td></tr></table></figure>\n<p>使用私钥提取私钥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in private.key -pubout -out public.key</span><br></pre></td></tr></table></figure>\n<p>私钥必须保密于授权服务器中，并将公钥分发给资源服务器。</p>\n<p><strong>生成加密密钥</strong></p>\n<p>加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，<code>string</code> 或 <code>defuse/php-encryption</code> 库的对象。</p>\n<p><em>加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。</em></p>\n<p>生成字符串密钥，在终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &apos;echo base64_encode(random_bytes(32)), PHP_EOL;&apos;</span><br></pre></td></tr></table></figure>\n<p>生成对象，在项目根目录的终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vendor/bin/generate-defuse-key</span><br></pre></td></tr></table></figure>\n<p>将获得的内容，传入 AuthorizationServer：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> \\<span class=\"title\">Defuse</span>\\<span class=\"title\">Crypto</span>\\<span class=\"title\">Key</span>;</span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKeyPath,</span><br><span class=\"line\">    Key::loadFromAsciiSafeString($encryptionKey) <span class=\"comment\">//传入加密密钥</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><strong>PHP版本支持</strong></p>\n<ul>\n<li>PHP 7.0</li>\n<li>PHP 7.1</li>\n<li>PHP 7.2</li>\n</ul>\n<h2 id=\"授权模式\"><a href=\"#授权模式\" class=\"headerlink\" title=\"授权模式\"></a>授权模式</h2><p>OAuth2.0 定义了四种授权模式，以应对不同情况时的授权。</p>\n<ol>\n<li>授权码模式</li>\n<li>隐式授权模式</li>\n<li>密码模式</li>\n<li>客户端模式</li>\n</ol>\n<h2 id=\"客户端类型\"><a href=\"#客户端类型\" class=\"headerlink\" title=\"客户端类型\"></a>客户端类型</h2><ul>\n<li>保密的：<ul>\n<li>客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）</li>\n</ul>\n</li>\n<li>公开的：<ul>\n<li>客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选用哪种授权模式？\"><a href=\"#选用哪种授权模式？\" class=\"headerlink\" title=\"选用哪种授权模式？\"></a>选用哪种授权模式？</h2><p>如果客户端是保密的，应使用<a href=\"#授权码模式\">授权码模式</a>。</p>\n<p>如果客户端是公开的，应使用<a href=\"#隐式授权模式\">隐式授权模式</a>。</p>\n<p>如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用<a href=\"#密码模式\">密码模式</a>。</p>\n<p>如果客户端是以自己的名义，不与用户产生关系，应使用<a href=\"#客户端模式\">客户端模式</a>。</p>\n<h2 id=\"预先注册\"><a href=\"#预先注册\" class=\"headerlink\" title=\"预先注册\"></a>预先注册</h2><p>客户端需要预先在授权服务器进行注册，用以获取 <code>client_id</code> 与 <code>client_secret</code>，也可以在注册是预先设定好 <code>redirect_uri</code>，以便于之后可以使用默认的 <code>redirect_uri</code>。</p>\n<h2 id=\"授权码模式\"><a href=\"#授权码模式\" class=\"headerlink\" title=\"授权码模式\"></a>授权码模式</h2><p>授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。</p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p><strong>第一部分（用户可见）</strong></p>\n<p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>code</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>code</code>：授权码(Authorization code)</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序</li>\n</ul>\n<p><strong>第二部分（用户不可见）</strong></p>\n<p>客户端已得到授权，通过 <code>POST</code> 请求向授权服务器获取访问令牌(access token)：</p>\n<ul>\n<li><code>grant_type</code>：授权模式，值固定为：<code>authorization_code</code></li>\n<li><code>client_id</code>：客户端ID</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>redirect_uri</code>：使用与第一部分请求相同的 URI</li>\n<li><code>code</code>：第一部分所获的的授权码，要注意URL解码</li>\n</ul>\n<p>授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：</p>\n<ul>\n<li><p><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></p>\n</li>\n<li><p><code>expires_in</code>：访问令牌的存活时间</p>\n</li>\n<li><p><code>access_token</code>：访问令牌</p>\n</li>\n<li><p><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</p>\n</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现\"><a href=\"#使用-oauth2-server-实现\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><p>OAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 <a href=\"#Interfaces\">Interfaces</a> 与 <a href=\"#Traits\">Traits</a> 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>。</p>\n<h5 id=\"初始化-server\"><a href=\"#初始化-server\" class=\"headerlink\" title=\"初始化 server\"></a>初始化 server</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化存储库</span></span><br><span class=\"line\">$clientRepository = <span class=\"keyword\">new</span> ClientRepository(); <span class=\"comment\">// Interface: ClientRepositoryInterface</span></span><br><span class=\"line\">$scopeRepository = <span class=\"keyword\">new</span> ScopeRepository(); <span class=\"comment\">// Interface: ScopeRepositoryInterface</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\">$authCodeRepository = <span class=\"keyword\">new</span> AuthCodeRepository(); <span class=\"comment\">// Interface: AuthCodeRepositoryInterface</span></span><br><span class=\"line\">$refreshTokenRepository = <span class=\"keyword\">new</span> RefreshTokenRepository(); <span class=\"comment\">// Interface: RefreshTokenRepositoryInterface</span></span><br><span class=\"line\">$userRepository = <span class=\"keyword\">new</span> UserRepository(); <span class=\"comment\">//Interface: UserRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 私钥与加密密钥</span></span><br><span class=\"line\">$privateKey = <span class=\"string\">'file://path/to/private.key'</span>;</span><br><span class=\"line\"><span class=\"comment\">//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码</span></span><br><span class=\"line\">$encryptionKey = <span class=\"string\">'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'</span>; <span class=\"comment\">// 加密密钥字符串</span></span><br><span class=\"line\"><span class=\"comment\">// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化 server</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKey,</span><br><span class=\"line\">    $encryptionKey</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h5 id=\"初始化授权码类型\"><a href=\"#初始化授权码类型\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 授权码授权类型初始化</span></span><br><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(</span><br><span class=\"line\">    $authCodeRepository,</span><br><span class=\"line\">    $refreshTokenRepository,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT10M'</span>) <span class=\"comment\">// 设置授权码过期时间为10分钟</span></span><br><span class=\"line\">);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将授权码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<p>用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：<a href=\"https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：\" target=\"_blank\" rel=\"noopener\">https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：</a></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;get(<span class=\"string\">'/authorize'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证 HTTP 请求，并返回 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = $server-&gt;validateAuthorizationRequest($request);</span><br><span class=\"line\">        <span class=\"comment\">// 此时应将 authRequest 对象序列化后存在当前会话(session)中</span></span><br><span class=\"line\">        $_SESSION[<span class=\"string\">'authRequest'</span>] = serialize($authRequest);</span><br><span class=\"line\">        <span class=\"comment\">// 然后将用户重定向至登录入口或在当前地址直接响应登录页面</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;getBody()-&gt;write(file_get_contents(<span class=\"string\">\"login.html\"</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">        // 设置用户实体(userEntity)</span><br><span class=\"line\">        $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">        // 设置权限范围</span><br><span class=\"line\">        $authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">        // true = 批准，false = 拒绝</span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">        // 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">        // 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>客户端通过授权码请求访问令牌：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式授权模式\"><a href=\"#隐式授权模式\" class=\"headerlink\" title=\"隐式授权模式\"></a>隐式授权模式</h2><p>隐式授权相当于是授权码模式的简化版本：</p>\n<h4 id=\"流程-用户可见\"><a href=\"#流程-用户可见\" class=\"headerlink\" title=\"流程(用户可见)\"></a>流程(用户可见)</h4><p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序</li>\n</ul>\n<p>整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。</p>\n<p><em>此模式下没有刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-1\"><a href=\"#使用-oauth2-server-实现-1\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-1\"><a href=\"#初始化授权码类型-1\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将隐式授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ImplicitGrant(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>)),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/login'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在会话(session)中取出 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[<span class=\"string\">'authRequest'</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 设置用户实体(userEntity)</span></span><br><span class=\"line\">        $authRequest-&gt;setUser(<span class=\"keyword\">new</span> UserEntity(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置权限范围</span></span><br><span class=\"line\">        $authRequest-&gt;setScopes([<span class=\"string\">'basic'</span>])</span><br><span class=\"line\">        <span class=\"comment\">// true = 批准，false = 拒绝</span></span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 完成后重定向至客户端请求重定向地址</span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">\t      // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">\t\t\t\t// 设置用户实体(userEntity)</span><br><span class=\"line\">\t\t    $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">\t\t\t\t// 设置权限范围</span><br><span class=\"line\">\t\t\t\t$authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">\t\t\t\t// true = 批准，false = 拒绝</span><br><span class=\"line\">\t\t    $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">\t\t\t\t// 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">    \t// 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"密码模式\"><a href=\"#密码模式\" class=\"headerlink\" title=\"密码模式\"></a>密码模式</h2><p>密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。</p>\n<p><em>OAuth2 协议规定此模式不需要传 <code>client_id</code> &amp; <code>client_secret</code>，但 oauth-server 库需要</em></p>\n<h4 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端要求用户提供授权凭据，通常是账号密码</p>\n<p>然后，客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>password</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>username</code>：用户账号</li>\n<li><code>password</code>：用户密码</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-2\"><a href=\"#使用-oauth2-server-实现-2\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-2\"><a href=\"#初始化授权码类型-2\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\PasswordGrant(</span><br><span class=\"line\">     $userRepository,</span><br><span class=\"line\">     $refreshTokenRepository</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将密码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端模式\"><a href=\"#客户端模式\" class=\"headerlink\" title=\"客户端模式\"></a>客户端模式</h2><p>客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。</p>\n<h4 id=\"流程-2\"><a href=\"#流程-2\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>client_credentials</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n</ul>\n<p><em>此模式下无需刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-3\"><a href=\"#使用-oauth2-server-实现-3\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-3\"><a href=\"#初始化授权码类型-3\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将客户端授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新访问令牌-access-token\"><a href=\"#刷新访问令牌-access-token\" class=\"headerlink\" title=\"刷新访问令牌(access token)\"></a>刷新访问令牌(access token)</h2><p>访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。</p>\n<h4 id=\"流程-3\"><a href=\"#流程-3\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>refresh_token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>refresh_token</code>：刷新令牌</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-4\"><a href=\"#使用-oauth2-server-实现-4\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-4\"><a href=\"#初始化授权码类型-4\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 新的刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将刷新访问令牌添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 新的访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"资源服务器验证访问令牌\"><a href=\"#资源服务器验证访问令牌\" class=\"headerlink\" title=\"资源服务器验证访问令牌\"></a>资源服务器验证访问令牌</h2><p>oauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。</p>\n<p>客户端需要在 <code>HTTP Header</code> 中使用 <code>Authorization</code> 传入访问令牌，如果通过，中间件将会在 <code>request</code> 中加入对应数据：</p>\n<ul>\n<li><code>oauth_access_token_id</code>：访问令牌 id</li>\n<li><code>oauth_client_id</code>: 客户端id</li>\n<li><code>oauth_user_id</code>：用户id</li>\n<li><code>oauth_scopes</code>：权限范围</li>\n</ul>\n<p>授权不通过，则抛出 <code>OAuthServerException::accessDenied</code> 异常。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 授权服务器分发的公钥</span></span><br><span class=\"line\">$publicKeyPath = <span class=\"string\">'file://path/to/public.key'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// 创建 ResourceServer</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\ResourceServer(</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $publicKeyPath</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中间件</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);</span><br></pre></td></tr></table></figure>\n<p>如果所用路由不支持中间件，可自行实现，符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可 ：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t$request = $server-&gt;validateAuthenticatedRequest($request);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> OAuthServerException($exception-&gt;getMessage(), <span class=\"number\">0</span>, <span class=\"string\">'unknown_error'</span>, <span class=\"number\">500</span>))-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"oauth2-server-实现\"><a href=\"#oauth2-server-实现\" class=\"headerlink\" title=\"oauth2-server 实现\"></a>oauth2-server 实现</h2><p>oauth2-server 的实现需要我们手动创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>，下面展示一个项目目录示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Entities</span><br><span class=\"line\">\t- AccessTokenEntity.php</span><br><span class=\"line\">\t- AuthCodeEntity.php</span><br><span class=\"line\">\t- ClientEntity.php</span><br><span class=\"line\">\t- RefreshTokenEntity.php</span><br><span class=\"line\">\t- ScopeEntity.php</span><br><span class=\"line\">\t- UserEntity.php</span><br><span class=\"line\">- Repositories</span><br><span class=\"line\">\t- AccessTokenRepository.php</span><br><span class=\"line\">\t- AuthCodeRepository.php</span><br><span class=\"line\">\t- ClientRepository.php</span><br><span class=\"line\">\t- RefreshTokenRepository.php</span><br><span class=\"line\">\t- ScopeRepository.php</span><br><span class=\"line\">\t- UserRepository.php</span><br></pre></td></tr></table></figure>\n<h3 id=\"Repositories\"><a href=\"#Repositories\" class=\"headerlink\" title=\"Repositories\"></a>Repositories</h3><p>Repositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义所需要实现的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AccessTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewToken</span><span class=\"params\">(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新访问令牌时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AccessTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要在返回前，向 AccessTokenEntity 传入参数中对应属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例代码：</span></span><br><span class=\"line\">        $accessToken = <span class=\"keyword\">new</span> AccessTokenEntity();</span><br><span class=\"line\">        $accessToken-&gt;setClient($clientEntity);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> ($scopes <span class=\"keyword\">as</span> $scope) &#123;</span><br><span class=\"line\">            $accessToken-&gt;addScope($scope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $accessToken-&gt;setUserIdentifier($userIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $accessToken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAccessToken</span><span class=\"params\">(AccessTokenEntityInterface $accessTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储访问令牌，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getIdentifier(); // 获得令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getExpiryDateTime(); // 获得令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAccessToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用刷新令牌创建新的访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原访问令牌的唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// 可将其在持久化存储中过期</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAccessTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源服务器验证访问令牌时将调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证访问令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AuthCodeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewAuthCode</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AuthCodeEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AuthCodeEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAuthCode</span><span class=\"params\">(AuthCodeEntityInterface $authCodeEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新授权码时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储授权码，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getIdentifier(); // 获得授权码唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getExpiryDateTime(); // 获得授权码过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAuthCode</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以在此时将授权码从持久化数据库中删除</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为授权码唯一标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAuthCodeRevoked</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证授权码是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ClientEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getClientEntity</span><span class=\"params\">($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取客户端对象时调用方法，用于验证客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 ClientEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientIdentifier 客户端唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $grantType 代表授权类型，根据类型不同，验证方式也不同</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的</span></span><br><span class=\"line\">        <span class=\"comment\">// $mustValidateSecret 代表是否需要验证客户端密钥</span></span><br><span class=\"line\">        $client = <span class=\"keyword\">new</span> ClientEntity();</span><br><span class=\"line\">        $client-&gt;setIdentifier($clientIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> RefreshTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewRefreshToken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 RefreshTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RefreshTokenEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewRefreshToken</span><span class=\"params\">(RefreshTokenEntityInterface $refreshTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新刷新令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于持久化存储授刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getIdentifier(); // 获得刷新令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getExpiryDateTime(); // 获得刷新令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getAccessToken()-&gt;getIdentifier(); // 获得访问令牌标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeRefreshToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 原刷新令牌将删除，创建新的刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原刷新令牌唯一标识</span></span><br><span class=\"line\">        <span class=\"comment\">// 可在此删除原刷新令牌</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRefreshTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证刷新令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ScopeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getScopeEntityByIdentifier</span><span class=\"params\">($identifier)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证权限是否在权限范围中会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为单个权限标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功则返回 ScopeEntityInterface 对象</span></span><br><span class=\"line\">        $scope = <span class=\"keyword\">new</span> ScopeEntity();</span><br><span class=\"line\">        $scope-&gt;setIdentifier($identifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalizeScopes</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        array $scopes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $userIdentifier = null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在创建授权码与访问令牌前会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证权限范围、授权类型、客户端、用户是否匹配</span></span><br><span class=\"line\">        <span class=\"comment\">// 可整合进项目自身的权限控制中</span></span><br><span class=\"line\">        <span class=\"comment\">// 必须返回 ScopeEntityInterface 对象可用的 scope 数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例：</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope = new ScopeEntity();</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope-&gt;setIdentifier('example');</span></span><br><span class=\"line\">        <span class=\"comment\">// $scopes[] = $scope;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scopes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> UserEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserEntityByUserCredentials</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $username,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $password,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证用户时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证用户信息是否符合</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功返回 UserEntityInterface 对象</span></span><br><span class=\"line\">        $user = <span class=\"keyword\">new</span> UserEntity();</span><br><span class=\"line\">        $user-&gt;setIdentifier(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Entities\"><a href=\"#Entities\" class=\"headerlink\" title=\"Entities\"></a>Entities</h3><p>Entities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义需要实现的方法，同时提供了 <a href=\"#Traits\">Traits</a> 帮助我们实现，可以选择使用，有需要时也可以重写。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">AccessTokenTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">AuthCodeTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">ClientTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">RefreshTokenTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 没有 Trait 实现这个方法，需要自行实现</span></span><br><span class=\"line\">    <span class=\"comment\">// oauth2-server 项目的测试代码的实现例子</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonSerialize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;getIdentifier();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h3><p><strong>Repositories</strong></p>\n<ul>\n<li><p>League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php</p>\n</li>\n</ul>\n<p><strong>Entities</strong></p>\n<ul>\n<li>League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\TokenInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\UserEntityInterface.php</li>\n</ul>\n<h3 id=\"Traits\"><a href=\"#Traits\" class=\"headerlink\" title=\"Traits\"></a>Traits</h3><ul>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php</li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>oauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。</p>\n<h5 id=\"client-authentication-failed\"><a href=\"#client-authentication-failed\" class=\"headerlink\" title=\"client.authentication.failed\"></a>client.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'client.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>客户端身份验证未通过时触发此事件。你可以在客户端尝试 <code>n</code> 次失败后禁止它一段时间内的再次尝试。</p>\n<h5 id=\"user-authentication-failed\"><a href=\"#user-authentication-failed\" class=\"headerlink\" title=\"user.authentication.failed\"></a>user.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'user.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 <code>n</code> 次后禁止用户再次尝试。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>《oauth2-server 官方文档》(<a href=\"https://oauth2.thephpleague.com/\" target=\"_blank\" rel=\"noopener\">https://oauth2.thephpleague.com/</a>)</p>\n<p>《理解OAuth 2.0》-阮一峰（<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://en.wikipedia.org/wiki/OAuth\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a> 是关于授权的开放网络标准，它允许用户已第三方应用获取该用户在某一网站的私密资源，而无需提供用户名与密码，目前已在全世界得到广泛应用。</p>\n<p><a href=\"https://github.com/thephpleague/oauth2-server\" target=\"_blank\" rel=\"noopener\">league/oauth2-server</a> 是一个轻量级并且功能强大的符合 OAuth2.0 协议的 PHP 库，使用它可以构建出标准的 OAuth2.0 授权服务器。</p>\n<p>本文通过对 PHP 库：league/oauth2-server 进行实践的同时，理解 OAuth2.0 的工作流程与设计思路。</p>","more":"<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>了解 OAuth2.0 与 oauth2-server 的专用术语，对于理解后面内容很有帮助。</p>\n<p><strong>OAuth2.0 定义了四个角色</strong></p>\n<ol>\n<li><strong>Client</strong>：客户端，第三方应用程序。</li>\n<li><strong>Resource Owner</strong>：资源所有者，授权 Client 访问其帐户的用户。</li>\n<li><strong>Authorization server</strong>：授权服务器，服务商专用于处理用户授权认证的服务器。</li>\n<li><strong>Resource server</strong>：资源服务器，服务商用于存放用户受保护资源的服务器，它可以与授权服务器是同一台服务器，也可以是不同的服务器。</li>\n</ol>\n<p><strong>oauth2-server</strong></p>\n<ol>\n<li><strong>Access token</strong>：用于访问受保护资源的令牌。</li>\n<li><strong>Authorization code</strong>：发放给应用程序的中间令牌，客户端应用使用此令牌交换 access token。</li>\n<li><strong>Scope</strong>：授予应用程序的权限范围。</li>\n<li><strong>JWT</strong>：<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">Json Web Token</a> 是一种用于安全传输的数据传输格式。</li>\n</ol>\n<h2 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h2><p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd2xhuoj30o70lkq3n.jpg\" alt=\"flowchart.png\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>推荐使用 <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">Composer</a> 进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require league/oauth2-server</span><br></pre></td></tr></table></figure>\n<p>根据<a href=\"#授权模式\">授权模式</a>的不同，oauth2-server 提供了不同的 Interface 与 Triat 帮助实现。</p>\n<p><em>本文发布时，版本号为7.3.1。</em></p>\n<p><strong>生成公钥与私钥</strong></p>\n<p>公钥与私钥用于签名和验证传输的 <a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">JWT</a>，授权服务器使用私钥签名 JWT，资源服务器拥有公钥验证 JWT。</p>\n<p><em>oauth2-server 使用 JWT 传输访问令牌(access token)，方便资源服务器获取其中内容，所以需要使用非对称加密。</em></p>\n<p>生成私钥，在终端中运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out private.key 2048</span><br></pre></td></tr></table></figure>\n<p>使用私钥提取私钥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in private.key -pubout -out public.key</span><br></pre></td></tr></table></figure>\n<p>私钥必须保密于授权服务器中，并将公钥分发给资源服务器。</p>\n<p><strong>生成加密密钥</strong></p>\n<p>加密密钥用于加密授权码(auth code)与刷新令牌(refesh token)，AuthorizationServer(授权服务器启动类)接受两种加密密钥，<code>string</code> 或 <code>defuse/php-encryption</code> 库的对象。</p>\n<p><em>加密授权码(auth code)与刷新令牌(refesh token)只有授权权服务器使用，所以使用对称加密。</em></p>\n<p>生成字符串密钥，在终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &apos;echo base64_encode(random_bytes(32)), PHP_EOL;&apos;</span><br></pre></td></tr></table></figure>\n<p>生成对象，在项目根目录的终端中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vendor/bin/generate-defuse-key</span><br></pre></td></tr></table></figure>\n<p>将获得的内容，传入 AuthorizationServer：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> \\<span class=\"title\">Defuse</span>\\<span class=\"title\">Crypto</span>\\<span class=\"title\">Key</span>;</span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKeyPath,</span><br><span class=\"line\">    Key::loadFromAsciiSafeString($encryptionKey) <span class=\"comment\">//传入加密密钥</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><strong>PHP版本支持</strong></p>\n<ul>\n<li>PHP 7.0</li>\n<li>PHP 7.1</li>\n<li>PHP 7.2</li>\n</ul>\n<h2 id=\"授权模式\"><a href=\"#授权模式\" class=\"headerlink\" title=\"授权模式\"></a>授权模式</h2><p>OAuth2.0 定义了四种授权模式，以应对不同情况时的授权。</p>\n<ol>\n<li>授权码模式</li>\n<li>隐式授权模式</li>\n<li>密码模式</li>\n<li>客户端模式</li>\n</ol>\n<h2 id=\"客户端类型\"><a href=\"#客户端类型\" class=\"headerlink\" title=\"客户端类型\"></a>客户端类型</h2><ul>\n<li>保密的：<ul>\n<li>客户端可以安全的存储自己与用户的凭据（例如：有所属的服务器端）</li>\n</ul>\n</li>\n<li>公开的：<ul>\n<li>客户端无法安全的存储自己与用户的凭据（例如：运行在浏览器的单页应用）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选用哪种授权模式？\"><a href=\"#选用哪种授权模式？\" class=\"headerlink\" title=\"选用哪种授权模式？\"></a>选用哪种授权模式？</h2><p>如果客户端是保密的，应使用<a href=\"#授权码模式\">授权码模式</a>。</p>\n<p>如果客户端是公开的，应使用<a href=\"#隐式授权模式\">隐式授权模式</a>。</p>\n<p>如果用户对于此客户端高度信任（例如：第一方应用程序或操作系统程序），应使用<a href=\"#密码模式\">密码模式</a>。</p>\n<p>如果客户端是以自己的名义，不与用户产生关系，应使用<a href=\"#客户端模式\">客户端模式</a>。</p>\n<h2 id=\"预先注册\"><a href=\"#预先注册\" class=\"headerlink\" title=\"预先注册\"></a>预先注册</h2><p>客户端需要预先在授权服务器进行注册，用以获取 <code>client_id</code> 与 <code>client_secret</code>，也可以在注册是预先设定好 <code>redirect_uri</code>，以便于之后可以使用默认的 <code>redirect_uri</code>。</p>\n<h2 id=\"授权码模式\"><a href=\"#授权码模式\" class=\"headerlink\" title=\"授权码模式\"></a>授权码模式</h2><p>授权码模式是 OAuth2.0 种功能最完整，流程最严密的一种模式，如果你使用过 Google 或 QQ 登录过第三方应用程序，应该会对这个流程的第一部分很熟悉。</p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p><strong>第一部分（用户可见）</strong></p>\n<p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>code</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>code</code>：授权码(Authorization code)</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此客户端而非其他客户端程序</li>\n</ul>\n<p><strong>第二部分（用户不可见）</strong></p>\n<p>客户端已得到授权，通过 <code>POST</code> 请求向授权服务器获取访问令牌(access token)：</p>\n<ul>\n<li><code>grant_type</code>：授权模式，值固定为：<code>authorization_code</code></li>\n<li><code>client_id</code>：客户端ID</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>redirect_uri</code>：使用与第一部分请求相同的 URI</li>\n<li><code>code</code>：第一部分所获的的授权码，要注意URL解码</li>\n</ul>\n<p>授权服务器核对授权码与重定向 URI，确认无误后，向客户端响应下列内容：</p>\n<ul>\n<li><p><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></p>\n</li>\n<li><p><code>expires_in</code>：访问令牌的存活时间</p>\n</li>\n<li><p><code>access_token</code>：访问令牌</p>\n</li>\n<li><p><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</p>\n</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现\"><a href=\"#使用-oauth2-server-实现\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><p>OAuth2.0 只是协议，在实现上需要联系到用户与数据库存储，oauth2-server 的新版本并没有指定某种数据库，但它提供了 <a href=\"#Interfaces\">Interfaces</a> 与 <a href=\"#Traits\">Traits</a> 帮助我们实现，这让我们可以方便的使用任何形式的数据存储方式，这种方便的代价就是需要我们自行创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>。</p>\n<h5 id=\"初始化-server\"><a href=\"#初始化-server\" class=\"headerlink\" title=\"初始化 server\"></a>初始化 server</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化存储库</span></span><br><span class=\"line\">$clientRepository = <span class=\"keyword\">new</span> ClientRepository(); <span class=\"comment\">// Interface: ClientRepositoryInterface</span></span><br><span class=\"line\">$scopeRepository = <span class=\"keyword\">new</span> ScopeRepository(); <span class=\"comment\">// Interface: ScopeRepositoryInterface</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\">$authCodeRepository = <span class=\"keyword\">new</span> AuthCodeRepository(); <span class=\"comment\">// Interface: AuthCodeRepositoryInterface</span></span><br><span class=\"line\">$refreshTokenRepository = <span class=\"keyword\">new</span> RefreshTokenRepository(); <span class=\"comment\">// Interface: RefreshTokenRepositoryInterface</span></span><br><span class=\"line\">$userRepository = <span class=\"keyword\">new</span> UserRepository(); <span class=\"comment\">//Interface: UserRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 私钥与加密密钥</span></span><br><span class=\"line\">$privateKey = <span class=\"string\">'file://path/to/private.key'</span>;</span><br><span class=\"line\"><span class=\"comment\">//$privateKey = new CryptKey('file://path/to/private.key', 'passphrase'); // 如果私钥文件有密码</span></span><br><span class=\"line\">$encryptionKey = <span class=\"string\">'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen'</span>; <span class=\"comment\">// 加密密钥字符串</span></span><br><span class=\"line\"><span class=\"comment\">// $encryptionKey = Key::loadFromAsciiSafeString($encryptionKey); //如果通过 generate-defuse-key 脚本生成的字符串，可使用此方法传入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化 server</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\AuthorizationServer(</span><br><span class=\"line\">    $clientRepository,</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $scopeRepository,</span><br><span class=\"line\">    $privateKey,</span><br><span class=\"line\">    $encryptionKey</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h5 id=\"初始化授权码类型\"><a href=\"#初始化授权码类型\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 授权码授权类型初始化</span></span><br><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant(</span><br><span class=\"line\">    $authCodeRepository,</span><br><span class=\"line\">    $refreshTokenRepository,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT10M'</span>) <span class=\"comment\">// 设置授权码过期时间为10分钟</span></span><br><span class=\"line\">);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将授权码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<p>用户向客户端提出 OAuth 登录请求，客户端将用户重定向授权服务器的地址（例如：<a href=\"https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：\" target=\"_blank\" rel=\"noopener\">https://example.com/authorize?response_type=code&amp;client_id={client_id}&amp;redirect_uri={redirect_uri}&amp;scope{scope}&amp;state={state})：</a></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;get(<span class=\"string\">'/authorize'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证 HTTP 请求，并返回 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = $server-&gt;validateAuthorizationRequest($request);</span><br><span class=\"line\">        <span class=\"comment\">// 此时应将 authRequest 对象序列化后存在当前会话(session)中</span></span><br><span class=\"line\">        $_SESSION[<span class=\"string\">'authRequest'</span>] = serialize($authRequest);</span><br><span class=\"line\">        <span class=\"comment\">// 然后将用户重定向至登录入口或在当前地址直接响应登录页面</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;getBody()-&gt;write(file_get_contents(<span class=\"string\">\"login.html\"</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wd9vzqsj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">        // 设置用户实体(userEntity)</span><br><span class=\"line\">        $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">        // 设置权限范围</span><br><span class=\"line\">        $authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">        // true = 批准，false = 拒绝</span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">        // 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">        // 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>客户端通过授权码请求访问令牌：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式授权模式\"><a href=\"#隐式授权模式\" class=\"headerlink\" title=\"隐式授权模式\"></a>隐式授权模式</h2><p>隐式授权相当于是授权码模式的简化版本：</p>\n<h4 id=\"流程-用户可见\"><a href=\"#流程-用户可见\" class=\"headerlink\" title=\"流程(用户可见)\"></a>流程(用户可见)</h4><p>用户访问客户端，客户端将用户导向授权服务器时，将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>response_type</code>：授权类型，必选项，值固定为：<code>token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>redirect_uri</code>：重定向URI，可选项，不填写时默认预先注册的重定向URI</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>state</code>：<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"noopener\">CSRF</a>令牌，可选项，但强烈建议使用，应将该值存储与用户会话中，以便在返回时验证</li>\n</ul>\n<p>用户选择是否给予客户端授权</p>\n<p>假设用户给予授权，授权服务器将用户导向客户端事先指定的 <code>redirect_uri</code>，并将以下参数通过 <code>GET query</code> 传入：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>state</code>：请求中发送的 <code>state</code>，原样返回。客户端将此值与用户会话中的值进行对比，以确保授权码响应的是此应用程序而非其他应用程序</li>\n</ul>\n<p>整个流程与授权码模式的第一部分类似，只是授权服务器直接响应了访问令牌，跳过了授权码的步骤。它适用于没有服务器，完全运行在前端的应用程序。</p>\n<p><em>此模式下没有刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-1\"><a href=\"#使用-oauth2-server-实现-1\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-1\"><a href=\"#初始化授权码类型-1\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将隐式授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ImplicitGrant(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>)),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/login'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在会话(session)中取出 authRequest 对象</span></span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[<span class=\"string\">'authRequest'</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 设置用户实体(userEntity)</span></span><br><span class=\"line\">        $authRequest-&gt;setUser(<span class=\"keyword\">new</span> UserEntity(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置权限范围</span></span><br><span class=\"line\">        $authRequest-&gt;setScopes([<span class=\"string\">'basic'</span>])</span><br><span class=\"line\">        <span class=\"comment\">// true = 批准，false = 拒绝</span></span><br><span class=\"line\">        $authRequest-&gt;setAuthorizationApproved(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 完成后重定向至客户端请求重定向地址</span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以捕获 OAuthServerException，将其转为 HTTP 响应</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他异常</span></span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时展示给用户的是这样的页面：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g85wde8ypgj30yg0ke0wc.jpg\" alt=\"qq-oauth.png\"></p>\n<p>用户提交登录后，设置好用户实体(userEntity)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(&apos;/login&apos;, function (ServerRequestInterface $request, ResponseInterface $response) use ($server) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">\t      // 在会话(session)中取出 authRequest 对象</span><br><span class=\"line\">        $authRequest = unserialize($_SESSION[&apos;authRequest&apos;]);</span><br><span class=\"line\">\t\t\t\t// 设置用户实体(userEntity)</span><br><span class=\"line\">\t\t    $authRequest-&gt;setUser(new UserEntity(1));</span><br><span class=\"line\">\t\t\t\t// 设置权限范围</span><br><span class=\"line\">\t\t\t\t$authRequest-&gt;setScopes([&apos;basic&apos;])</span><br><span class=\"line\">\t\t\t\t// true = 批准，false = 拒绝</span><br><span class=\"line\">\t\t    $authRequest-&gt;setAuthorizationApproved(true);</span><br><span class=\"line\">\t\t\t\t// 完成后重定向至客户端请求重定向地址</span><br><span class=\"line\">\t\t    return $server-&gt;completeAuthorizationRequest($authRequest, $response);</span><br><span class=\"line\">    &#125; catch (OAuthServerException $exception) &#123;</span><br><span class=\"line\">        // 可以捕获 OAuthServerException，将其转为 HTTP 响应</span><br><span class=\"line\">        return $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; catch (\\Exception $exception) &#123;</span><br><span class=\"line\">    \t// 其他异常</span><br><span class=\"line\">        $body = new Stream(fopen(&apos;php://temp&apos;, &apos;r+&apos;));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        return $response-&gt;withStatus(500)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"密码模式\"><a href=\"#密码模式\" class=\"headerlink\" title=\"密码模式\"></a>密码模式</h2><p>密码模式是由用户提供给客户端账号密码来获取访问令牌，这属于危险行为，所以此模式只适用于高度信任的客户端（例如第一方应用程序）。客户端不应存储用户的账号密码。</p>\n<p><em>OAuth2 协议规定此模式不需要传 <code>client_id</code> &amp; <code>client_secret</code>，但 oauth-server 库需要</em></p>\n<h4 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端要求用户提供授权凭据，通常是账号密码</p>\n<p>然后，客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>password</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>username</code>：用户账号</li>\n<li><code>password</code>：用户密码</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-2\"><a href=\"#使用-oauth2-server-实现-2\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-2\"><a href=\"#初始化授权码类型-2\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\PasswordGrant(</span><br><span class=\"line\">     $userRepository,</span><br><span class=\"line\">     $refreshTokenRepository</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 设置刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将密码授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端模式\"><a href=\"#客户端模式\" class=\"headerlink\" title=\"客户端模式\"></a>客户端模式</h2><p>客户端模式是指以客户端的名义，而不是用户的名义，向授权服务器获取认证。在这个模式下，用户与授权服务器不产生关系，用户只能感知到的客户端，所产生的资源也都由客户端处理。</p>\n<h4 id=\"流程-2\"><a href=\"#流程-2\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>client_credentials</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n</ul>\n<p><em>此模式下无需刷新令牌(refresh token)的返回。</em></p>\n<h4 id=\"使用-oauth2-server-实现-3\"><a href=\"#使用-oauth2-server-实现-3\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-3\"><a href=\"#初始化授权码类型-3\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将客户端授权类型添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 设置访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><em>注意：这里的示例演示的是 Slim Framework 的用法，Slim 不是这个库的必要条件，只需要请求与响应符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可。</em></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新访问令牌-access-token\"><a href=\"#刷新访问令牌-access-token\" class=\"headerlink\" title=\"刷新访问令牌(access token)\"></a>刷新访问令牌(access token)</h2><p>访问令牌有一个较短的存活时间，在过期后，客户端通过刷新令牌来获得新的访问令牌与刷新令牌。当用户长时间不活跃，刷新令牌也过期后，就需要重新获取授权。</p>\n<h4 id=\"流程-3\"><a href=\"#流程-3\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>客户端发送 <code>POST</code> 请求至授权服务器，携带以下参数：</p>\n<ul>\n<li><code>grant_type</code>：授权类型，必选项，值固定为：<code>refresh_token</code></li>\n<li><code>client_id</code>：客户端ID，必选项</li>\n<li><code>client_secret</code>：客户端 secret</li>\n<li><code>scope</code>：权限范围，可选项，以空格分隔</li>\n<li><code>refresh_token</code>：刷新令牌</li>\n</ul>\n<p>授权服务器响应以下内容：</p>\n<ul>\n<li><code>token_type</code>：令牌类型，值固定为：<code>Bearer</code></li>\n<li><code>expires_in</code>：访问令牌的存活时间</li>\n<li><code>access_token</code>：访问令牌</li>\n<li><code>refresh_token</code>：刷新令牌，访问令牌过期后，使用刷新令牌重新获取</li>\n</ul>\n<h4 id=\"使用-oauth2-server-实现-4\"><a href=\"#使用-oauth2-server-实现-4\" class=\"headerlink\" title=\"使用 oauth2-server 实现\"></a>使用 oauth2-server 实现</h4><p><strong><a href=\"#初始化\">初始化 server</a></strong></p>\n<h5 id=\"初始化授权码类型-4\"><a href=\"#初始化授权码类型-4\" class=\"headerlink\" title=\"初始化授权码类型\"></a>初始化授权码类型</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$grant = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);</span><br><span class=\"line\">$grant-&gt;setRefreshTokenTTL(<span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'P1M'</span>)); <span class=\"comment\">// 新的刷新令牌过期时间1个月</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将刷新访问令牌添加进 server</span></span><br><span class=\"line\">$server-&gt;enableGrantType(</span><br><span class=\"line\">    $grant,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> \\DateInterval(<span class=\"string\">'PT1H'</span>) <span class=\"comment\">// 新的访问令牌过期时间1小时</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><em><a href=\"http://php.net/manual/zh/class.dateinterval.php\" target=\"_blank\" rel=\"noopener\">DateInterval</a></em></p>\n<h5 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$app-&gt;post(<span class=\"string\">'/access_token'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(ServerRequestInterface $request, ResponseInterface $response)</span> <span class=\"title\">use</span> <span class=\"params\">($server)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里只需要这一行就可以，具体的判断在 Repositories 中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $server-&gt;respondToAccessTokenRequest($request, $response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\League\\OAuth2\\Server\\<span class=\"keyword\">Exception</span>\\OAuthServerException $exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">        $body = <span class=\"keyword\">new</span> Stream(fopen(<span class=\"string\">'php://temp'</span>, <span class=\"string\">'r+'</span>));</span><br><span class=\"line\">        $body-&gt;write($exception-&gt;getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $response-&gt;withStatus(<span class=\"number\">500</span>)-&gt;withBody($body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"资源服务器验证访问令牌\"><a href=\"#资源服务器验证访问令牌\" class=\"headerlink\" title=\"资源服务器验证访问令牌\"></a>资源服务器验证访问令牌</h2><p>oauth2-server 为资源服务器提供了一个中间件用于验证访问令牌。</p>\n<p>客户端需要在 <code>HTTP Header</code> 中使用 <code>Authorization</code> 传入访问令牌，如果通过，中间件将会在 <code>request</code> 中加入对应数据：</p>\n<ul>\n<li><code>oauth_access_token_id</code>：访问令牌 id</li>\n<li><code>oauth_client_id</code>: 客户端id</li>\n<li><code>oauth_user_id</code>：用户id</li>\n<li><code>oauth_scopes</code>：权限范围</li>\n</ul>\n<p>授权不通过，则抛出 <code>OAuthServerException::accessDenied</code> 异常。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">$accessTokenRepository = <span class=\"keyword\">new</span> AccessTokenRepository(); <span class=\"comment\">// Interface: AccessTokenRepositoryInterface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 授权服务器分发的公钥</span></span><br><span class=\"line\">$publicKeyPath = <span class=\"string\">'file://path/to/public.key'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// 创建 ResourceServer</span></span><br><span class=\"line\">$server = <span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\ResourceServer(</span><br><span class=\"line\">    $accessTokenRepository,</span><br><span class=\"line\">    $publicKeyPath</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中间件</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> \\League\\OAuth2\\Server\\Middleware\\ResourceServerMiddleware($server);</span><br></pre></td></tr></table></figure>\n<p>如果所用路由不支持中间件，可自行实现，符合<a href=\"https://www.php-fig.org/psr/psr-7/\" target=\"_blank\" rel=\"noopener\">PSR-7</a>规范即可 ：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t$request = $server-&gt;validateAuthenticatedRequest($request);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (OAuthServerException $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> $exception-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> OAuthServerException($exception-&gt;getMessage(), <span class=\"number\">0</span>, <span class=\"string\">'unknown_error'</span>, <span class=\"number\">500</span>))-&gt;generateHttpResponse($response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"oauth2-server-实现\"><a href=\"#oauth2-server-实现\" class=\"headerlink\" title=\"oauth2-server 实现\"></a>oauth2-server 实现</h2><p>oauth2-server 的实现需要我们手动创建 <a href=\"#Repositories\">Repositories</a> 与 <a href=\"#Entities\">Entities</a>，下面展示一个项目目录示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Entities</span><br><span class=\"line\">\t- AccessTokenEntity.php</span><br><span class=\"line\">\t- AuthCodeEntity.php</span><br><span class=\"line\">\t- ClientEntity.php</span><br><span class=\"line\">\t- RefreshTokenEntity.php</span><br><span class=\"line\">\t- ScopeEntity.php</span><br><span class=\"line\">\t- UserEntity.php</span><br><span class=\"line\">- Repositories</span><br><span class=\"line\">\t- AccessTokenRepository.php</span><br><span class=\"line\">\t- AuthCodeRepository.php</span><br><span class=\"line\">\t- ClientRepository.php</span><br><span class=\"line\">\t- RefreshTokenRepository.php</span><br><span class=\"line\">\t- ScopeRepository.php</span><br><span class=\"line\">\t- UserRepository.php</span><br></pre></td></tr></table></figure>\n<h3 id=\"Repositories\"><a href=\"#Repositories\" class=\"headerlink\" title=\"Repositories\"></a>Repositories</h3><p>Repositories 里主要是处理关于授权码、访问令牌等数据的存储逻辑，oauth2-server 提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义所需要实现的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AccessTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewToken</span><span class=\"params\">(ClientEntityInterface $clientEntity, array $scopes, $userIdentifier = null)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新访问令牌时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AccessTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要在返回前，向 AccessTokenEntity 传入参数中对应属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例代码：</span></span><br><span class=\"line\">        $accessToken = <span class=\"keyword\">new</span> AccessTokenEntity();</span><br><span class=\"line\">        $accessToken-&gt;setClient($clientEntity);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> ($scopes <span class=\"keyword\">as</span> $scope) &#123;</span><br><span class=\"line\">            $accessToken-&gt;addScope($scope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $accessToken-&gt;setUserIdentifier($userIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $accessToken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAccessToken</span><span class=\"params\">(AccessTokenEntityInterface $accessTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储访问令牌，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AccessTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getIdentifier(); // 获得令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getExpiryDateTime(); // 获得令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $accessTokenEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAccessToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用刷新令牌创建新的访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原访问令牌的唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// 可将其在持久化存储中过期</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAccessTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源服务器验证访问令牌时将调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证访问令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> AuthCodeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewAuthCode</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 AuthCodeEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AuthCodeEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewAuthCode</span><span class=\"params\">(AuthCodeEntityInterface $authCodeEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新授权码时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以用于持久化存储授权码，持久化数据库自行选择</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 AuthCodeEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getIdentifier(); // 获得授权码唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getExpiryDateTime(); // 获得授权码过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getUserIdentifier(); // 获得用户标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getScopes(); // 获得权限范围</span></span><br><span class=\"line\">        <span class=\"comment\">// $authCodeEntity-&gt;getClient()-&gt;getIdentifier(); // 获得客户端标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeAuthCode</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以在此时将授权码从持久化数据库中删除</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为授权码唯一标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isAuthCodeRevoked</span><span class=\"params\">($codeId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用授权码获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证授权码是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ClientEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getClientEntity</span><span class=\"params\">($clientIdentifier, $grantType = null, $clientSecret = null, $mustValidateSecret = true)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取客户端对象时调用方法，用于验证客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 ClientEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientIdentifier 客户端唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $grantType 代表授权类型，根据类型不同，验证方式也不同</span></span><br><span class=\"line\">        <span class=\"comment\">// $clientSecret 代表客户端密钥，是客户端事先在授权服务器中注册时得到的</span></span><br><span class=\"line\">        <span class=\"comment\">// $mustValidateSecret 代表是否需要验证客户端密钥</span></span><br><span class=\"line\">        $client = <span class=\"keyword\">new</span> ClientEntity();</span><br><span class=\"line\">        $client-&gt;setIdentifier($clientIdentifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> RefreshTokenEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewRefreshToken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新授权码时调用方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要返回 RefreshTokenEntityInterface 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RefreshTokenEntity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">persistNewRefreshToken</span><span class=\"params\">(RefreshTokenEntityInterface $refreshTokenEntity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建新刷新令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于持久化存储授刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以使用参数中的 RefreshTokenEntityInterface 对象，获得有价值的信息：</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getIdentifier(); // 获得刷新令牌唯一标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getExpiryDateTime(); // 获得刷新令牌过期时间</span></span><br><span class=\"line\">        <span class=\"comment\">// $refreshTokenEntity-&gt;getAccessToken()-&gt;getIdentifier(); // 获得访问令牌标识符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">revokeRefreshToken</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 原刷新令牌将删除，创建新的刷新令牌</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为原刷新令牌唯一标识</span></span><br><span class=\"line\">        <span class=\"comment\">// 可在此删除原刷新令牌</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRefreshTokenRevoked</span><span class=\"params\">($tokenId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当使用刷新令牌获取访问令牌时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证刷新令牌是否已被删除</span></span><br><span class=\"line\">        <span class=\"comment\">// return true 已删除，false 未删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> ScopeEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getScopeEntityByIdentifier</span><span class=\"params\">($identifier)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证权限是否在权限范围中会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数为单个权限标识符</span></span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功则返回 ScopeEntityInterface 对象</span></span><br><span class=\"line\">        $scope = <span class=\"keyword\">new</span> ScopeEntity();</span><br><span class=\"line\">        $scope-&gt;setIdentifier($identifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalizeScopes</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        array $scopes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $userIdentifier = null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在创建授权码与访问令牌前会调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证权限范围、授权类型、客户端、用户是否匹配</span></span><br><span class=\"line\">        <span class=\"comment\">// 可整合进项目自身的权限控制中</span></span><br><span class=\"line\">        <span class=\"comment\">// 必须返回 ScopeEntityInterface 对象可用的 scope 数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例：</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope = new ScopeEntity();</span></span><br><span class=\"line\">        <span class=\"comment\">// $scope-&gt;setIdentifier('example');</span></span><br><span class=\"line\">        <span class=\"comment\">// $scopes[] = $scope;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $scopes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> UserEntityInterface</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserEntityByUserCredentials</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $username,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $password,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        $grantType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ClientEntityInterface $clientEntity</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证用户时调用此方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于验证用户信息是否符合</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以验证是否为用户可使用的授权类型($grantType)与客户端($clientEntity)</span></span><br><span class=\"line\">        <span class=\"comment\">// 验证成功返回 UserEntityInterface 对象</span></span><br><span class=\"line\">        $user = <span class=\"keyword\">new</span> UserEntity();</span><br><span class=\"line\">        $user-&gt;setIdentifier(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Entities\"><a href=\"#Entities\" class=\"headerlink\" title=\"Entities\"></a>Entities</h3><p>Entities 里是 oauth2-server 处理授权与认证逻辑的类，它为我们提供了 <a href=\"#Interfaces\">Interfaces</a> 来定义需要实现的方法，同时提供了 <a href=\"#Traits\">Traits</a> 帮助我们实现，可以选择使用，有需要时也可以重写。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">AccessTokenTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthCodeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthCodeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">TokenEntityTrait</span>, <span class=\"title\">AuthCodeTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClientEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>, <span class=\"title\">ClientTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefreshTokenEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">RefreshTokenEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">RefreshTokenTrait</span>, <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ScopeEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 没有 Trait 实现这个方法，需要自行实现</span></span><br><span class=\"line\">    <span class=\"comment\">// oauth2-server 项目的测试代码的实现例子</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonSerialize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;getIdentifier();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserEntity</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserEntityInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">EntityTrait</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h3><p><strong>Repositories</strong></p>\n<ul>\n<li><p>League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\AuthCodeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ClientRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\RefreshTokenRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\ScopeRepositoryInterface.php</p>\n</li>\n<li><p>League\\OAuth2\\Server\\Repositories\\UserRepositoryInterface.php</p>\n</li>\n</ul>\n<p><strong>Entities</strong></p>\n<ul>\n<li>League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\AuthCodeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ClientEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\RefreshTokenEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\ScopeEntityInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\TokenInterface.php</li>\n<li>League\\OAuth2\\Server\\Entities\\UserEntityInterface.php</li>\n</ul>\n<h3 id=\"Traits\"><a href=\"#Traits\" class=\"headerlink\" title=\"Traits\"></a>Traits</h3><ul>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AccessTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\AuthCodeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ClientTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\EntityTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\RefreshTokenTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\ScopeTrait.php</li>\n<li>League\\OAuth2\\Server\\Entities\\Traits\\TokenEntityTrait.php</li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>oauth2-server 预设了一些事件，目前官方文档中只有两个，余下的可以在 RequestEvent.php 文件中查看。</p>\n<h5 id=\"client-authentication-failed\"><a href=\"#client-authentication-failed\" class=\"headerlink\" title=\"client.authentication.failed\"></a>client.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'client.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>客户端身份验证未通过时触发此事件。你可以在客户端尝试 <code>n</code> 次失败后禁止它一段时间内的再次尝试。</p>\n<h5 id=\"user-authentication-failed\"><a href=\"#user-authentication-failed\" class=\"headerlink\" title=\"user.authentication.failed\"></a>user.authentication.failed</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$server-&gt;getEmitter()-&gt;addListener(</span><br><span class=\"line\">    <span class=\"string\">'user.authentication.failed'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(\\League\\OAuth2\\Server\\RequestEvent $event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>用户身份验证未通过时触发此事件。你可以通过这里提醒用户重置密码，或尝试 <code>n</code> 次后禁止用户再次尝试。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>《oauth2-server 官方文档》(<a href=\"https://oauth2.thephpleague.com/\" target=\"_blank\" rel=\"noopener\">https://oauth2.thephpleague.com/</a>)</p>\n<p>《理解OAuth 2.0》-阮一峰（<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）</a></p>"},{"title":"RESTful缓存方案","date":"2016-09-10T11:18:17.000Z","_content":"\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","source":"_posts/RESTful-cache.md","raw":"---\ntitle: RESTful缓存方案\ndate: 2016/9/10 19:18:17\n---\n\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","slug":"RESTful-cache","published":1,"updated":"2019-10-21T08:58:41.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29by000ayz79eggmwv6y","content":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>\n<a id=\"more\"></a>  \n<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">资源无更新示例:</span><br><span class=\"line\">304 Not Modified</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\"></span><br><span class=\"line\">资源有更新示例:</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;ooooooooooooo&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>\n","site":{"data":{}},"excerpt":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>","more":"<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">资源无更新示例:</span><br><span class=\"line\">304 Not Modified</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\"></span><br><span class=\"line\">资源有更新示例:</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">Cache-Controller: max-age=60</span><br><span class=\"line\">ETag: &quot;ooooooooooooo&quot;</span><br><span class=\"line\">Content-Lenght: 1024</span><br></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>"},{"title":"超媒体驱动的 Web API","date":"2017-04-20T11:18:17.000Z","_content":"\n**REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。**\n\n<!--more-->  \n\n### 超媒体的重要性\n\n超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。\n\n> Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。\n\n这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 **互联网规模（Internet-scale）** 的 **分布式** **超媒体** 系统的需求来进行分析。\n\n**超媒体是 REST 的基点之一。**\n\n### WEB API 中的超媒体\n\n超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《[REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。\n\n**关于超媒体与超文本，以下是Fielding博士在评论中的回复**\n\n> When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.\n\n### 超媒体的作用\n\n论文中给出的正式的超媒体的定义：\n\n> 超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。\n\n**超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力**。举个例子，HTML 的 <a> 标签：\n\n```\n<a href=\"http://www.baidu.com/\">点击我将跳转至百度</a>\n```\n\n这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\n```\n\n这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。\n\n> 超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。\n\n以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。\n\n> 通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。\n\n### Web API 存在的问题\n\n* Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。\n\n* 要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。\n\n* Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。\n\n### 解决方案\n\n目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。\n\n### 困惑-Web API的发展方向\n\n目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？\n\n### 总结\n\n嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。\n","source":"_posts/hypertext-driven.md","raw":"---\ntitle: 超媒体驱动的 Web API\ndate: 2017/4/20 19:18:17\n---\n\n**REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。**\n\n<!--more-->  \n\n### 超媒体的重要性\n\n超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。\n\n> Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。\n\n这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 **互联网规模（Internet-scale）** 的 **分布式** **超媒体** 系统的需求来进行分析。\n\n**超媒体是 REST 的基点之一。**\n\n### WEB API 中的超媒体\n\n超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《[REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。\n\n**关于超媒体与超文本，以下是Fielding博士在评论中的回复**\n\n> When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.\n\n### 超媒体的作用\n\n论文中给出的正式的超媒体的定义：\n\n> 超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。\n\n**超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力**。举个例子，HTML 的 <a> 标签：\n\n```\n<a href=\"http://www.baidu.com/\">点击我将跳转至百度</a>\n```\n\n这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\n```\n\n这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。\n\n> 超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。\n\n以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。\n\n> 通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。\n\n### Web API 存在的问题\n\n* Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。\n\n* 要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。\n\n* Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。\n\n### 解决方案\n\n目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。\n\n### 困惑-Web API的发展方向\n\n目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？\n\n### 总结\n\n嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。\n","slug":"hypertext-driven","published":1,"updated":"2019-06-10T08:22:31.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29bz000byz790gtfkfho","content":"<p><strong>REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。</strong></p>\n<a id=\"more\"></a>  \n<h3 id=\"超媒体的重要性\"><a href=\"#超媒体的重要性\" class=\"headerlink\" title=\"超媒体的重要性\"></a>超媒体的重要性</h3><p>超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。</p>\n<blockquote>\n<p>Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。</p>\n</blockquote>\n<p>这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 <strong>互联网规模（Internet-scale）</strong> 的 <strong>分布式</strong> <strong>超媒体</strong> 系统的需求来进行分析。</p>\n<p><strong>超媒体是 REST 的基点之一。</strong></p>\n<h3 id=\"WEB-API-中的超媒体\"><a href=\"#WEB-API-中的超媒体\" class=\"headerlink\" title=\"WEB API 中的超媒体\"></a>WEB API 中的超媒体</h3><p>超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《<a href=\"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\" target=\"_blank\" rel=\"noopener\">REST APIs must be hypertext-driven</a>》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。</p>\n<p><strong>关于超媒体与超文本，以下是Fielding博士在评论中的回复</strong></p>\n<blockquote>\n<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.</p>\n</blockquote>\n<h3 id=\"超媒体的作用\"><a href=\"#超媒体的作用\" class=\"headerlink\" title=\"超媒体的作用\"></a>超媒体的作用</h3><p>论文中给出的正式的超媒体的定义：</p>\n<blockquote>\n<p>超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。</p>\n</blockquote>\n<p><strong>超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力</strong>。举个例子，HTML 的 <a> 标签：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;点击我将跳转至百度&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br></pre></td></tr></table></figure>\n<p>这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。</p>\n<blockquote>\n<p>超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。</p>\n</blockquote>\n<p>以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。</p>\n<blockquote>\n<p>通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。</p>\n</blockquote>\n<h3 id=\"Web-API-存在的问题\"><a href=\"#Web-API-存在的问题\" class=\"headerlink\" title=\"Web API 存在的问题\"></a>Web API 存在的问题</h3><ul>\n<li><p>Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。</p>\n</li>\n<li><p>要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。</p>\n</li>\n<li><p>Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。</p>\n<h3 id=\"困惑-Web-API的发展方向\"><a href=\"#困惑-Web-API的发展方向\" class=\"headerlink\" title=\"困惑-Web API的发展方向\"></a>困惑-Web API的发展方向</h3><p>目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。</p>\n","site":{"data":{}},"excerpt":"<p><strong>REST 必须是超媒体驱动的！我在以前关于 RESTful API 的博文中，对于超媒体驱动只有简单的提过，现在来探索这个问题。</strong></p>","more":"<h3 id=\"超媒体的重要性\"><a href=\"#超媒体的重要性\" class=\"headerlink\" title=\"超媒体的重要性\"></a>超媒体的重要性</h3><p>超媒体这个概念的基础含义我就不再赘述了，说一说超媒体在 Web 的重要性。</p>\n<blockquote>\n<p>Web（万维网，英文全称 World Wide Web，简称 Web）的成功，很大程度上是因为其软件架构设计满足了拥有互联网规模（Internet-scale）的分布式超媒体系统的需求。</p>\n</blockquote>\n<p>这是Fielding博士在论文中对于 Web 的定义，而 REST 架构风格，正是一直指导着现代 web 架构的设计与开发。这篇论文中提起的所有架构属性，都是基于 <strong>互联网规模（Internet-scale）</strong> 的 <strong>分布式</strong> <strong>超媒体</strong> 系统的需求来进行分析。</p>\n<p><strong>超媒体是 REST 的基点之一。</strong></p>\n<h3 id=\"WEB-API-中的超媒体\"><a href=\"#WEB-API-中的超媒体\" class=\"headerlink\" title=\"WEB API 中的超媒体\"></a>WEB API 中的超媒体</h3><p>超媒体对于 web 的重要性显而易见了，但是在 web API 中超媒体却发展的不是很理想，很多不是超媒体驱动的 web API 也自称 RESTful API，Fielding博士在2008年10月20日，发表了一篇文章：《<a href=\"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\" target=\"_blank\" rel=\"noopener\">REST APIs must be hypertext-driven</a>》，博士在文章中与下方的评论中阐述了超媒体的重要性。毫无疑问，REST 这个 buzzword 的专利是属于Fielding博士的，嗯，既然不符合标准我以前的博文还是换个 buzzword 吧，改为 HTTP API 好了。</p>\n<p><strong>关于超媒体与超文本，以下是Fielding博士在评论中的回复</strong></p>\n<blockquote>\n<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions. Hypermedia is just an expansion on what text means to include temporal anchors within a media stream; most researchers have dropped the distinction.</p>\n</blockquote>\n<h3 id=\"超媒体的作用\"><a href=\"#超媒体的作用\" class=\"headerlink\" title=\"超媒体的作用\"></a>超媒体的作用</h3><p>论文中给出的正式的超媒体的定义：</p>\n<blockquote>\n<p>超媒体（hypermedia）是由应用控制信息（application control information）来定义的，这些控制信息内嵌在信息的表达（the presentation of information）之中，或者作为信息的表达之上的一层。</p>\n</blockquote>\n<p><strong>超媒体将资源互相连接起来，并以机器可读的方式来描述它们的能力</strong>。举个例子，HTML 的 <a> 标签：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;点击我将跳转至百度&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的超媒体控件，它向浏览器传达了它可以发起这样的一个请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br></pre></td></tr></table></figure>\n<p>这就是机器可读的超媒体格式，HTML 还有其他更多更复杂的超媒体控件。</p>\n<blockquote>\n<p>超媒体是服务器用以和客户端进行对话的一种方式，客户端从而可以知道未来将可以向服务器发起什么样的请求。它就是一个由服务器提供的菜单，客户端可以从中自由的进行选择。服务器通常都知道可能发生哪些事，但是客户端将决定实际发生什么。其实这并不是什么新鲜的话题，我们的万维网就是以这种方式工作的，并且我们都想当然地认为它就应该是这样工作的，其他的任何方式都是一种无用的历史的倒退。但是在 API 的世界里，超媒体仍然是一个令人难以理解且富有争议的话题。这也说明了为什么如今的 API 在应对变化时还是显得如此糟糕。</p>\n</blockquote>\n<p>以上出自《RESTful Web APIs》第四章。想一想现在的大部分 web API，是不是就是缺少超媒体，缺少机器可读的方式，只有人类可读的文档。</p>\n<blockquote>\n<p>通过合理地使用超媒体，便可以解决或至少是改善现今 web API 存在的可用性和稳定性问题。</p>\n</blockquote>\n<h3 id=\"Web-API-存在的问题\"><a href=\"#Web-API-存在的问题\" class=\"headerlink\" title=\"Web API 存在的问题\"></a>Web API 存在的问题</h3><ul>\n<li><p>Web API 经常有大量的阅读文档来告诉你如何为不同的资管构造 URL。这违背了 REST 的连通性与自描述信息的原则。</p>\n</li>\n<li><p>要集成一个新的 API，不可避免的就要编写新的定制化软件，或者安装别人编写的代码库，哪怕这个新的 API 也叫作 RESTful API，哪怕这个新的 API 是你原来用过的同一个公司的不同产品。</p>\n</li>\n<li><p>Web API 发生了变化以后，定制化的 API 客户端就不能正常使用了，需要维护者进行一些代码修复。对比来看，当网站重新设计改版，用户可能会抱怨，然后慢慢适应。在这期间，浏览器可不会停止工作。</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>目前已经有了一些超媒体解决方案，《RESTful Web APIs》中有着详细的介绍，我还没有完全理解，先不讲出来误人子弟了。</p>\n<h3 id=\"困惑-Web-API的发展方向\"><a href=\"#困惑-Web-API的发展方向\" class=\"headerlink\" title=\"困惑-Web API的发展方向\"></a>困惑-Web API的发展方向</h3><p>目前在我看来，有着超媒体的 web API 以后的发展方向就是：传输数据与自描述消息，但是展现形式却由客户端来定义，如果展现也是服务器给出的话，那 API 客户端也就是另一个浏览器了。可这绝对是不符合大部分 API 提供者的利益，或许这种理想化的情况只能出现在以后的人工智能中吗？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>嗯，标题党了，没有给出超媒体驱动的解决方案，只是讲了我对于超媒体以及 web API 的一些观点，确实是对于实现这里还没有完全理解，日后有所收获了再分享。</p>"},{"title":"Session 与 JWT","date":"2017-08-11T11:18:17.000Z","_content":"\n**关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT**\n\n<!--more-->  \n\n### 知识点\n\n1. **无状态**\n\n\t* 关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。\n\n\t* 《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》\n\n\t* > 客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有**会话状态（session state）** 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。\n\n\t* 《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。\n\n2. **Cookie**\n\n\t* 说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。\n\n\t* > cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。\n\n\t* > 可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。\n\n\t* 以上是《HTTP权威指南》一书中对于 cookie 的解释。\n\n3. **Session ID**\n\n\t* 会话 cookie 就是现在人们常说的 session，他的表现形式通常为：\n\n\t* > 一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。\n\n\t* 恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是**使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法**。\n\n4. **JWT**\n\n\t* > JSON Web Token（JWT）是一种开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。\n\n\t* 这种格式有很多优点，我这里用于与 session ID 来比较的是它的**自成一体**。\n\n\t* > 自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。\n\n\t* 是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。\n\n### 比较\n\n在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，[《为什么 session 机制没有被 JWT 所取代?》](https://www.v2ex.com/t/381996)，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。\n\n### 无状态架构的取舍\n\n在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。\n\nFielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。\n\n> 这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。\n> 与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。\n\n*顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。*\n\n### Session ID 与 JWT 的取舍\n\n**Session ID**\n\n先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。\n\n* 可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。\n* 可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。\n* 可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。\n\n**JWT**\n\n再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。\n\n*额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。*\n\n**取舍**\n\n服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。\n\n### 总结\n\nsession ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。\n\n但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。\n","source":"_posts/session-and-JWT.md","raw":"---\ntitle: Session 与 JWT\ndate: 2017/8/11 19:18:17\n---\n\n**关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT**\n\n<!--more-->  \n\n### 知识点\n\n1. **无状态**\n\n\t* 关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。\n\n\t* 《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》\n\n\t* > 客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有**会话状态（session state）** 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。\n\n\t* 《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。\n\n2. **Cookie**\n\n\t* 说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。\n\n\t* > cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。\n\n\t* > 可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。\n\n\t* 以上是《HTTP权威指南》一书中对于 cookie 的解释。\n\n3. **Session ID**\n\n\t* 会话 cookie 就是现在人们常说的 session，他的表现形式通常为：\n\n\t* > 一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。\n\n\t* 恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是**使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法**。\n\n4. **JWT**\n\n\t* > JSON Web Token（JWT）是一种开放标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。\n\n\t* 这种格式有很多优点，我这里用于与 session ID 来比较的是它的**自成一体**。\n\n\t* > 自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。\n\n\t* 是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。\n\n### 比较\n\n在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，[《为什么 session 机制没有被 JWT 所取代?》](https://www.v2ex.com/t/381996)，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。\n\n### 无状态架构的取舍\n\n在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。\n\nFielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。\n\n> 这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。\n> 与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。\n\n*顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。*\n\n### Session ID 与 JWT 的取舍\n\n**Session ID**\n\n先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。\n\n* 可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。\n* 可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。\n* 可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。\n\n**JWT**\n\n再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。\n\n*额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。*\n\n**取舍**\n\n服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。\n\n### 总结\n\nsession ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。\n\n但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。\n","slug":"session-and-JWT","published":1,"updated":"2019-10-21T08:58:52.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29c0000cyz796414he97","content":"<p><strong>关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT</strong></p>\n<a id=\"more\"></a>  \n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li><p><strong>无状态</strong></p>\n<ul>\n<li><p>关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。</p>\n</li>\n<li><p>《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》</p>\n</li>\n<li><blockquote>\n<p>客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有<strong>会话状态（session state）</strong> 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。</p>\n</blockquote>\n</li>\n<li><p>《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Cookie</strong></p>\n<ul>\n<li><p>说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。</p>\n</li>\n<li><blockquote>\n<p>cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。</p>\n</blockquote>\n</li>\n<li><p>以上是《HTTP权威指南》一书中对于 cookie 的解释。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Session ID</strong></p>\n<ul>\n<li><p>会话 cookie 就是现在人们常说的 session，他的表现形式通常为：</p>\n</li>\n<li><blockquote>\n<p>一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。</p>\n</blockquote>\n</li>\n<li><p>恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是<strong>使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>JWT</strong></p>\n<ul>\n<li><blockquote>\n<p>JSON Web Token（JWT）是一种开放标准（<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">RFC 7519</a>），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。</p>\n</blockquote>\n</li>\n<li><p>这种格式有很多优点，我这里用于与 session ID 来比较的是它的<strong>自成一体</strong>。</p>\n</li>\n<li><blockquote>\n<p>自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。</p>\n</blockquote>\n</li>\n<li><p>是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，<a href=\"https://www.v2ex.com/t/381996\" target=\"_blank\" rel=\"noopener\">《为什么 session 机制没有被 JWT 所取代?》</a>，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。</p>\n<h3 id=\"无状态架构的取舍\"><a href=\"#无状态架构的取舍\" class=\"headerlink\" title=\"无状态架构的取舍\"></a>无状态架构的取舍</h3><p>在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。</p>\n<p>Fielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。</p>\n<blockquote>\n<p>这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。<br>与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。</p>\n</blockquote>\n<p><em>顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。</em></p>\n<h3 id=\"Session-ID-与-JWT-的取舍\"><a href=\"#Session-ID-与-JWT-的取舍\" class=\"headerlink\" title=\"Session ID 与 JWT 的取舍\"></a>Session ID 与 JWT 的取舍</h3><p><strong>Session ID</strong></p>\n<p>先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。</p>\n<ul>\n<li>可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。</li>\n<li>可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。</li>\n<li>可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。</li>\n</ul>\n<p><strong>JWT</strong></p>\n<p>再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。</p>\n<p><em>额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。</em></p>\n<p><strong>取舍</strong></p>\n<p>服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>session ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。</p>\n<p>但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。</p>\n","site":{"data":{}},"excerpt":"<p><strong>关于 REST 与 HTTP 中无状态架构约束的思考之 Session 与 JWT</strong></p>","more":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li><p><strong>无状态</strong></p>\n<ul>\n<li><p>关于无状态，Fielding博士在论文的 3.4.3 与 5.1.3 中有所提及。</p>\n</li>\n<li><p>《3.4.3 客户-无状态-服务器（Client-Stateless-Server）》</p>\n</li>\n<li><blockquote>\n<p>客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件至上不允许有<strong>会话状态（session state）</strong> 。从客户发给服务器的每个请求中，都必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文（content），会话状态应全部保存在客户端。</p>\n</blockquote>\n</li>\n<li><p>《5.1.3 无状态》中对于无状态的描述与 3.4.3 一致。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Cookie</strong></p>\n<ul>\n<li><p>说 session 之前先说一下 cookie，因为有太多人将 cookie 与 session 搞混了。</p>\n</li>\n<li><blockquote>\n<p>cookie 最初由网景公司开发，是当前识别用户，实现持久会话的最好方式。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie，会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。会话 cookie 和持久 cookie 的唯一区别就是它们的过期时间。</p>\n</blockquote>\n</li>\n<li><p>以上是《HTTP权威指南》一书中对于 cookie 的解释。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Session ID</strong></p>\n<ul>\n<li><p>会话 cookie 就是现在人们常说的 session，他的表现形式通常为：</p>\n</li>\n<li><blockquote>\n<p>一个很短的由数字和字母组成的字符串键，它和服务器端的某个非常大的数据结构相关联。</p>\n</blockquote>\n</li>\n<li><p>恩，上面是《RESTful Web APIs》对于 seesion 的看法，也就是 session ID。这也是我对于这个知识点想说明的，我针对的不是会话 cookie 的运行机制，而是<strong>使用字符串来代替会话状态，将会话状态全部存储于服务器端的使用方法</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>JWT</strong></p>\n<ul>\n<li><blockquote>\n<p>JSON Web Token（JWT）是一种开放标准（<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">RFC 7519</a>），它定义了一种紧凑且自成一体的方式，使用 JSON 格式安全地传输信息。</p>\n</blockquote>\n</li>\n<li><p>这种格式有很多优点，我这里用于与 session ID 来比较的是它的<strong>自成一体</strong>。</p>\n</li>\n<li><blockquote>\n<p>自成一体：这个载体（payload）包含所有的用户请求信息，避免频繁的查询数据库。</p>\n</blockquote>\n</li>\n<li><p>是不是似曾相识的描述，没错，无状态也是这个标准：包含理解请求所必须的全部信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>在我最初的想法里，是没有比较这个概念的，很明显，JWT 是符合无状态架构风格的，且它最常见的使用地点也是在认证授权部分，所以怎么看都是要比 seesion ID 要好用的。于是我去 v2ex 问了一下这个问题，<a href=\"https://www.v2ex.com/t/381996\" target=\"_blank\" rel=\"noopener\">《为什么 session 机制没有被 JWT 所取代?》</a>，很感谢V友们热心回答。经过整理总结，我也理解了 JWT 的不足与 session ID 的优点。</p>\n<h3 id=\"无状态架构的取舍\"><a href=\"#无状态架构的取舍\" class=\"headerlink\" title=\"无状态架构的取舍\"></a>无状态架构的取舍</h3><p>在说 JWT 与 session ID 的差异之前，先说一下关于无状态架构的取舍。</p>\n<p>Fielding博士是通过整理一系列基于网络应用的架构风格，并对其分类评估，而后有所取舍，组合成的 REST。不可能每种架构都只有优点没有缺点，无状态架构也一样，论文的 3.4.3小节 与 5.1.3小节，Fielding博士对于无状态的取舍有着详细的表述。</p>\n<blockquote>\n<p>这一约束产生了可见性，可靠性，可伸缩性三个架构属性，改善了可见性是因为监视系统不必为了确定一个请求的全部性质而去查看该请求之外的多个请求。改善了可靠性是因为它减轻了从局部故障中恢复的任务量。改善了可伸缩性是因为不必在多个请求之间保存状态，从而允许服务器组件迅速释放资源，并进一步简化其实现，因为服务器不必跨多个请求管理资源的使用情况。<br>与大多数架构抉择一样，无状态这一架构约束反映出了设计上的权衡点。其缺点是：由于不能将状态数据保存在服务器上的共享上下文中，因此增加了在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性能。此外，将应用状态放在客户端还降低了服务器对于一致的应用行为的控制能力，因为这样一来，应用就得依赖于跨多个客户端版本（semantics across multiple client versions）的语义的正确实现。</p>\n</blockquote>\n<p><em>顺带一提，原来我认为 cookie 应该是符合无状态的，因为它还是将内容存在客户端的，每次请求都需要携带。但《RESTful Web APIs》中点出了 cookie 的问题，作者认为：客户端一旦接受了一个 cookie，它就应该与随后一定时间内的所有请求一起提交给服务器。服务器也会要求客户端以后不能再发起在接受这个 cookie 之前曾经发起过的请求了。这也违反了无状态原则。</em></p>\n<h3 id=\"Session-ID-与-JWT-的取舍\"><a href=\"#Session-ID-与-JWT-的取舍\" class=\"headerlink\" title=\"Session ID 与 JWT 的取舍\"></a>Session ID 与 JWT 的取舍</h3><p><strong>Session ID</strong></p>\n<p>先说 session ID 存在的问题，由于违反了无状态的架构约束，所以很明显的也就没有了可见性，可靠性，可伸缩性。</p>\n<ul>\n<li>可见性：客户端不可能在一堆混乱的字符串中得到有用信息，自然没有了可见性。</li>\n<li>可靠性：一旦发生故障，可能需要跨越多个请求的结果查询信息，增加了任务量。</li>\n<li>可伸缩性：这个词在论文中被提到过很多很多次了，客户-服务器改善了可伸缩性，无状态改善了可伸缩性，缓存改善了可伸缩性等等等等，可见可伸缩性在 Web 中的重要性了。那么 session ID 在哪方面对可伸缩性造成了影响呢？举个简单的例子：负载均衡。这个很常见对吧，做 Web 的应该都有接触，负载均衡就是很常见的横向的可伸缩性。session ID 在这种情况下，就有很明显的问题，他需要每个单元对其进行额外的处理，比如 session 的同步，或者 session 单独剥离出一个额外的单元，还需要为这个额外的单元考虑负载问题。</li>\n</ul>\n<p><strong>JWT</strong></p>\n<p>再说 JWT 的问题，符合了无状态的架构约束，上面的那三个架构属性都有所改善，问题也正是交互的开销问题，JWT 在有些时候要存储所有完整的会话是不现实的，这就需要存储资源ID，需要进行额外的处理。但是对比 session ID 来说，额外的资源存储要少很多。</p>\n<p><em>额外提一点，这里只讨论了 JWT 的自成一体这一机制，其他不讨论。</em></p>\n<p><strong>取舍</strong></p>\n<p>服务器没有了会话状态的保存，涉及到认证授权的一些问题，需要额外进行处理，例如注销，统计在线用户数量等问题。由于有这些问题的存在，处理后的 JWT 很可能变为另一个 session ID，但 session ID 在这方面更加成熟。所以，请根据自身的项目，采取适当的处理方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>session ID 机制在网站中已经是一套很成熟的系统的。不遵守无状态架构约束所带来的后果也都有着大量的解决方案。JWT 这种符合无状态架构约束的机制，并没有带来很明显的效果，所以很难推广开来。</p>\n<p>但是，在 Web API 的领域，session ID 的问题被进一步的凸显，所以应该尽量选择符合无状态架构约束的机制。</p>"},{"title":"Vue 学习路线","date":"2019-04-10T13:20:19.000Z","_content":"\n## 前言\n\n本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。\n\n<!--more-->  \n\n## 为什么选择vue\n\n可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。\n\n* Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。\n* 相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。\n\n* 渐进式框架也可以更好的逐步的改变原有项目。\n* 团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。\n\n## 学习路线\n\n0. ### JavaScript与web基础\n\n   学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。\n\n1. ### Vue 基本概念\n\n   使用 Vue 来构建项目，需要先了解一些基本概念：\n\n   **渐进式框架**\n\n   渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。\n\n   在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。\n\n   Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。\n\n   **声明式渲染**\n\n   ```HTML\n   <div id=\"app\">\n     {{ message }}\n   </div>\n   ```\n\n   ```javascript\n   var app = new Vue({\n     el: '#app',\n     data: {\n       message: 'Hello Vue!'\n     }\n   })\n   ```\n\n   这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。\n\n   **响应式数据**\n\n   在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 `app.message` 的值，就可以看到页面也会发生对应改变。\n\n   **组件化**\n\n   组件化的核心思想就是：将页面结构映射为组件树。\n\n   ![component-tree.png](https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480)\n\n   组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。\n\n   **单页面应用与客户端路由**\n\n   单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。\n\n   Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。\n\n   **状态管理**\n\n   在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。\n\n   这就是 Vuex 所做的事情。\n\n2. ### 使用 Vue 构建单页面应用\n\n   以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。\n\n   **构建工具**\n\n   Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。\n\n   最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。\n\n   **使用 axios 访问 Web API**\n\n   Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。\n\n   作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。\n\n   如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。\n\n   **测试**\n\n   如果想要开发出稳定可维护的项目，测试是必不可少的。\n\n   Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。\n\n   **Chrome 开发者工具**\n\n   Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。\n\n   **多端支持**\n\n   可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。\n\n3. ### 前端技术栈\n\n   上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。\n\n   **现代 JavaScript 与 Babel**\n\n   Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。\n\n   如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。\n\n   **Webpack**\n\n   Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。\n\n   虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。\n\n   **TypeScript 与 Flow**\n\n   Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。\n\n   这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。\n\n   Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。\n\n4. ### Vue 生态系统\n\n   **官方核心插件**\n\n   上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。\n\n   **官方工具**\n\n   上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。\n\n   **UI 组件库**\n\n   也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。\n\n   市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。\n\n5. ### 深入理解 Vue\n\n   **为什么是渐进式框架**\n\n   *框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》*\n\n   当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。\n\n   但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。\n\n   React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。\n\n   Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。\n\n   Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。\n\n   **声明式渲染**\n\n   Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。\n\n   那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。\n\n   虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。\n\n   Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。\n\n   当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。\n\n   不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。\n\n   **状态管理**\n\n   状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。\n\n   ![state-单向数据流.png](https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c)\n\n   在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。\n\n   它将组件的共享状态抽离出来，放入 Store，组件通过调度（`dispatch`）使用 Action，Action 通过提交（`commit`）Mutation 修改 State，然后响应到组件。\n\n   ![vuex.png](https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d)\n\n6. ### 实现原理\n\n   **生命周期**\n\n   ![lifecycle.png](https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4)\n\n   **Virtual DOM**\n\n   Virtual DOM 在 Vue 中的实现。\n\n   **响应式数据原理**\n\n   在 Vue2，使用的是 ES5 的 `Object.defineProperty` 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。\n\n   在即将到来的 Vue3 中，会使用 `Proxy` 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。\n\n   **编译与渲染函数**\n\n   在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。\n\n   **组件化**\n\n   每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。\n\n   **v-model**\n\n   Vue 提供了 `v-model` 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。\n\n   ```html\n   <input v-model=\"sth\" />\n   <input v-bind:value=\"sth\" v-on:input=\"sth = $event.target.value\" />\n   ```\n\n   **核心插件**\n\n   Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。\n\n   Vuex：初始化过程，如何管理全局状态等。\n\n## 思维导图\n\n![Vue 学习路线.png](https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6)\n\n## 相关学习资料\n\n[《Vue 2.0——渐进式前端解决方案》](https://www.infoq.cn/article/vue-2-progressive-front-end-solution) 尤雨溪\n\n[《Vue Guide》](https://cn.vuejs.org/v2/guide/) Vue 官方团队\n\n[《Vue.js 技术揭秘》](https://ustbhuangyi.github.io/vue-analysis/) ustbhuangyi\n\n[《Vuex》](https://vuex.vuejs.org/zh/) Vuex\n\n[VueConf](https://vue.w3ctech.com/) VueConf\n\n[Vue.js developers](https://vuejsdevelopers.com/) vuejsdevelopers.com\n\n## 参考文章\n\n[《2019 年 Vue 学习路线图》](https://www.infoq.cn/article/9XymmTqu*4QwahqikMka)","source":"_posts/Vue-learning-route.md","raw":"---\ntitle: Vue 学习路线\ndate: 2019/04/10 21:20:19\n---\n\n## 前言\n\n本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。\n\n<!--more-->  \n\n## 为什么选择vue\n\n可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。\n\n* Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。\n* 相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。\n\n* 渐进式框架也可以更好的逐步的改变原有项目。\n* 团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。\n\n## 学习路线\n\n0. ### JavaScript与web基础\n\n   学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。\n\n1. ### Vue 基本概念\n\n   使用 Vue 来构建项目，需要先了解一些基本概念：\n\n   **渐进式框架**\n\n   渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。\n\n   在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。\n\n   Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。\n\n   **声明式渲染**\n\n   ```HTML\n   <div id=\"app\">\n     {{ message }}\n   </div>\n   ```\n\n   ```javascript\n   var app = new Vue({\n     el: '#app',\n     data: {\n       message: 'Hello Vue!'\n     }\n   })\n   ```\n\n   这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。\n\n   **响应式数据**\n\n   在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 `app.message` 的值，就可以看到页面也会发生对应改变。\n\n   **组件化**\n\n   组件化的核心思想就是：将页面结构映射为组件树。\n\n   ![component-tree.png](https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480)\n\n   组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。\n\n   **单页面应用与客户端路由**\n\n   单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。\n\n   Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。\n\n   **状态管理**\n\n   在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。\n\n   这就是 Vuex 所做的事情。\n\n2. ### 使用 Vue 构建单页面应用\n\n   以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。\n\n   **构建工具**\n\n   Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。\n\n   最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。\n\n   **使用 axios 访问 Web API**\n\n   Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。\n\n   作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。\n\n   如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。\n\n   **测试**\n\n   如果想要开发出稳定可维护的项目，测试是必不可少的。\n\n   Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。\n\n   **Chrome 开发者工具**\n\n   Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。\n\n   **多端支持**\n\n   可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。\n\n3. ### 前端技术栈\n\n   上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。\n\n   **现代 JavaScript 与 Babel**\n\n   Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。\n\n   如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。\n\n   **Webpack**\n\n   Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。\n\n   虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。\n\n   **TypeScript 与 Flow**\n\n   Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。\n\n   这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。\n\n   Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。\n\n4. ### Vue 生态系统\n\n   **官方核心插件**\n\n   上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。\n\n   **官方工具**\n\n   上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。\n\n   **UI 组件库**\n\n   也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。\n\n   市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。\n\n5. ### 深入理解 Vue\n\n   **为什么是渐进式框架**\n\n   *框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》*\n\n   当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。\n\n   但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。\n\n   React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。\n\n   Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。\n\n   Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。\n\n   **声明式渲染**\n\n   Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。\n\n   那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。\n\n   虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。\n\n   Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。\n\n   当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。\n\n   不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。\n\n   **状态管理**\n\n   状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。\n\n   ![state-单向数据流.png](https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c)\n\n   在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。\n\n   它将组件的共享状态抽离出来，放入 Store，组件通过调度（`dispatch`）使用 Action，Action 通过提交（`commit`）Mutation 修改 State，然后响应到组件。\n\n   ![vuex.png](https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d)\n\n6. ### 实现原理\n\n   **生命周期**\n\n   ![lifecycle.png](https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4)\n\n   **Virtual DOM**\n\n   Virtual DOM 在 Vue 中的实现。\n\n   **响应式数据原理**\n\n   在 Vue2，使用的是 ES5 的 `Object.defineProperty` 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。\n\n   在即将到来的 Vue3 中，会使用 `Proxy` 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。\n\n   **编译与渲染函数**\n\n   在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。\n\n   **组件化**\n\n   每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。\n\n   **v-model**\n\n   Vue 提供了 `v-model` 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。\n\n   ```html\n   <input v-model=\"sth\" />\n   <input v-bind:value=\"sth\" v-on:input=\"sth = $event.target.value\" />\n   ```\n\n   **核心插件**\n\n   Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。\n\n   Vuex：初始化过程，如何管理全局状态等。\n\n## 思维导图\n\n![Vue 学习路线.png](https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6)\n\n## 相关学习资料\n\n[《Vue 2.0——渐进式前端解决方案》](https://www.infoq.cn/article/vue-2-progressive-front-end-solution) 尤雨溪\n\n[《Vue Guide》](https://cn.vuejs.org/v2/guide/) Vue 官方团队\n\n[《Vue.js 技术揭秘》](https://ustbhuangyi.github.io/vue-analysis/) ustbhuangyi\n\n[《Vuex》](https://vuex.vuejs.org/zh/) Vuex\n\n[VueConf](https://vue.w3ctech.com/) VueConf\n\n[Vue.js developers](https://vuejsdevelopers.com/) vuejsdevelopers.com\n\n## 参考文章\n\n[《2019 年 Vue 学习路线图》](https://www.infoq.cn/article/9XymmTqu*4QwahqikMka)","slug":"Vue-learning-route","published":1,"updated":"2019-10-21T08:59:12.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29c1000dyz79l26yh3m3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。</p>\n<a id=\"more\"></a>  \n<h2 id=\"为什么选择vue\"><a href=\"#为什么选择vue\" class=\"headerlink\" title=\"为什么选择vue\"></a>为什么选择vue</h2><p>可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。</p>\n<ul>\n<li>Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。</li>\n<li><p>相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。</p>\n</li>\n<li><p>渐进式框架也可以更好的逐步的改变原有项目。</p>\n</li>\n<li>团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。</li>\n</ul>\n<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><ol>\n<li><h3 id=\"JavaScript与web基础\"><a href=\"#JavaScript与web基础\" class=\"headerlink\" title=\"JavaScript与web基础\"></a>JavaScript与web基础</h3><p>学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。</p>\n</li>\n<li><h3 id=\"Vue-基本概念\"><a href=\"#Vue-基本概念\" class=\"headerlink\" title=\"Vue 基本概念\"></a>Vue 基本概念</h3><p>使用 Vue 来构建项目，需要先了解一些基本概念：</p>\n<p><strong>渐进式框架</strong></p>\n<p>渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。</p>\n<p>在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。</p>\n<p>Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。</p>\n<p><strong>声明式渲染</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123; message &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。</p>\n<p><strong>响应式数据</strong></p>\n<p>在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 <code>app.message</code> 的值，就可以看到页面也会发生对应改变。</p>\n<p><strong>组件化</strong></p>\n<p>组件化的核心思想就是：将页面结构映射为组件树。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480\" alt=\"component-tree.png\"></p>\n<p>组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。</p>\n<p><strong>单页面应用与客户端路由</strong></p>\n<p>单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。</p>\n<p>Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。</p>\n<p><strong>状态管理</strong></p>\n<p>在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。</p>\n<p>这就是 Vuex 所做的事情。</p>\n</li>\n<li><h3 id=\"使用-Vue-构建单页面应用\"><a href=\"#使用-Vue-构建单页面应用\" class=\"headerlink\" title=\"使用 Vue 构建单页面应用\"></a>使用 Vue 构建单页面应用</h3><p>以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。</p>\n<p><strong>构建工具</strong></p>\n<p>Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。</p>\n<p>最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。</p>\n<p><strong>使用 axios 访问 Web API</strong></p>\n<p>Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。</p>\n<p>作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。</p>\n<p>如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。</p>\n<p><strong>测试</strong></p>\n<p>如果想要开发出稳定可维护的项目，测试是必不可少的。</p>\n<p>Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。</p>\n<p><strong>Chrome 开发者工具</strong></p>\n<p>Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。</p>\n<p><strong>多端支持</strong></p>\n<p>可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。</p>\n</li>\n<li><h3 id=\"前端技术栈\"><a href=\"#前端技术栈\" class=\"headerlink\" title=\"前端技术栈\"></a>前端技术栈</h3><p>上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。</p>\n<p><strong>现代 JavaScript 与 Babel</strong></p>\n<p>Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。</p>\n<p>如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。</p>\n<p><strong>Webpack</strong></p>\n<p>Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。</p>\n<p>虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。</p>\n<p><strong>TypeScript 与 Flow</strong></p>\n<p>Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。</p>\n<p>这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。</p>\n<p>Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。</p>\n</li>\n<li><h3 id=\"Vue-生态系统\"><a href=\"#Vue-生态系统\" class=\"headerlink\" title=\"Vue 生态系统\"></a>Vue 生态系统</h3><p><strong>官方核心插件</strong></p>\n<p>上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。</p>\n<p><strong>官方工具</strong></p>\n<p>上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。</p>\n<p><strong>UI 组件库</strong></p>\n<p>也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。</p>\n<p>市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。</p>\n</li>\n<li><h3 id=\"深入理解-Vue\"><a href=\"#深入理解-Vue\" class=\"headerlink\" title=\"深入理解 Vue\"></a>深入理解 Vue</h3><p><strong>为什么是渐进式框架</strong></p>\n<p><em>框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》</em></p>\n<p>当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。</p>\n<p>但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。</p>\n<p>React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。</p>\n<p>Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。</p>\n<p>Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。</p>\n<p><strong>声明式渲染</strong></p>\n<p>Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。</p>\n<p>那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。</p>\n<p>虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。</p>\n<p>Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。</p>\n<p>当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。</p>\n<p>不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。</p>\n<p><strong>状态管理</strong></p>\n<p>状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c\" alt=\"state-单向数据流.png\"></p>\n<p>在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。</p>\n<p>它将组件的共享状态抽离出来，放入 Store，组件通过调度（<code>dispatch</code>）使用 Action，Action 通过提交（<code>commit</code>）Mutation 修改 State，然后响应到组件。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d\" alt=\"vuex.png\"></p>\n</li>\n<li><h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><strong>生命周期</strong></p>\n<p><img src=\"https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4\" alt=\"lifecycle.png\"></p>\n<p><strong>Virtual DOM</strong></p>\n<p>Virtual DOM 在 Vue 中的实现。</p>\n<p><strong>响应式数据原理</strong></p>\n<p>在 Vue2，使用的是 ES5 的 <code>Object.defineProperty</code> 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。</p>\n<p>在即将到来的 Vue3 中，会使用 <code>Proxy</code> 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。</p>\n<p><strong>编译与渲染函数</strong></p>\n<p>在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。</p>\n<p><strong>组件化</strong></p>\n<p>每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。</p>\n<p><strong>v-model</strong></p>\n<p>Vue 提供了 <code>v-model</code> 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"sth\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"sth\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"sth = $event.target.value\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>核心插件</strong></p>\n<p>Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。</p>\n<p>Vuex：初始化过程，如何管理全局状态等。</p>\n</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><img src=\"https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6\" alt=\"Vue 学习路线.png\"></p>\n<h2 id=\"相关学习资料\"><a href=\"#相关学习资料\" class=\"headerlink\" title=\"相关学习资料\"></a>相关学习资料</h2><p><a href=\"https://www.infoq.cn/article/vue-2-progressive-front-end-solution\" target=\"_blank\" rel=\"noopener\">《Vue 2.0——渐进式前端解决方案》</a> 尤雨溪</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">《Vue Guide》</a> Vue 官方团队</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/\" target=\"_blank\" rel=\"noopener\">《Vue.js 技术揭秘》</a> ustbhuangyi</p>\n<p><a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">《Vuex》</a> Vuex</p>\n<p><a href=\"https://vue.w3ctech.com/\" target=\"_blank\" rel=\"noopener\">VueConf</a> VueConf</p>\n<p><a href=\"https://vuejsdevelopers.com/\" target=\"_blank\" rel=\"noopener\">Vue.js developers</a> vuejsdevelopers.com</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.infoq.cn/article/9XymmTqu*4QwahqikMka\" target=\"_blank\" rel=\"noopener\">《2019 年 Vue 学习路线图》</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文旨在规划 Vue 框架的学习路线，通过掌握基本概念了解框架，熟悉生态系统，最后深入至框架本身。并未涉及到框架使用方式等详细内容，对每个知识点也只是浅尝即止。</p>","more":"<h2 id=\"为什么选择vue\"><a href=\"#为什么选择vue\" class=\"headerlink\" title=\"为什么选择vue\"></a>为什么选择vue</h2><p>可能有很多人只是知道 Vue 这个框架，并没有详细的了解，所以在这里简单的列举下 Vue 的优势。</p>\n<ul>\n<li>Vue 有着前端框架中最多的 stars，人数众多的开发者，保证了社区的繁荣。</li>\n<li><p>相对来说较平滑的学习曲线，这主要取决于vue是一个渐进式框架，同时使用基础的HTML模版语法，这让有HTML经验的人很少上手。</p>\n</li>\n<li><p>渐进式框架也可以更好的逐步的改变原有项目。</p>\n</li>\n<li>团队中有来自世界各地的专家开发者，中文社区和文档质量相对不错。</li>\n</ul>\n<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><ol>\n<li><h3 id=\"JavaScript与web基础\"><a href=\"#JavaScript与web基础\" class=\"headerlink\" title=\"JavaScript与web基础\"></a>JavaScript与web基础</h3><p>学习 Vue 框架之前必须先了解 JavaScript 与 web 开发的基本知识，就像看一本英语书前，你需要先掌握英文。</p>\n</li>\n<li><h3 id=\"Vue-基本概念\"><a href=\"#Vue-基本概念\" class=\"headerlink\" title=\"Vue 基本概念\"></a>Vue 基本概念</h3><p>使用 Vue 来构建项目，需要先了解一些基本概念：</p>\n<p><strong>渐进式框架</strong></p>\n<p>渐进式就是：一步一步，不需要在一开始就把所有的东西都用上。</p>\n<p>在 Vue 上的体现就是：它的核心库只包含视图，其他的客户端路由、全局状态管理等通过核心插件提供。</p>\n<p>Vue 在设计角度上，包含了解决构建大型单页面应用的大部分问题，但你不需要一开始就把所有的东西都用上。这就带来了较平滑的学习曲线与对老项目渐进式重构的好处。</p>\n<p><strong>声明式渲染</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123; message &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里的示例代码就是声明式渲染，你写出想要的结果，由框架执行渲染的命令。</p>\n<p><strong>响应式数据</strong></p>\n<p>在上面的示例代码中，数据就与 DOM 建立了关联，成为响应式数据。此时改变 <code>app.message</code> 的值，就可以看到页面也会发生对应改变。</p>\n<p><strong>组件化</strong></p>\n<p>组件化的核心思想就是：将页面结构映射为组件树。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4555f25f3e509ed94b6480\" alt=\"component-tree.png\"></p>\n<p>组件是资源独立的，组件可以复用，组件与组件之间可以嵌套。</p>\n<p><strong>单页面应用与客户端路由</strong></p>\n<p>单页面应用（SPA）可以通过单个页面实现传统网站多个页面的功能，通过客户端路由实现加载新内容，而不需要通过浏览器跳转，重新加载页面。</p>\n<p>Vue Router 就是 Vue 的实现，由官方维护，通过插件的形式加载。</p>\n<p><strong>状态管理</strong></p>\n<p>在 Vue 中，每个组件管理着自己的状态，如果有状态需要在多个组件间复用，就需要把共享的状态抽离出来，作为全局的状态来管理，这样，在任何组件中都能获取到。</p>\n<p>这就是 Vuex 所做的事情。</p>\n</li>\n<li><h3 id=\"使用-Vue-构建单页面应用\"><a href=\"#使用-Vue-构建单页面应用\" class=\"headerlink\" title=\"使用 Vue 构建单页面应用\"></a>使用 Vue 构建单页面应用</h3><p>以上的基本概念用于理解 Vue，如果要将它实际应用到项目中，还需要了解更多的东西。</p>\n<p><strong>构建工具</strong></p>\n<p>Vue 提供了一个官方的 CLI：Vue CLI，为单页面应用搭建繁杂的脚手架。</p>\n<p>最新的版本 Vue CLI3中加入了 GUI 的支持，对用户更为友好。</p>\n<p><strong>使用 axios 访问 Web API</strong></p>\n<p>Vue 的一个核心思想就是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，Vue 将数据与 DOM 关联，构建响应式数据，我们对视图的修改，不会直接修改 DOM，而是修改数据，响应至视图。</p>\n<p>作为一个单页面应用，数据需要通过 Web API 获取，这些数据可能通过 RESTful API 或 GraphQL 提供，也可能通过 WebSocket 提供。</p>\n<p>如果是使用的 HTTP 协议，在 Vue Cookbook 中，推荐使用基于 promise 的 axios。</p>\n<p><strong>测试</strong></p>\n<p>如果想要开发出稳定可维护的项目，测试是必不可少的。</p>\n<p>Vue 官方团队提供了 Vue Test Utils，Vue Test Utils 通过将组件隔离挂载，然后模拟必要的输入和对输出的断言来测试。</p>\n<p><strong>Chrome 开发者工具</strong></p>\n<p>Vue.js devtools 是一个用于 Chrome 的开发者工具，使用它可以清楚的看到组件树的结构，组件的状态等信息。如果使用了 Vuex，还可以看到全局状态，并将其快照发送给其他人，这个人可以在控制台导入状态，方便定位问题。</p>\n<p><strong>多端支持</strong></p>\n<p>可以在 Weex 中使用 Vue，Vue 的官方也与 Weex 的团队加深联系，在未来的 Vue3 中，会有更好的支持。</p>\n</li>\n<li><h3 id=\"前端技术栈\"><a href=\"#前端技术栈\" class=\"headerlink\" title=\"前端技术栈\"></a>前端技术栈</h3><p>上述所讲的大多是 Vue 或 Vue 生态系统中的工具。但 Vue 并不是独立存在的，它知识前端技术栈中的一部分。</p>\n<p><strong>现代 JavaScript 与 Babel</strong></p>\n<p>Vue 应用程序可以使用 ES5 开发，这是现代浏览器都支持的 JavaScript 标准。</p>\n<p>如果想要获得更好的开发体验，可以更新 JavaScript 标准 ES2015 或更高版本，但这会导致不支持旧版浏览器，为了解决这个问题，就需要使用 Babel，它可以将你的新语法编译为 ES5 代码。</p>\n<p><strong>Webpack</strong></p>\n<p>Webpack 是一个模块打包器，它可以将你的应用程序中各个模块的代码打包至一个或多个文件中，形成浏览器可读的 js 文件。还可以在打包过程中，对代码进行转换、使用 Babel、Sass、TypeScript 等。</p>\n<p>虽然 Vue CLI 可以为我们构建基础的 webpack 配置，并且在新版本中，可以使用 GUI 来调整，但这并不意味着你可以不学习它，你还是不可避免的需要自行调试它的配置。</p>\n<p><strong>TypeScript 与 Flow</strong></p>\n<p>Vue2 版本中使用的是 Flow，在 Vue3 中将重构为使用 TypeScript。</p>\n<p>这两门语言的主要目的是让 js 拥有类型系统，使用它们可以写出高健壮性的代码，并且可以编译为普通的 ES 语法。</p>\n<p>Vue3 将完全使用 TypeScript 编写，这并不意味着你必须使用它。但是如果想要了解 Vue 源码，也是不可避免的。</p>\n</li>\n<li><h3 id=\"Vue-生态系统\"><a href=\"#Vue-生态系统\" class=\"headerlink\" title=\"Vue 生态系统\"></a>Vue 生态系统</h3><p><strong>官方核心插件</strong></p>\n<p>上述提到的 Vue Router、Vuex，还有 Vue SSR 都是由官方维护的，这区别于 React，官方主要是考虑到了社区维护会导致更新频繁、解决方案太杂乱的问题。</p>\n<p><strong>官方工具</strong></p>\n<p>上述也提到过的 Vue devtools、Vue CLI，还有 Vue Loader，也都是基于同样的原因。但这不意味着没有社区参与，作为开源项目，依然可以提出建议，修复问题，只是官方有一个发展方向作为参考。</p>\n<p><strong>UI 组件库</strong></p>\n<p>也可以称为 UI 框架，主要是一系列常用的组件，例如 Form、Table 等常见的元素，方便快速开发。</p>\n<p>市面上有非常多的 UI 框架可供选择，Element UI、iView、Vux 等，各有各的风格特色。</p>\n</li>\n<li><h3 id=\"深入理解-Vue\"><a href=\"#深入理解-Vue\" class=\"headerlink\" title=\"深入理解 Vue\"></a>深入理解 Vue</h3><p><strong>为什么是渐进式框架</strong></p>\n<p><em>框架的存在是为了帮助我们应对复杂度 - 《Vue 2.0——渐进式前端解决方案》</em></p>\n<p>当我们在做一个前端应用时，会遇许多的问题，这些问题可以称为应用复杂度，前端框架的出现，就是为了降低应用复杂度，解决一些重复的并且已经有良好解决方案的问题。</p>\n<p>但是，框架本身由于其学习曲线，也会带来不同的复杂度，称为框架复杂度。如何权衡应用复杂度与框架复杂度就称为了一个问题。</p>\n<p>React 与 Vue 的选择的模式就是：以可弹性伸缩的框架复杂度来应对不同的应用复杂度。框架核心库只包含视图层，其他的问题都由可选的附加库/工具来解决。</p>\n<p>Facebook 团队只专注做 React 本身，其他的问题都是由社区贡献解决方案，社区非常活跃，也有很多优秀的想法和思路，但社区的活跃性也会带来一些副作用，版本更新太快，一个问题有太多的解决方案导致的选择困难，库与库之间可能存在的磨合问题。</p>\n<p>Vue 的团队选择的方向就是渐进式，核心插件\\工具由团队开发，负责一些大方向上的统一，同时也是模块化的，可供选择。</p>\n<p><strong>声明式渲染</strong></p>\n<p>Vue 或者说现代 js 框架，都有一个统一的看法，数据状态是唯一的真相，DOM 状态只是数据状态的映射。所有的逻辑操作都应在状态的层面进行，当状态发生改变时，DOM 在框架的帮助下自动更新至合理的状态。</p>\n<p>那么，Vue 时如何实现的呢？主要是使用的虚拟（Virtual） DOM。</p>\n<p>虚拟 DOM 简单来说就是使用 js 对象去描述一个 DOM 节点，它产生的前提就是一个 DOM 元素在浏览器中是非常庞大的，因为有着各种属性，各种事件，浏览器的标准就是这么设计的。相比于 DOM 对象，原生的 js 对象处理起来更快，而且更简单。</p>\n<p>Vue 将它所有要监听的 DOM 映射为一个虚拟 DOM 树，这个树非常的轻量，它的职责就是描述当前页面的 DOM 状态。</p>\n<p>当数据状态发生改变时，Vue 的响应系统会侦测到变化，并生成一个新的虚拟 DOM 树，通过与上一个虚拟 DOM 树进行比较，将改动应用至真实 DOM 状态。</p>\n<p>不同于 React 的是，Vue 可以使用 HTML 模版，也可以是用 JSX，这是 Vue 在编译时将模版编译为渲染函数。</p>\n<p><strong>状态管理</strong></p>\n<p>状态管理本质上就是把整个应用抽象为下图中的循环，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使 State 产生变化，从而导致 View 重新渲染，这就是单向数据流。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554ae5f3e509ed94b5b8c\" alt=\"state-单向数据流.png\"></p>\n<p>在 Vue 中，一个组件就已经是这样的结构了，在多个组件共享状态时，或是来自不同视图的行为变更一个状态时，应该如何管理呢？此问题的答案就是 Vuex。</p>\n<p>它将组件的共享状态抽离出来，放入 Store，组件通过调度（<code>dispatch</code>）使用 Action，Action 通过提交（<code>commit</code>）Mutation 修改 State，然后响应到组件。</p>\n<p><img src=\"https://www.superbed.cn/pic/5c4554c75f3e509ed94b5c5d\" alt=\"vuex.png\"></p>\n</li>\n<li><h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><strong>生命周期</strong></p>\n<p><img src=\"https://www.superbed.cn/pic/5c45553b5f3e509ed94b5ec4\" alt=\"lifecycle.png\"></p>\n<p><strong>Virtual DOM</strong></p>\n<p>Virtual DOM 在 Vue 中的实现。</p>\n<p><strong>响应式数据原理</strong></p>\n<p>在 Vue2，使用的是 ES5 的 <code>Object.defineProperty</code> 来构成数据监听系统，这也是 Vue2 不能兼容 IE8 及以下的原因。</p>\n<p>在即将到来的 Vue3 中，会使用 <code>Proxy</code> 进行重构数据监听系统，这会导致 Vue3 不能兼容 IE11 及一下，Vue 团队会提出其他的办法来解决这个问题。</p>\n<p><strong>编译与渲染函数</strong></p>\n<p>在 Vue 中，会将模版编译为渲染函数，在 Vue3 中，也做出了相当的优化。</p>\n<p><strong>组件化</strong></p>\n<p>每一个组件就是一个 Vue 实例，组件内部是如何工作的，组件间的嵌套等实现。</p>\n<p><strong>v-model</strong></p>\n<p>Vue 提供了 <code>v-model</code> 的指令，用于实现表单与数据状态之间的双向绑定，这也没有破坏单向数据流，只是语法糖。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"sth\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"sth\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"sth = $event.target.value\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>核心插件</strong></p>\n<p>Vue Router：客户端路由中存在的种种问题，嵌套路由、重定向/别名、懒加载等。</p>\n<p>Vuex：初始化过程，如何管理全局状态等。</p>\n</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><img src=\"https://www.superbed.cn/pic/5c4554da5f3e509ed94b5cd6\" alt=\"Vue 学习路线.png\"></p>\n<h2 id=\"相关学习资料\"><a href=\"#相关学习资料\" class=\"headerlink\" title=\"相关学习资料\"></a>相关学习资料</h2><p><a href=\"https://www.infoq.cn/article/vue-2-progressive-front-end-solution\" target=\"_blank\" rel=\"noopener\">《Vue 2.0——渐进式前端解决方案》</a> 尤雨溪</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">《Vue Guide》</a> Vue 官方团队</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/\" target=\"_blank\" rel=\"noopener\">《Vue.js 技术揭秘》</a> ustbhuangyi</p>\n<p><a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">《Vuex》</a> Vuex</p>\n<p><a href=\"https://vue.w3ctech.com/\" target=\"_blank\" rel=\"noopener\">VueConf</a> VueConf</p>\n<p><a href=\"https://vuejsdevelopers.com/\" target=\"_blank\" rel=\"noopener\">Vue.js developers</a> vuejsdevelopers.com</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.infoq.cn/article/9XymmTqu*4QwahqikMka\" target=\"_blank\" rel=\"noopener\">《2019 年 Vue 学习路线图》</a></p>"},{"title":"JWT 与 OAuth 2.0","date":"2016-09-01T13:30:18.000Z","_content":"**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","source":"_posts/JWT-and-OAuth2.0.md","raw":"---\ntitle: JWT 与 OAuth 2.0\ndate: 2016/9/1 21:30:18\n---\n**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","slug":"JWT-and-OAuth2.0","published":1,"updated":"2019-10-21T08:57:28.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck35g29ca000eyz79hjx7mcpf","content":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>\n<a id=\"more\"></a>  \n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>\n","site":{"data":{}},"excerpt":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}