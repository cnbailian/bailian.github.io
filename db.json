{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","path":"static/css/style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","path":"static/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","path":"static/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","path":"static/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","path":"static/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","path":"static/images/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","path":"static/images/favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.jpg","path":"static/images/gravatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","path":"static/js/meizi.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-meizi/.gitignore","hash":"18e4e4fd0bb2c3c41b65b92434b866bd9795c337","modified":1508465606777},{"_id":"themes/hexo-theme-meizi/README.md","hash":"024a49acbe3e7cbf4e94d2c2bde2229b1c6f8327","modified":1508465606782},{"_id":"themes/hexo-theme-meizi/_config.yml","hash":"83c0c87e4f52e51f3052576e364e93b0300b349f","modified":1508467322137},{"_id":"themes/hexo-theme-meizi/bower.json","hash":"0fed4bb836114730ea6260ba57ecbd6cd49bfb1e","modified":1508465606795},{"_id":"themes/hexo-theme-meizi/gulpfile.js","hash":"3a5345f1d1ea7b6de18851dd51816e9ed15744a7","modified":1508465606807},{"_id":"themes/hexo-theme-meizi/package.json","hash":"b8ea63cdd52aaedf157d0bb0cae7252b87ccc260","modified":1508465607309},{"_id":"source/_posts/Api安全研究.md","hash":"bd4241e8380a1b49baac8d41981852199d61987f","modified":1508464802939},{"_id":"source/_posts/Chrome扩展 -- Box.dat","hash":"17e65ede36d76fa16e38b9f8aa66fd21e5759a01","modified":1508464802946},{"_id":"source/_posts/JWT 与 OAuth 2.0.md","hash":"22331ccad6b74cdbf9b3c004f99eca22efa38927","modified":1508464802952},{"_id":"source/_posts/RESTful API 实践.md","hash":"09a2d0592fc04e5ba74fea5da5cac78b3a76736d","modified":1508464803002},{"_id":"source/_posts/RESTful 设计大纲.dat","hash":"53d99a05cb46ce6f4db84d39796291b2ad8f3bc1","modified":1508464803015},{"_id":"source/_posts/RESTful缓存方案.md","hash":"59fa2957ebe68acfeb1f83fac1a719826051233b","modified":1508464803021},{"_id":"source/_posts/chromeBox 大纲.dat","hash":"26d44ea5427717e9a087f0fb0e1c761b9ce8ce9a","modified":1508464803029},{"_id":"source/_posts/tpshop代码审计--续.dat","hash":"217b8d1d2c727f3833783dd909e8e9d15745292c","modified":1508464803037},{"_id":"source/_posts/tpshop代码审计.dat","hash":"947743019b73981dad743903d7533895809bd207","modified":1508464803049},{"_id":"source/about/index.md","hash":"d1d790b6b612448a78961049bbe6f65805113c26","modified":1508467123119},{"_id":"source/archive/index.md","hash":"5f8fde1852fa5ca6f090885b142b749a99f444d8","modified":1508464803063},{"_id":"source/links/index.md","hash":"08289172ad8475701d899907240604fb3337128f","modified":1508464803073},{"_id":"source/tags/index.md","hash":"4e329cd95121976f17f4eba64efbb8e77a0b2afb","modified":1508464803080},{"_id":"themes/hexo-theme-meizi/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1508465606734},{"_id":"themes/hexo-theme-meizi/.git/config","hash":"1c5d5c19a26ebf5e252382d87d71de061d3cf149","modified":1508465606759},{"_id":"themes/hexo-theme-meizi/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1508465592387},{"_id":"themes/hexo-theme-meizi/.git/index","hash":"771890fec2f83b409952674d16c170a73accb1a2","modified":1508465607656},{"_id":"themes/hexo-theme-meizi/.git/packed-refs","hash":"f1912cd5fdf10c595f5c0416d8d347c60054903a","modified":1508465606715},{"_id":"themes/hexo-theme-meizi/languages/zh-cn.yml","hash":"7edfe87917251dbed57f21ac7effcee91affddae","modified":1508465606812},{"_id":"themes/hexo-theme-meizi/layout/about.ejs","hash":"4323c21b553780269f2cac5d6e5a8f33d6243290","modified":1508465607278},{"_id":"themes/hexo-theme-meizi/layout/all-archives.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1508465607283},{"_id":"themes/hexo-theme-meizi/layout/index.ejs","hash":"b0d62a2f93de7917e67556f30dee33214d9b7d74","modified":1508465607288},{"_id":"themes/hexo-theme-meizi/layout/links.ejs","hash":"1514d633dae3c5c5a76344afeaa0fbdf154c025c","modified":1508465607293},{"_id":"themes/hexo-theme-meizi/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1508465607298},{"_id":"themes/hexo-theme-meizi/layout/tags.ejs","hash":"17a1f47a1b54624645fcb182d4e275512e918386","modified":1508465607302},{"_id":"themes/hexo-theme-meizi/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1508465592395},{"_id":"themes/hexo-theme-meizi/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1508465592402},{"_id":"themes/hexo-theme-meizi/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1508465592407},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1508465592412},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1508465592419},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1508465592427},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1508465592438},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1508465592446},{"_id":"themes/hexo-theme-meizi/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1508465592452},{"_id":"themes/hexo-theme-meizi/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1508465592465},{"_id":"themes/hexo-theme-meizi/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1508465592472},{"_id":"themes/hexo-theme-meizi/.git/logs/HEAD","hash":"8724a7a6cb7791419e476b2fe47dccdc2215942b","modified":1508465606742},{"_id":"themes/hexo-theme-meizi/layout/_partial/about.ejs","hash":"ae4b861b5d4610eed0b453d99440d3119791434f","modified":1508465606821},{"_id":"themes/hexo-theme-meizi/layout/_partial/archive.ejs","hash":"a6cd881011727880f7b371efb86ac6c4592508db","modified":1508465606866},{"_id":"themes/hexo-theme-meizi/layout/_partial/index.ejs","hash":"a657c09b2b5ea4fa9fd7ac6a8f1da1d171d75b8c","modified":1508465607221},{"_id":"themes/hexo-theme-meizi/layout/_partial/links.ejs","hash":"b9e430cbbd4728d661973fcef30acb8070e3d0ad","modified":1508465607227},{"_id":"themes/hexo-theme-meizi/layout/_partial/post.ejs","hash":"0f238c473949bf11b794123b6b6759baf3937739","modified":1508465607262},{"_id":"themes/hexo-theme-meizi/layout/_partial/tags.ejs","hash":"4677915a4974524cce69490e09a5947790b1507b","modified":1508465607272},{"_id":"themes/hexo-theme-meizi/scripts/helpers/func.js","hash":"fc4eada12e5996566d08ea675858c76526c5176c","modified":1508465607320},{"_id":"themes/hexo-theme-meizi/source/_css/style.scss","hash":"25c4d7785f2083c90788618c25eec6b4e5673c96","modified":1508465607442},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1508465607460},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.svg","hash":"df0cb1217b5ab78a70fd3d1ffde1c8fb4a29fad1","modified":1508465607470},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1508465607481},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1508465607491},{"_id":"themes/hexo-theme-meizi/source/_images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1508465607497},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1508466362149},{"_id":"themes/hexo-theme-meizi/source/_images/gravatar.jpg","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1508466362149},{"_id":"themes/hexo-theme-meizi/source/_js/meizi.js","hash":"391b8f4e36e95399ca37a78dca11c906c952e577","modified":1508465607543},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.idx","hash":"ddc8d023560997562e71b97d44a538fb0ed1e1f5","modified":1508465606501},{"_id":"themes/hexo-theme-meizi/.git/refs/heads/master","hash":"9e0459116ecb93cf28843d634c4f246e721004fd","modified":1508465606741},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/disqus.ejs","hash":"e2a51f20a797b507347c9f49c4bfee652e369c54","modified":1508465606871},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/duoshuo.ejs","hash":"4e5e379b03e88ddd3dced3bb2e9cfe6223130c56","modified":1508465606876},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/footer.ejs","hash":"fa6d3667d0bebd00475fd67c1426cd30c80e8ed3","modified":1508465606881},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/head.ejs","hash":"d892e07d09f5488b49c6249fff3b0a998d7ac3f2","modified":1508465606925},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/header.ejs","hash":"9c4c7c566eae6d9559a692dfaea02eedc157a821","modified":1508465606950},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/pagination.ejs","hash":"d0a99a1dee30216fc1fbaf1f81825f016ac2c381","modified":1508465606957},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/scripts.ejs","hash":"7d56639f0145866791647f16dcd481b88d7d6bc5","modified":1508465607036},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/sidebar.ejs","hash":"a0430320dc446d1a9ef1a43ebb38e0a21156aafe","modified":1508465607171},{"_id":"themes/hexo-theme-meizi/source/_css/include/_core.scss","hash":"db73f16512ef3107a885798b962f260d5f2b2beb","modified":1508465607328},{"_id":"themes/hexo-theme-meizi/source/_css/include/_header.scss","hash":"913588a2b15332552f8d8a047caf8b349d68051f","modified":1508465607334},{"_id":"themes/hexo-theme-meizi/source/_css/include/_iconfont.scss","hash":"d4c7cd917bcdcb1d35b3addd7e26c07bbf53ebea","modified":1508465607346},{"_id":"themes/hexo-theme-meizi/source/_css/include/_layout.scss","hash":"333c034f4aa63baba704660659b770499cc58e93","modified":1508465607393},{"_id":"themes/hexo-theme-meizi/source/_css/include/_main.scss","hash":"c1905357a5841460e8a932ba634dba4cc07ac46e","modified":1508465607398},{"_id":"themes/hexo-theme-meizi/source/_css/include/_markdown.scss","hash":"b632e48c9eaed6c4137d343490f92d11f80a9e3d","modified":1508465607407},{"_id":"themes/hexo-theme-meizi/source/_css/include/_sidebar.scss","hash":"b177f96ee20c5a46ac95fe6d1a29b87eedb517d0","modified":1508465607414},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_query.scss","hash":"79512a2612a108519b9fe10a4acdee5adbf90c2c","modified":1508465607426},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_variables.scss","hash":"6d4484a20645b6ac96fcaa121e0bc94b7f03f179","modified":1508465607431},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1508465607562},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1508465607582},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","hash":"df0cb1217b5ab78a70fd3d1ffde1c8fb4a29fad1","modified":1508465607590},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1508465607596},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1508465607598},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1508465607604},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1508466362149},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.jpg","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1508466362149},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1508465607647},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/heads/master","hash":"8724a7a6cb7791419e476b2fe47dccdc2215942b","modified":1508465606745},{"_id":"themes/hexo-theme-meizi/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1508465606731},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/remotes/origin/HEAD","hash":"8724a7a6cb7791419e476b2fe47dccdc2215942b","modified":1508465606725},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.pack","hash":"deb8601f46513acdf5c099767f143977c23340d2","modified":1508465606602},{"_id":"public/atom.xml","hash":"5951f303083a113fce87c97063c7e7fcab8fce3d","modified":1508467374614},{"_id":"public/about/index.html","hash":"6b0410365a0a2651aab8823b3128c98e5476dd25","modified":1508467374619},{"_id":"public/archive/index.html","hash":"e78bffebfef1b6792614280a496a58edcccf57d8","modified":1508467374619},{"_id":"public/links/index.html","hash":"4aaa717fdda608f7014801f32551bb170def7b0a","modified":1508467374619},{"_id":"public/tags/index.html","hash":"003f3736599978b59dcab4d078e528f92cda99b3","modified":1508467374619},{"_id":"public/2017/10/RESTful缓存方案/index.html","hash":"fa9ec5fefa3799701e079e5360d977ed0b0a1efd","modified":1508467374619},{"_id":"public/2017/10/JWT 与 OAuth 2.0/index.html","hash":"af924bd4db67f130ee45d52bac905cd184bd7c72","modified":1508467374619},{"_id":"public/2017/10/Api安全研究/index.html","hash":"04cbda2900d68aa3ed0c60aa2d6eea4572326dea","modified":1508467374620},{"_id":"public/archives/index.html","hash":"b4f25cbc5724b76b17cfa657081d2ca1d430942f","modified":1508467374620},{"_id":"public/archives/2017/index.html","hash":"b4f25cbc5724b76b17cfa657081d2ca1d430942f","modified":1508467374620},{"_id":"public/archives/2017/10/index.html","hash":"b4f25cbc5724b76b17cfa657081d2ca1d430942f","modified":1508467374620},{"_id":"public/index.html","hash":"b4f25cbc5724b76b17cfa657081d2ca1d430942f","modified":1508467374620},{"_id":"public/2017/10/RESTful API 实践/index.html","hash":"b635c89a6396d63021dbf45464d0805f5ff92f64","modified":1508467374620},{"_id":"public/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1508467374627},{"_id":"public/static/fonts/iconfont.svg","hash":"df0cb1217b5ab78a70fd3d1ffde1c8fb4a29fad1","modified":1508467374627},{"_id":"public/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1508467374628},{"_id":"public/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1508467374628},{"_id":"public/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1508467374628},{"_id":"public/static/images/favicon.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1508467374628},{"_id":"public/static/images/gravatar.jpg","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1508467374628},{"_id":"public/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1508467374636},{"_id":"public/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1508467374636}],"Category":[],"Data":[],"Page":[{"title":"关于我","layout":"about","_content":"\n<!-- 这里写你的简介 -->\n\n普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程\n\n代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客   \n\n博客用的Hexo + gihub,主题是https://github.com/imochen/hexo-theme-meizi\n\n本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。\n\n最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。\n","source":"about/index.md","raw":"title: \"关于我\"\nlayout: \"about\"\n---\n\n<!-- 这里写你的简介 -->\n\n普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程\n\n代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客   \n\n博客用的Hexo + gihub,主题是https://github.com/imochen/hexo-theme-meizi\n\n本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。\n\n最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。\n","date":"2017-10-20T02:38:43.119Z","updated":"2017-10-20T02:38:43.119Z","path":"about/index.html","comments":1,"_id":"cj8zaiz660001o8qu054l2p54","content":"<!-- 这里写你的简介 -->\n<p>普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程</p>\n<p>代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客   </p>\n<p>博客用的Hexo + gihub,主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\" target=\"_blank\" rel=\"external\">https://github.com/imochen/hexo-theme-meizi</a></p>\n<p>本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。</p>\n<p>最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。</p>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的简介 -->\n<p>普通程序员，从事PHP开发。试图开启全栈技能树和接触各种语言(python ruby golang等)。面向google编程</p>\n<p>代码外的生活逃不出游戏/音乐/书籍(大部分为小说)，现在又加上了写博客   </p>\n<p>博客用的Hexo + gihub,主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\" target=\"_blank\" rel=\"external\">https://github.com/imochen/hexo-theme-meizi</a></p>\n<p>本来都要弃坑了，毕竟不善于写作，但是临到找工作又捡回来了，毕竟总得有个让人了解自己的地方。</p>\n<p>最近一年沉迷于 API 开发无法自拔，在这其中，学习 REST、HTTP、使用GO开发网关等，当然也希望能找到相关的工作。</p>\n"},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"title: \"归档\"\nlayout: \"all-archives\"\n---","date":"2017-10-20T02:00:03.063Z","updated":"2017-10-20T02:00:03.063Z","path":"archive/index.html","comments":1,"_id":"cj8zaiz6h0005o8qufpadt6vz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"友情链接","layout":"links","_content":"\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","source":"links/index.md","raw":"title: \"友情链接\"\nlayout: \"links\"\n---\n\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","date":"2017-10-20T02:00:03.073Z","updated":"2017-10-20T02:00:03.073Z","path":"links/index.html","comments":1,"_id":"cj8zaiz6i0006o8qu9u1ca2qx","content":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"external\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"external\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---","date":"2017-10-20T02:00:03.080Z","updated":"2017-10-20T02:00:03.080Z","path":"tags/index.html","comments":1,"_id":"cj8zaiz6j0007o8quuz17x8oz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Api安全 研究","_content":"\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","source":"_posts/Api安全研究.md","raw":"---\ntitle: Api安全 研究\n---\n\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","slug":"Api安全研究","published":1,"date":"2017-10-20T02:00:02.932Z","updated":"2017-10-20T02:00:02.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8zaiz600000o8qulod4jbzf","content":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>\n<a id=\"more\"></a>  \n<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>","more":"<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>"},{"title":"RESTful API 实践","_content":"\n## 理解 REST 与 RESTful\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ... \n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求) \n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在 \n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)","source":"_posts/RESTful API 实践.md","raw":"---\ntitle: RESTful API 实践\n---\n\n## 理解 REST 与 RESTful\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful。\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容，资源就是\"Representational State Transfer\"这个词组中被省略的主语。\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)。\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源。\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性)，可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)。\n\n### SSL/TLS\n\n条件允许的情况下，永远使用SSL/TLS!\n\n好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。\n\n### 文档\n\n文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。\n\n这里推荐使用Postman，很好用的调试RESTful API的chrome应用。\n\n### 版本号\n\nAPI不会是永远稳定的，版本升级的问题无法避免。\n\n版本号只允许枚举，不允许区间。\n\n关于API的版本号问题，有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些。\n2. 放入Header 信息中.URL更加优雅，api.github.com采用此方法。\n\n### 信息过滤\n\n包括 筛选、排序、分页等。\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户。\n\n为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户。\n\n*如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。*\n\n**限制返回字段**\n\n`?fields=id，name`\n\n**排序**\n\n两种解决方案，第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种，使用 `-` 表示倒序，使用 `，` 分隔多个排序:\n\n```\n?sort=-type，created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种，第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页，需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页。\n2. 会出现重复数据问题。\n3. 当`offset`数值较大时，效率降低明显。\n4. 分页不涉及排序。\n\n我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。\n\n*在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。*\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :\n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\"，\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一，也看了在API中的用处[[5]](#HATEOAS)，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主体为 `json` 格式数据\n关于优缺点不多做描述， QuQu大神 讲解的很详细了[[6]](#JSON格式输入)。\n\n### 相关资源嵌入\n\nAPI在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入。\n\n```\n?embed=department.name，job\n```\n\n使用 `.` 表示相关字段， 使用 `，` 分割资源列表。\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1，\n\t\"name\" : \"user\"，\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t}，\n\t\"job\" : {\n\t\t\"id\" : 1，\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制。\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)。\n\n这里主要说的是 RESTful API 在这方面做出的处理:\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误。\n\n同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)。\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)。\n\n### 权限\n\nREST的重要原则之一就是无状态，所以不应该使用 `cookie` & `session` ， 而是使用 凭证 来进行权限认证。\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0)，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)。\n\n我的总结: 语义不同。\n\n`sessionID` 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。\n\n而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`。\n\n这里有一片讲解 `ETag` 的文章， 非常详细[[12]](#Etag详解)。\n\n`Last-Modified` 基本与 `ETag` 相同，只是判断依据从 `ETag` 变为时间。\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可，不要返回 `code = 0` 这样的无用信息。\n\n错误时返回具体的错误信息:\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时，返回业务逻辑错误码:\n\n```json\n{\n\t'code' : 10010，\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义`HTTP status code` 。*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 `JSONP`)。\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200，\n\tnext_page: \"https://..\"，\n\tresponse: {\n\t\t... 正常的 JSON 实体 ... \n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容。\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功，并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功，但没有内容返回 (例如 `DELET` 请求) \n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据，但权限不足\n\n - `404 Not Found` - 请求的资源不存在 \n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。\n\n*如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。*\n\n### 实践出真知\n\n在上面常见的HTTP动词中，我没有提到 `PATCH`， 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况，所以，觉得这个方法不是那么主要。\n\n客户端要求不能直接返回数组型的 JSON 数据， 要加上 `KEY` 。有时间可以学一学，做个小APP实践一下。\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读，或拆分。\n\n例如 : `search` 我的理解，  某种服务也是资源。\n\n例如 : `login` 我的理解， 对于一个 API 来说， `login` 的行为在本质上是对 `凭据` 这个资源的创建，而且是幂等的。\n\n**业务逻辑与代码逻辑冲突时，HTTP动词的选择**\n\n跟着业务逻辑走。\n\n例如，业务的删除，在代码里的时间可能是软删除( `deleted_at =1` )，这个时候的HTTP动词一定要是 `DELETE`。\n\n### 写在最后\n\n在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。\n\nAPI的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解，与实践结合而成。\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。\n\n**如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.**\n\n*因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。*\n\n终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好，所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API，可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0， 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），\n并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。\n在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。\n这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，\n它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)","slug":"RESTful API 实践","published":1,"date":"2017-10-20T02:00:02.953Z","updated":"2017-10-20T02:00:03.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8zaiz670002o8quk5c702az","content":"<h2 id=\"理解-REST-与-RESTful\"><a href=\"#理解-REST-与-RESTful\" class=\"headerlink\" title=\"理解 REST 与 RESTful\"></a>理解 REST 与 RESTful</h2><p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>\n<a id=\"more\"></a>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sortby=level&amp;order=asc</div></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sort=-type，created_at</div></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?offset=10 - 偏移量</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</div><div class=\"line\">\t......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?embed=department.name，job</div></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</div><div class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</div><div class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</div><div class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</div></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'message': 'Invalid Token'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'code' : 10010，</div><div class=\"line\">\t'message': 'Insufficient balance'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback_function(&#123;</div><div class=\"line\">\tstatus_code: 200，</div><div class=\"line\">\tnext_page: &quot;https://..&quot;，</div><div class=\"line\">\tresponse: &#123;</div><div class=\"line\">\t\t... 正常的 JSON 实体 ... </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求) </p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在 </p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"external\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"external\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</div><div class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</div><div class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</div><div class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</div><div class=\"line\">它成为了现代 Web 架构的基础。</div><div class=\"line\"></div><div class=\"line\">出自[中文译版] 结论</div></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"external\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"external\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"external\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"external\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"external\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"external\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">HTTP缓存 这里主要是讲的Etag</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"理解-REST-与-RESTful\"><a href=\"#理解-REST-与-RESTful\" class=\"headerlink\" title=\"理解 REST 与 RESTful\"></a>理解 REST 与 RESTful</h2><p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构的基础。<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful。</p>","more":"<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息，会话状态因此要全部保存在客户端。</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试，能够方便的使用web功能测试、性能测试等工具进行测试，web类应用也方便将多个RESTful API进行整合。</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容，资源就是”Representational State Transfer”这个词组中被省略的主语。</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制，HTTP的缓存机制就是个不错的选择。</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性， 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源。</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE。</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候，应使用PUT方法，这个点赞是具有幂等性的，当一个人可以点赞无数次时，应使用POST方法。</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深，二三层即可，过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性)，可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下，永远使用SSL/TLS!</p>\n<p>好处不多说了，再说一点: 不要将HTTP重定向到HTTPS，抛出错误就好，因为第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例，粘贴至浏览器能直接使用。</p>\n<p>这里推荐使用Postman，很好用的调试RESTful API的chrome应用。</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的，版本升级的问题无法避免。</p>\n<p>版本号只允许枚举，不允许区间。</p>\n<p>关于API的版本号问题，有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些。</li>\n<li>放入Header 信息中.URL更加优雅，api.github.com采用此方法。</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等。</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户。</p>\n<p>为了使接口调用者更加方便，可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户。</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任，可以试着查询参数json化，虽然不标准，但是已解决问题为主。</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id，name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案，第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sortby=level&amp;order=asc</div></pre></td></tr></table></figure>\n<p>第二种，使用 <code>-</code> 表示倒序，使用 <code>，</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sort=-type，created_at</div></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种，第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?offset=10 - 偏移量</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>第二种是使用游标分页，需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页。</li>\n<li>会出现重复数据问题。</li>\n<li>当<code>offset</code>数值较大时，效率降低明显。</li>\n<li>分页不涉及排序。</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小，例如想要作为游标的字段有着重复的数据，不能适应负责的排序等.多数情况下，不推荐使用。</p>\n<p><em>在实践中发现 重复数据 的问题有些严重，我的解决方案是增加首次分页的时间作为查询条件，取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示。</em></p>\n<h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)， REST的重要原则之一。</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法，比如，访问 api.github.com :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"current_user_url\"</span>: <span class=\"string\">\"https://api.github.com/user\"</span>，</div><div class=\"line\">\t......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一，也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>，但是在实践中感觉用处不是很大，碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧。</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主体为 <code>json</code> 格式数据<br>关于优缺点不多做描述， QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a>。</p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中，不可避免的要遇到需要加载相关数据的情况，比如说获取一个用户信息的同时获取这个用户相关的部门信息，这个时候让客户端再请求一次部门的接口是不友好的，也不能在用户信息里加入相关部门信息。</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?embed=department.name，job</div></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段， 使用 <code>，</code> 分割资源列表。</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"user\"</span>，</div><div class=\"line\">\t<span class=\"string\">\"department\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\t<span class=\"string\">\"job\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>，</div><div class=\"line\">\t\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议，不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景。</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制。</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a>。</p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理:</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误。</p>\n<p>同时应在响应头中提示用户，命名没有一定的规范，但也要遵守基本法，不要胡乱取名，示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</div><div class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</div><div class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</div></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a>。</p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a>。</p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态，所以不应该使用 <code>cookie</code> &amp; <code>session</code> ， 而是使用 凭证 来进行权限认证。</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>，作为API的权限控制， 对内接口也可使用简化版的 OAuth2.0。</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则， 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)。</p>\n<p>我的总结: 语义不同。</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY，给服务端传递请求的语义为:请帮我取出这个信息，在这里，信息是由服务端进行存储的，所以，毫无疑问这是违反REST无状态原则的。</p>\n<p>而凭据呢，是服务端期待着客户端传过来的用户验证身份的凭据，是由客户端进行存储的，所以是符合REST原则的。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code>。</p>\n<p>这里有一片讲解 <code>ETag</code> 的文章， 非常详细<a href=\"#Etag详解\">[12]</a>。</p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同，只是判断依据从 <code>ETag</code> 变为时间。</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可，不要返回 <code>code = 0</code> 这样的无用信息。</p>\n<p>错误时返回具体的错误信息:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'message': 'Invalid Token'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时，返回业务逻辑错误码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'code' : 10010，</div><div class=\"line\">\t'message': 'Insufficient balance'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时， 应该想着去使用 业务逻辑码 来解决问题，而不是自定义<code>HTTP status code</code> 。</em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况，这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)。</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback_function(&#123;</div><div class=\"line\">\tstatus_code: 200，</div><div class=\"line\">\tnext_page: &quot;https://..&quot;，</div><div class=\"line\">\tresponse: &#123;</div><div class=\"line\">\t\t... 正常的 JSON 实体 ... </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容。</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功，并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受，但尚未处理，请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功，但没有内容返回 (例如 <code>DELET</code> 请求) </p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据，但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在 </p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃，并且没有对应新资源 (如果是转到了新的URL，应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确，但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数，让返回的结果是格式化后的 JSON 数据，便于使用者的调试。</p>\n<p><em>如果你是一个使用者，并且api没有提供一个这样的参数的情况下，可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试。</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中，我没有提到 <code>PATCH</code>， 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况，所以，觉得这个方法不是那么主要。</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据， 要加上 <code>KEY</code> 。有时间可以学一学，做个小APP实践一下。</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读，或拆分。</p>\n<p>例如 : <code>search</code> 我的理解，  某种服务也是资源。</p>\n<p>例如 : <code>login</code> 我的理解， 对于一个 API 来说， <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建，而且是幂等的。</p>\n<p><strong>业务逻辑与代码逻辑冲突时，HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走。</p>\n<p>例如，业务的删除，在代码里的时间可能是软删除( <code>deleted_at =1</code> )，这个时候的HTTP动词一定要是 <code>DELETE</code>。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来， RESTful 真的很好，简单直观，规范易懂，贴合web，更易于测试 等等等等， 但是 毕竟只是架构风格，过度纠结如何遵守规范反而是违背了设计API的初衷.我在实践中也有很多不遵守的地方，也曾经纠结过很多东西，事后证明大部分不过是浪费时间罢了。</p>\n<p>API的设计本身就是要从使用者的角度出发，如果是对外的接口，要尽量做的规范，这样能适应大多数人，对内的接口还是要多听取下使用者的意见，针对于本身的业务来进行调整。</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解，与实践结合而成。</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好，看的中文译本)后，融合网络上的RESTful规范理解而成。</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解，剩余部分是在网络中整理提炼出来的知识，将两者整合，应用于实践后的我的理解。</p>\n<p><strong>如果你认为有些地方有问题，或者歧义比较大的话，还望指出，thanks.</strong></p>\n<p><em>因为要整理的知识点很多，也很杂乱，所以写了一个chrome扩展来帮助自己做笔记，没有上架，还在完善中，有兴趣的同学可以去我的github上down来试一试。</em></p>\n<p>终于写完了,断断续续的写了好几天,在以后的工作过程中,如果还有新的内容,也会一并更新在这里 - 2016-12-30</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"external\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此，对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士的论文中文版 因为英语不太好，所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"external\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a> (使我了解了RESTful API，可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">理解OAuth 2.0</a> (理解OAuth2.0， 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0），</div><div class=\"line\">并且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。</div><div class=\"line\">在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。</div><div class=\"line\">这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，</div><div class=\"line\">它成为了现代 Web 架构的基础。</div><div class=\"line\"></div><div class=\"line\">出自[中文译版] 结论</div></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"external\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"external\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"external\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"external\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"external\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"external\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">HTTP缓存 这里主要是讲的Etag</a></p>"},{"title":"JWT 与 OAuth 2.0","_content":"**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","source":"_posts/JWT 与 OAuth 2.0.md","raw":"---\ntitle: JWT 与 OAuth 2.0\n---\n**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","slug":"JWT 与 OAuth 2.0","published":1,"date":"2017-10-20T02:00:02.946Z","updated":"2017-10-20T02:00:02.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8zaiz690003o8quwo4pucke","content":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>\n<a id=\"more\"></a>  \n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>\n","site":{"data":{}},"excerpt":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>"},{"title":"RESTful缓存方案","_content":"\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","source":"_posts/RESTful缓存方案.md","raw":"---\ntitle: RESTful缓存方案\n---\n\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","slug":"RESTful缓存方案","published":1,"date":"2017-10-20T02:00:03.015Z","updated":"2017-10-20T02:00:03.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8zaiz6a0004o8quq449d2sb","content":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>\n<a id=\"more\"></a>  \n<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>\n","site":{"data":{}},"excerpt":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>","more":"<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}