{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","path":"static/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","path":"static/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","path":"static/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","path":"static/js/meizi.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","path":"static/images/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.jpg","path":"static/images/favicon.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","path":"static/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.jpg","path":"static/images/gravatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","path":"static/images/favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/images/xiamu.png","path":"static/images/xiamu.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","path":"static/css/style.css","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-meizi/README.md","hash":"bd5f1ef099ca4f621c29f319165c6470b0cb7014","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/_config.yml","hash":"2f3da27695f065db80cc104f86e204fcc4f738f0","modified":1476343874235},{"_id":"themes/hexo-theme-meizi/gulpfile.js","hash":"805dbc9e619c0e4be563a8a32b39060fb7475655","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/bower.json","hash":"dedf03e9e405d4be38cebaa753fe23158e32b066","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/package.json","hash":"4a88f9f1450747b0b1c13d1f2500ef63a2383de8","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.gitignore","hash":"5163f3d9e05f8be9025633bac924c47c777b41e6","modified":1476150848311},{"_id":"source/_posts/Api安全研究.md","hash":"d4ea08bf1fb8f2947a5b7a90866cf948b625dc8e","modified":1477365876081},{"_id":"source/_posts/JWT 与 OAuth 2.0.md","hash":"b483b80ef5462756ec3463063ee80c2ef85102ea","modified":1476421967231},{"_id":"source/_posts/RESTful API 实践.md","hash":"0de1c97e8a7eebf8d90e3eecc2be4ec58bfbd422","modified":1483090202459},{"_id":"source/_posts/RESTful缓存方案.md","hash":"b30dd6df21d9ab9eee31dc871cabeb874b7118f7","modified":1480990631225},{"_id":"source/_posts/tpshop代码审计--续.dat","hash":"a364ec4317bbbf9bd2e355726344e0d9335de13c","modified":1476694639589},{"_id":"source/_posts/chromeBox 大纲.dat","hash":"26d44ea5427717e9a087f0fb0e1c761b9ce8ce9a","modified":1481794161846},{"_id":"source/links/index.md","hash":"49e30f19d6276ac9f7ddd5956d05c854ae37d99a","modified":1476151170188},{"_id":"source/about/index.md","hash":"676581e1475f2ff4bd724ff63e4f6ef3a044acf8","modified":1477040992474},{"_id":"source/_posts/tpshop代码审计.dat","hash":"c6b836d318b4d08b294f94135262b27946d7959b","modified":1476668804959},{"_id":"source/tags/index.md","hash":"35867ca3284afb0c225bd922f41386fd8b21d8e8","modified":1476151234018},{"_id":"themes/hexo-theme-meizi/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1476150848311},{"_id":"source/_posts/RESTful 设计大纲.dat","hash":"53d99a05cb46ce6f4db84d39796291b2ad8f3bc1","modified":1483000924406},{"_id":"themes/hexo-theme-meizi/.git/config","hash":"1c5d5c19a26ebf5e252382d87d71de061d3cf149","modified":1476150848311},{"_id":"source/archive/index.md","hash":"fc18302dc4b2a347ac7969bab93eda360f3b7bd3","modified":1476151223272},{"_id":"themes/hexo-theme-meizi/.git/index","hash":"7dd04e6901cb2339c5088455ca12b6e872449c64","modified":1478486845947},{"_id":"themes/hexo-theme-meizi/.git/packed-refs","hash":"f1912cd5fdf10c595f5c0416d8d347c60054903a","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/about.ejs","hash":"4323c21b553780269f2cac5d6e5a8f33d6243290","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/all-archives.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1476150837665},{"_id":"themes/hexo-theme-meizi/layout/links.ejs","hash":"1514d633dae3c5c5a76344afeaa0fbdf154c025c","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/index.ejs","hash":"b0d62a2f93de7917e67556f30dee33214d9b7d74","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/tags.ejs","hash":"17a1f47a1b54624645fcb182d4e275512e918386","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/languages/zh-cn.yml","hash":"60767afef61e4ce6809071fccdc4e833b06863eb","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1476150837665},{"_id":"themes/hexo-theme-meizi/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1476150837665},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/.git/logs/HEAD","hash":"6ad4a377699b78094b84999a7e97fb76dfb6b7aa","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/about.ejs","hash":"a08ffc6ab76217d05facb9cc2b4fcc7ae5148a3e","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1476150837696},{"_id":"themes/hexo-theme-meizi/layout/_partial/index.ejs","hash":"3d0bd9cc0b5f1660d74c63166c62155e76c92102","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/links.ejs","hash":"f70a0579a35f2815b919080ae643574e7156e59d","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/_partial/tags.ejs","hash":"b5121bf77d8da66cdb18c1d6269854951fd1c0e5","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/layout/_partial/post.ejs","hash":"a9cc56d5d8cf125bd6526eecaa37c26820c3a310","modified":1476324556180},{"_id":"themes/hexo-theme-meizi/layout/_partial/archive.ejs","hash":"8126fd297918132825fe3110f5ebb0efe2b9d024","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/source/_css/style.scss","hash":"3b7fd5a263afc20c60557326827c5bd0bfc75de8","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/xiamu.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1476327869749},{"_id":"themes/hexo-theme-meizi/source/_js/meizi.js","hash":"e8e2709c6202af825f28a1fc413922c7297dd160","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.png","hash":"3d6e9a9968a1c040977337acf095594112630c68","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_images/favicon.jpg","hash":"b58fc61a225c7d6c08917b77b76152242725d897","modified":1476328003180},{"_id":"themes/hexo-theme-meizi/source/_images/gravatar.jpg","hash":"4f099782bbfd659255ae4299a101872df01c035b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/scripts/helpers/func.js","hash":"9deec4d350f6baffae85f44c91097139c3fefe46","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.idx","hash":"ddc8d023560997562e71b97d44a538fb0ed1e1f5","modified":1476150848092},{"_id":"themes/hexo-theme-meizi/.git/refs/heads/master","hash":"9e0459116ecb93cf28843d634c4f246e721004fd","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/disqus.ejs","hash":"e6658fa854c46077b797289599fb1158a05d47dd","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/duoshuo.ejs","hash":"fa58511057fb387b59771193b1d7eebfe9273c59","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/footer.ejs","hash":"fa6d3667d0bebd00475fd67c1426cd30c80e8ed3","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/head.ejs","hash":"7a463f03d7fa36e44750f63ccf51ecf52bfde3c3","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/pagination.ejs","hash":"244782d6b1fdc6bd71517709a0407272a33c7919","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/scripts.ejs","hash":"c3138803ca03ea4b94aa620b626f1d9cfe477bb2","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/sidebar.ejs","hash":"4ecc51d5c94ab12dab9c8516bb8bfcd720482fa1","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/layout/_partial/include/header.ejs","hash":"f27ad620e4d3b036ede31a5068066581e0d35532","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_query.scss","hash":"b0c46b67d87e7548ccf0704bb43363f2cc6278bd","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_iconfont.scss","hash":"7de2c0a7dc1ae4f16eb2da1a4fdddd9a0a4acd74","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_core.scss","hash":"cc72e8ef196ada45f663ab94f0b5862bf0f60f43","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_main.scss","hash":"f89d6f8c0225f60d958deb88c239ce2ba97528bb","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_header.scss","hash":"30643e4b7b2fc920c3474ab79936afd619e521ac","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/mixins/_variables.scss","hash":"38138cafcc3b702b032bb576fa46815b2f0cff3f","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_markdown.scss","hash":"2ee28dada07096cf1537652e3105d8e9216c88d3","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_sidebar.scss","hash":"d9a9cd8d52ed2d8e3b23074f1c1e7f9b179eaaf4","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/_css/include/_layout.scss","hash":"313456db88a9ffef298bce6f5041456b98f3f2a6","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.jpg","hash":"b58fc61a225c7d6c08917b77b76152242725d897","modified":1476328003180},{"_id":"themes/hexo-theme-meizi/source/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/gravatar.jpg","hash":"4f099782bbfd659255ae4299a101872df01c035b","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/favicon.png","hash":"3d6e9a9968a1c040977337acf095594112630c68","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/source/static/images/xiamu.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1476327869749},{"_id":"themes/hexo-theme-meizi/source/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1476150848326},{"_id":"themes/hexo-theme-meizi/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/heads/master","hash":"6ad4a377699b78094b84999a7e97fb76dfb6b7aa","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/logs/refs/remotes/origin/HEAD","hash":"6ad4a377699b78094b84999a7e97fb76dfb6b7aa","modified":1476150848311},{"_id":"themes/hexo-theme-meizi/.git/objects/pack/pack-c864bf3d1b1a7f1bdf1812b8af26dfa27d80b08f.pack","hash":"deb8601f46513acdf5c099767f143977c23340d2","modified":1476150848170},{"_id":"public/atom.xml","hash":"cb3738d3f503cc0c4c28add0ff3cacfacff89624","modified":1483090208550},{"_id":"public/links/index.html","hash":"9ab2a0340cce12bb93eb57a85b3ee423dbf6b7e8","modified":1483090208550},{"_id":"public/about/index.html","hash":"425aa3ac2e9893bf36401557dc7a9d74bc853884","modified":1483090208550},{"_id":"public/tags/index.html","hash":"8edd19a133c8ad2db0cfc59cb4c9c7e7cb39fc02","modified":1483090208550},{"_id":"public/archive/index.html","hash":"5fd586d366622a72f3fa1ce97ff0d700aaa51d39","modified":1483090208550},{"_id":"public/2016/10/RESTful缓存方案/index.html","hash":"c7becb2d4dd1068a37ed5ce2f1b961f44e62b2aa","modified":1483090208550},{"_id":"public/2016/10/Api安全研究/index.html","hash":"e9a728d3abff9bad8692c75b0e466af6238c324f","modified":1483090208550},{"_id":"public/2016/10/JWT 与 OAuth 2.0/index.html","hash":"34a85283987c6dad4f2673468d1a27616b6d2d83","modified":1483090208550},{"_id":"public/archives/index.html","hash":"4ac95b6ed5e89ad53cbd9f4a637e74b6952782e0","modified":1483090208550},{"_id":"public/archives/2016/index.html","hash":"4ac95b6ed5e89ad53cbd9f4a637e74b6952782e0","modified":1483090208550},{"_id":"public/archives/2016/10/index.html","hash":"f10db2a91c8fe231ee5ed2b1203ae8acb4ad8ff5","modified":1483090208550},{"_id":"public/archives/2016/12/index.html","hash":"27c32e2ad570391edfe085487dcf59a2e0c116f8","modified":1483090208550},{"_id":"public/index.html","hash":"4ac95b6ed5e89ad53cbd9f4a637e74b6952782e0","modified":1483090208550},{"_id":"public/2016/12/RESTful API 实践/index.html","hash":"a652dfbad4fd99578647ed5b92190c3c802c2c57","modified":1483090208550},{"_id":"public/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1483090208560},{"_id":"public/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1483090208560},{"_id":"public/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1483090208560},{"_id":"public/static/images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1483090208560},{"_id":"public/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1483090208560},{"_id":"public/static/images/favicon.jpg","hash":"b58fc61a225c7d6c08917b77b76152242725d897","modified":1483090208560},{"_id":"public/static/images/gravatar.jpg","hash":"4f099782bbfd659255ae4299a101872df01c035b","modified":1483090208560},{"_id":"public/static/images/favicon.png","hash":"3d6e9a9968a1c040977337acf095594112630c68","modified":1483090208560},{"_id":"public/static/images/xiamu.png","hash":"c821bc09e33096325d0913d19fd9c08910e33dd9","modified":1483090208560},{"_id":"public/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1483090208570},{"_id":"public/static/css/style.css","hash":"0e6cd3bd9e5d2ccea03fbf7c255e9b2ad83521f6","modified":1483090208570}],"Category":[],"Data":[],"Page":[{"title":"友情链接","layout":"links","_content":"\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","source":"links/index.md","raw":"title: \"友情链接\"\nlayout: \"links\"\n---\n\n<!-- 这里写你的友情链接列表 -->\n\n- <i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n这样前面会带一个小锁，标明是 https 的站点","date":"2016-10-11T01:59:30.188Z","updated":"2016-10-11T01:59:30.188Z","path":"links/index.html","comments":1,"_id":"cixblm8k10001mwi4ogiv8gqy","content":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"external\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n","excerpt":"","more":"<!-- 这里写你的友情链接列表 -->\n<ul>\n<li><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\">JerryQu 的小站</a>（万能的屈屈大神）<br>这样前面会带一个小锁，标明是 https 的站点</li>\n</ul>\n"},{"title":"关于我","layout":"about","_content":"\n<!-- 这里写你的简介 -->\n\n普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程  \n代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   \n\n博客用的Hexo + gihub,主题是https://github.com/imochen/hexo-theme-meizi  \n博客没有名字,或者说 它的名字就是Blog  \n本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  \n\nps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.","source":"about/index.md","raw":"title: \"关于我\"\nlayout: \"about\"\n---\n\n<!-- 这里写你的简介 -->\n\n普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程  \n代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   \n\n博客用的Hexo + gihub,主题是https://github.com/imochen/hexo-theme-meizi  \n博客没有名字,或者说 它的名字就是Blog  \n本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  \n\nps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.","date":"2016-10-21T09:09:52.474Z","updated":"2016-10-21T09:09:52.474Z","path":"about/index.html","comments":1,"_id":"cixblm8k10003mwi43ub6w8cj","content":"<!-- 这里写你的简介 -->\n<p>普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程<br>代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   </p>\n<p>博客用的Hexo + gihub,主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\" target=\"_blank\" rel=\"external\">https://github.com/imochen/hexo-theme-meizi</a><br>博客没有名字,或者说 它的名字就是Blog<br>本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  </p>\n<p>ps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.</p>\n","excerpt":"","more":"<!-- 这里写你的简介 -->\n<p>普通程序员,从事PHP开发.试图开启全栈技能树和接触各种语言(python ruby等),但是除了PHP都没有生产环境下经验.面向google编程<br>代码外的生活逃不出游戏/音乐/book(大部分为小说)  现在又加上了写博客   </p>\n<p>博客用的Hexo + gihub,主题是<a href=\"https://github.com/imochen/hexo-theme-meizi\">https://github.com/imochen/hexo-theme-meizi</a><br>博客没有名字,或者说 它的名字就是Blog<br>本人 不太会表达,也不会写作,如果有错误,万望指出(这也正是我写博客的主要原因)  </p>\n<p>ps: favicon与头像出自夏目友人帐.想成为像夏目一样温柔的人.</p>\n"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---","date":"2016-10-11T02:00:34.018Z","updated":"2016-10-11T02:00:34.018Z","path":"tags/index.html","comments":1,"_id":"cixblm8kb0006mwi4qwpjrke6","content":"","excerpt":"","more":""},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"title: \"归档\"\nlayout: \"all-archives\"\n---","date":"2016-10-11T02:00:23.272Z","updated":"2016-10-11T02:00:23.272Z","path":"archive/index.html","comments":1,"_id":"cixblm8kb0007mwi4rggokji6","content":"","excerpt":"","more":""}],"Post":[{"title":"Api安全 研究","_content":"\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","source":"_posts/Api安全研究.md","raw":"---\ntitle: Api安全 研究\n---\n\n**继续研究接口系列的东西,这回是安全方面的防重放攻击与限流**\n\n<!--more-->  \n\n**首先是防止重放攻击的\"签名+时间戳\"方法.**  \n\n*因为据了解apk的反编译并不难,所以我认为\"签名\"已经是防君子不防小人的东西了*  \n\n签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传  \n也有的需要解密,所以不使用hash,使用对称加密的.   \n```json\n{\n\t'data' : {\n\t\t'id' : 1\n\t},\n\t'time' : 14000000000,,\n\t'token' : 'xxxxxxxxxx',\n\t'salt' : '%^$#FJfdsd^*34'\n}\n```\n服务器端先验证时间戳超时  \n后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  \n\n\n**再说限流,因为\"DOS攻击(Denial of Service Attack)\",所以限流的存在还是很有必要的,虽然一般限流都是运维的工作**  \n*万一运维不会的话,就有用到的时候了*  \n\n常用的限流算法有两种: 漏桶算法和令牌桶算法  \n漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率  \n令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  \n\n**上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个\"冲水算法\"**  \n**冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!**  \n```php\n//用的lumen框架 php扩展的Redis\n// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)\n$ip  = $_SERVER['REMOTE_ADDR'];\n// total 为容器大小,即: $cycle时间内最多有x次访问\n$total = 10;\n// cycle 为时间周期,即: x时间内最多有$total词访问\n$cycle = 10;\n// 黑名单持续时间\n$blackTime = 600;\n// 验证黑名单\nif ($redis->get('blackIp:'.$ip)){\n  $ttl = $redis->ttl('blackIp:'.$ip);\n  return response(['error' => \"Access Denied time:\".$ttl], 403);\n}\n// 获取容器里的内容\n$bucket = $redis->lrange('ip:'.$ip,0,$total-1);\nif ($bucket){\n  // 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止\n  foreach ($bucket as $k => $v){\n    // 判断一个时间周期内是否有内容过期\n    if ((time() - $cycle*$total) < (int)$v){\n      // 存下尚未过期内容,冲掉已过期内容\n      $redis->ltrim('ip:'.$ip, $k, 9);\n      // 将起始数定为当前key\n      $start = $k;\n      break;\n    }\n  }\n  // 如果内容全部过期,则删除全部内容\n  if (!isset($start)){\n    app('phpRedis')->del('ip:'.$ip);\n  }else{\n    // 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单\n    if ($start == 0 && count($bucket) == $total){\n    app('phpRedis')->setex('blackIp:'.$ip, $blackTime, $ip);\n    }\n  }\n}\n// 存储访问记录\n$redis->rpush('ip:'.$ip,time());\n$redis->expire('ip:'.$ip,3600);\n```","slug":"Api安全研究","published":1,"date":"2016-10-21T07:21:38.263Z","updated":"2016-10-25T03:24:36.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixblm8jr0000mwi4x90wit1u","content":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>\n<a id=\"more\"></a>  \n<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>\n","excerpt":"<p><strong>继续研究接口系列的东西,这回是安全方面的防重放攻击与限流</strong></p>","more":"<p><strong>首先是防止重放攻击的”签名+时间戳”方法.</strong>  </p>\n<p><em>因为据了解apk的反编译并不难,所以我认为”签名”已经是防君子不防小人的东西了</em>  </p>\n<p>签名的算法大致都是相同的:即请求参数+时间戳+token+盐等,hash加密后传<br>也有的需要解密,所以不使用hash,使用对称加密的.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'data' : &#123;</div><div class=\"line\">\t\t'id' : 1</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t'time' : 14000000000,,</div><div class=\"line\">\t'token' : 'xxxxxxxxxx',</div><div class=\"line\">\t'salt' : '%^$#FJfdsd^*34'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>服务器端先验证时间戳超时<br>后同样的算法验证一下签名是否一致,判定成功后将签名存入缓存(缓存的时间应为验证时间戳超时的时间),下次验证签名是否存在,防止重放攻击  </p>\n<p><strong>再说限流,因为”DOS攻击(Denial of Service Attack)”,所以限流的存在还是很有必要的,虽然一般限流都是运维的工作</strong><br><em>万一运维不会的话,就有用到的时候了</em>  </p>\n<p>常用的限流算法有两种: 漏桶算法和令牌桶算法<br>漏桶算法的思路很简单,水()请求)先进入到漏桶里,漏桶以一定的速度出水,当水流入速度过大会直接溢出,可以看出漏桶算法能强行限制数据的传输速率<br>令牌桶的思路是: 所有的流量要放行前都要消耗一定量的token,所有的token都存放在一个bucket(桶)内,每经过一个时间周期(每1/r秒),都会在bucket中放入一个token,bucket有着最大的容量.当token存满容器并且没有消耗时,新的产出token将会被抛弃  </p>\n<p><strong>上面的两种算法都是有着持久化的需求(不断放水与不断加入令牌),但是web服务是访问时才会运行,所以不适用这两种方法,经过半天的思考,我想出了一个”冲水算法”</strong><br><strong>冲水就是在有需要的时候,把不需要的东西冲掉,例如,每次方便后按下冲水按钮一样,详细的过程请看代码注释!</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//用的lumen框架 php扩展的Redis</span></div><div class=\"line\"><span class=\"comment\">// 设置限制条件,也就是redis存储的名称 可更改为其他(用户id等)</span></div><div class=\"line\">$ip  = $_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>];</div><div class=\"line\"><span class=\"comment\">// total 为容器大小,即: $cycle时间内最多有x次访问</span></div><div class=\"line\">$total = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// cycle 为时间周期,即: x时间内最多有$total词访问</span></div><div class=\"line\">$cycle = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"comment\">// 黑名单持续时间</span></div><div class=\"line\">$blackTime = <span class=\"number\">600</span>;</div><div class=\"line\"><span class=\"comment\">// 验证黑名单</span></div><div class=\"line\"><span class=\"keyword\">if</span> ($redis-&gt;get(<span class=\"string\">'blackIp:'</span>.$ip))&#123;</div><div class=\"line\">  $ttl = $redis-&gt;ttl(<span class=\"string\">'blackIp:'</span>.$ip);</div><div class=\"line\">  <span class=\"keyword\">return</span> response([<span class=\"string\">'error'</span> =&gt; <span class=\"string\">\"Access Denied time:\"</span>.$ttl], <span class=\"number\">403</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 获取容器里的内容</span></div><div class=\"line\">$bucket = $redis-&gt;lrange(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">0</span>,$total<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> ($bucket)&#123;</div><div class=\"line\">  <span class=\"comment\">// 通过循环判断是否过期,因为Redis的存储方式是时间戳正序存入,所以可以找到未过期的内容即为停止</span></div><div class=\"line\">  <span class=\"keyword\">foreach</span> ($bucket <span class=\"keyword\">as</span> $k =&gt; $v)&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断一个时间周期内是否有内容过期</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((time() - $cycle*$total) &lt; (int)$v)&#123;</div><div class=\"line\">      <span class=\"comment\">// 存下尚未过期内容,冲掉已过期内容</span></div><div class=\"line\">      $redis-&gt;ltrim(<span class=\"string\">'ip:'</span>.$ip, $k, <span class=\"number\">9</span>);</div><div class=\"line\">      <span class=\"comment\">// 将起始数定为当前key</span></div><div class=\"line\">      $start = $k;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果内容全部过期,则删除全部内容</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($start))&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;del(<span class=\"string\">'ip:'</span>.$ip);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果起始数为0,证明没有过期内容,并且容器已满,加入黑名单</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ($start == <span class=\"number\">0</span> &amp;&amp; count($bucket) == $total)&#123;</div><div class=\"line\">    app(<span class=\"string\">'phpRedis'</span>)-&gt;setex(<span class=\"string\">'blackIp:'</span>.$ip, $blackTime, $ip);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 存储访问记录</span></div><div class=\"line\">$redis-&gt;rpush(<span class=\"string\">'ip:'</span>.$ip,time());</div><div class=\"line\">$redis-&gt;expire(<span class=\"string\">'ip:'</span>.$ip,<span class=\"number\">3600</span>);</div></pre></td></tr></table></figure></p>"},{"title":"JWT 与 OAuth 2.0","_content":"**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","source":"_posts/JWT 与 OAuth 2.0.md","raw":"---\ntitle: JWT 与 OAuth 2.0\n---\n**新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理**  \n\n在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   \n\n<!--more-->  \n\n```\nJWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。\n```\n\nhttp://laravelacademy.org/post/3640.html?utm_source=tuicool&utm_medium=referral   \n\n```\nOAuth是一个关于授权（authorization）的开放网络标准\n```\n\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  \n\n以上是两篇详细解读JWT于OAuth2.0的文章  \n\n**以下是我的理解:**  \n\nJWT的token是用于传递消息的,所以token是能被解密的  \n\nOAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  ","slug":"JWT 与 OAuth 2.0","published":1,"date":"2016-10-12T10:00:27.365Z","updated":"2016-10-14T05:12:47.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixblm8k10002mwi4afqzizbs","content":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>\n<a id=\"more\"></a>  \n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>\n","excerpt":"<p><strong>新的项目要写接口 开始研究接口规范,决定使用RESTful风格接口规范与OAuth2.0权限管理</strong>  </p>\n<p>在了解OAuth2.0的过程中,发现了JWT,搜索到的结果也有好多《JWT加OAuth2.0实现xxx》等文章,让我误以为JWT与OAuth2.0是一种东西,甚至于是依赖于OAuth2.0,专用于生成token的规范.细心了解之后,发现并不一样   </p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</div></pre></td></tr></table></figure>\n<p><a href=\"http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral\">http://laravelacademy.org/post/3640.html?utm_source=tuicool&amp;utm_medium=referral</a>   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OAuth是一个关于授权（authorization）的开放网络标准</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>\n<p>以上是两篇详细解读JWT于OAuth2.0的文章  </p>\n<p><strong>以下是我的理解:</strong>  </p>\n<p>JWT的token是用于传递消息的,所以token是能被解密的  </p>\n<p>OAuth2.0的token就代表着授权令牌,而消息是服务器端在与token关联的消息体上获取.因为token本身并没有蕴含消息,所以token的生成只需要hash一下并且保证不重复就ok了  </p>"},{"title":"RESTful API 实践","_content":"\n## 理解 REST 与 RESTful\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful.\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容,资源就是\"Representational State Transfer\"这个词组中被省略的主语\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性),可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)\n\n### SSL/TLS\n\n条件允许的情况下,永远使用SSL/TLS!\n\n好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持\n\n### 文档\n\n文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用\n\n这里推荐使用Postman,很好用的调试RESTful API的chrome应用\n\n### 版本号\n\nAPI不会是永远稳定的,版本升级的问题无法避免.\n\n版本号只允许枚举,不允许区间.\n\n关于API的版本号问题,有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些\n2. 放入Header 信息中.URL更加优雅,api.github.com采用此方法\n\n### 信息过滤\n\n包括 筛选、排序、分页等\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户\n\n为了使接口调用者更加方便,可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户\n\n*如果业务过于复杂导致普通的查询参数无法胜任,可以试着查询参数json化,虽然不标准,但是已解决问题为主*\n\n**限制返回字段**\n\n`?fields=id,name`\n\n**排序**\n\n两种解决方案,第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种,使用 `-` 表示倒序,使用 `,` 分隔多个排序:\n\n```\n?sort=-type,created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种,第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页,需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页\n2. 会出现重复数据问题\n3. 当`offset`数值较大时,效率降低明显\n4. 分页不涉及排序\n\n我认为使用游标的分页方式受众面比较小,例如想要作为游标的字段有着重复的数据,不能适应负责的排序等.多数情况下,不推荐使用\n\n*在实践中发现 重复数据 的问题有些严重,我的解决方案是增加首次分页的时间作为查询条件,取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示,*\n\n### exceptional 返回时详细描述**\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State), REST的重要原则之一\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法,比如,访问 api.github.com \n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\",\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一,也看了在API中的用处[[5]](#HATEOAS),但是在实践中感觉用处不是很大,碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主题为 `json` 格式数据\n关于优缺点不多做描述, QuQu大神 讲解的很详细了[[6]](#JSON格式输入)\n\n### 相关资源嵌入\n\nAPI在使用过程中,不可避免的要遇到需要加载相关数据的情况,比如说获取一个用户信息的同时获取这个用户相关的部门信息,这个时候让客户端再请求一次部门的接口是不友好的,也不能在用户信息里加入相关部门信息.\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入\n\n```\n?embed=department.name,job\n```\n\n使用 `.` 表示相关字段, 使用 `,` 分割资源列表\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1,\n\t\"name\" : \"user\",\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t},\n\t\"job\" : {\n\t\t\"id\" : 1,\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议,不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)\n\n这里主要说的是 RESTful API 在这方面做出的处理\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误\n\n同时应在响应头中提示用户,命名没有一定的规范,但也要遵守基本法,不要胡乱取名,示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)\n\n### 权限\n\nREST的重要原则之一就是无状态,所以不应该使用 `cookie` & `session` , 而是使用 凭证 来进行权限认证.\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0),作为API的权限控制, 对内接口也可使用简化版的 OAuth2.0\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则, 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)\n\n我的总结: 语义不同.\n\n`sessionID` 作为一种 标识着某个会话的KEY,给服务端传递请求的语义为:请帮我取出这个信息,在这里,信息是由服务端进行存储的,所以,毫无疑问这是违反REST无状态原则的.\n\n而凭据呢,是服务端期待着客户端传过来的用户验证身份的凭据,是由客户端进行存储的,所以是符合REST原则的\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`\n\n这里有一片讲解 `ETag` 的文章, 非常详细[[12]](#Etag详解)\n\n`Last-Modified` 基本与 `ETag` 相同,只是判断依据从 `ETag` 变为时间\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可,不要返回 `code = 0` 这样的无用信息\n\n错误时返回具体的错误信息\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时,返回业务逻辑错误码\n\n```json\n{\n\t'code' : 10010,\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时, 应该想着去使用 业务逻辑码 来解决问题,而不是自定义`HTTP status code`*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况,这是要将头信息包含在实体中返回(例如 `JSONP`)\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200,\n\tnext_page: \"https://..\",\n\tresponse: {\n\t\t... 正常的 JSON 实体 ... \n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功,并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现,而且有一个新的资源已经依据请求的需要而创建,其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受,但尚未处理,请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功,但没有内容返回 (例如 `DELET` 请求) \n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据,但权限不足\n\n - `404 Not Found` - 请求的资源不存在 \n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃,并且没有对应新资源 (如果是转到了新的URL,应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确,但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数,让返回的结果是格式化后的 JSON 数据,便于使用者的调试.\n\n*如果你是一个使用者,并且api没有提供一个这样的参数的情况下,可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试*\n\n### 实践出真知\n\n在上面常见的HTTP动词中,我没有提到 `PATCH`, 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况,所以,觉得这个方法不是那么主要\n\n客户端要求不能直接返回数组型的 JSON 数据, 要加上 `KEY` .有时间可以学一学,做个小APP实践一下\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读,或拆分\n\n例如 : `search` 我的理解,  某种服务也是资源\n\n例如 : `login` 我的理解, 对于一个 API 来说, `login` 的行为在本质上是对 `凭据` 这个资源的创建,而且是幂等的\n\n**业务逻辑与代码逻辑冲突时,HTTP动词的选择**\n\n跟着业务逻辑走\n\n例如,业务的删除,在代码里的时间可能是软删除( `deleted_at =1` ),这个时候的HTTP动词一定要是 `DELETE`\n\n### 写在最后\n\n在我看来, RESTful 真的很好,简单直观,规范易懂,贴合web,更易于测试 等等等等, 但是 毕竟只是架构风格,过度纠结如何遵守规范反而是违背了设计API的初衷.\n\n我在实践中也有很多不遵守的地方,也曾经纠结过很多东西,事后证明大部分不过是浪费时间罢了.\n\nAPI的设计本身就是要从使用者的角度出发,如果是对外的接口,要尽量做的规范,这样能适应大多数人,对内的接口还是要多听取下使用者的意见,针对于本身的业务来进行调整.\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解,与实践结合而成.\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好,看的中文译本)后,融合网络上的RESTful规范理解而成\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解,剩余部分是在网络中整理提炼出来的知识,将两者整合,应用于实践后的我的理解.\n\n**如果你认为有些地方有问题,或者歧义比较大的话,还望指出,thanks**\n\n*因为要整理的知识点很多,也很杂乱,所以写了一个chrome扩展来帮助自己做笔记,没有上架,还在完善中,有兴趣的同学可以去我的github上down来试一试*\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此,对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好,所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API,可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0, 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0）[19]，并且为 HTTP/1.1 [42] 和 URI（统一资源标识符）[21] 的新规范设计扩展。在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)","source":"_posts/RESTful API 实践.md","raw":"---\ntitle: RESTful API 实践\n---\n\n## 理解 REST 与 RESTful\n\nREST 是Fielding博士在他的论文[[1]](#Fielding博士论文)中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[[2]](#HTTP)\n\n符合 REST 原则的应用程序或设计称做 RESTful.\n\n<!--more-->\n\n**RESTful API 设计原则:**\n\n1. 无状态\n\n - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端\n\n - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存*\n\n2. 对于web的融入\n\n - 这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用\n\n3. 资源\n\n - 对于资源的抽象，是设计RESTful API的核心内容,资源就是\"Representational State Transfer\"这个词组中被省略的主语\n\n - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。\n\n4. 缓存\n\n - 应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择\n\n5. 低耦合\n\n - REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[[3]](#低耦合性)\n\n## RESTful API 实践\n\n### 请求\n\nRESTful 使用HTTP动词操作资源\n\n**常用的HTTP动词有下面四个[[4]](#所有的HTTP动词)**\n\n1. `GET` - 用于获取资源信息\n2. `POST` - 用于新建或修改资源\n3. `PUT` - 用于新建或修改资源\n4. `DELETE` - 用于删除资源\n\n**幂等性(Idempotent)**\n\n幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE\n\n用一个点赞的示例来说明幂等性 & POST与PUT的区别:\n\n当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法\n\n*PUT方法的幂等性使我们能更好的处理逻辑*\n\n**常见操作示例**\n\n- `GET /user` - 获取用户列表\n- `GET /user/uid` - 获取指定用户\n- `GET /user/uid/comments` - 获取指定用户的评论\n- `POST /user` - 新建一个用户\n- `PUT /user/uid` - 修改指定用户\n- `DELETE /user/uid` - 删除指定用户\n\n*URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径*\n\n**不被支持的HTTP动词**\n\n有些情况下会只支持GET&POST方法(HTML的FORM标签method属性),可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)\n\n### SSL/TLS\n\n条件允许的情况下,永远使用SSL/TLS!\n\n好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持\n\n### 文档\n\n文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用\n\n这里推荐使用Postman,很好用的调试RESTful API的chrome应用\n\n### 版本号\n\nAPI不会是永远稳定的,版本升级的问题无法避免.\n\n版本号只允许枚举,不允许区间.\n\n关于API的版本号问题,有两种解决方案:\n\n1. 放入URL中. 优点是更加直观些\n2. 放入Header 信息中.URL更加优雅,api.github.com采用此方法\n\n### 信息过滤\n\n包括 筛选、排序、分页等\n\n**筛选**\n\n`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户\n\n为了使接口调用者更加方便,可以将一些常见的查询参数使用别名表示:\n\n`GET /users/vip` - 筛选出所有 `vip` 用户\n\n*如果业务过于复杂导致普通的查询参数无法胜任,可以试着查询参数json化,虽然不标准,但是已解决问题为主*\n\n**限制返回字段**\n\n`?fields=id,name`\n\n**排序**\n\n两种解决方案,第一种是拆分为两个参数:\n\n```\n?sortby=level&order=asc\n```\n\n第二种,使用 `-` 表示倒序,使用 `,` 分隔多个排序:\n\n```\n?sort=-type,created_at\n```\n\n**分页**\n\n常见的分页解决方案有两种,第一种是传统的 `offset` + `limit` :\n\n```\n?offset=10 - 偏移量\n?limit=10 - 返回数量\n```\n\n第二种是使用游标分页,需提供 `cursor` (下一页的游标) 与 `limit` :\n\n```\n?cursor=2015-01-01 15:20:30 - 使用时间作为游标\n?limit=10 - 返回数量\n```\n\n总结一下传统分页的特点:\n\n1. 传统分页可以进行跳页\n2. 会出现重复数据问题\n3. 当`offset`数值较大时,效率降低明显\n4. 分页不涉及排序\n\n我认为使用游标的分页方式受众面比较小,例如想要作为游标的字段有着重复的数据,不能适应负责的排序等.多数情况下,不推荐使用\n\n*在实践中发现 重复数据 的问题有些严重,我的解决方案是增加首次分页的时间作为查询条件,取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示,*\n\n### exceptional 返回时详细描述**\n\n### HATEOAS\n\nHATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State), REST的重要原则之一\n\n在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法,比如,访问 api.github.com \n\n```json\n{\n\t\"current_user_url\": \"https://api.github.com/user\",\n\t......\n}\n```\n\n理应作为RESTful的设计原则之一,也看了在API中的用处[[5]](#HATEOAS),但是在实践中感觉用处不是很大,碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧\n\n### JSON格式请求\n\n请求头的 `Content-Type` 设置为 `application/json` 告诉服务器端消息主题为 `json` 格式数据\n关于优缺点不多做描述, QuQu大神 讲解的很详细了[[6]](#JSON格式输入)\n\n### 相关资源嵌入\n\nAPI在使用过程中,不可避免的要遇到需要加载相关数据的情况,比如说获取一个用户信息的同时获取这个用户相关的部门信息,这个时候让客户端再请求一次部门的接口是不友好的,也不能在用户信息里加入相关部门信息.\n\n解决方案是在请求参数中加入 `embed` 来表示相关资源的嵌入\n\n```\n?embed=department.name,job\n```\n\n使用 `.` 表示相关字段, 使用 `,` 分割资源列表\n\n这个请求的返回应该是:\n\n```json\n{\n\t\"id\" : 1,\n\t\"name\" : \"user\",\n\t\"department\" : {\n\t\t\"name\" : \"xxx\"\n\t},\n\t\"job\" : {\n\t\t\"id\" : 1,\n\t\t\"name\" : \"xxxx\"\n\t}\n}\n```\n\n*没有使用过HTTP2.0协议,不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景*\n\n### 限流\n\n用户在一定时间内发出的请求次数要做出限制\n\n具体算法可以看大神博客[[7]](#流量控制与令牌桶算法)\n\n这里主要说的是 RESTful API 在这方面做出的处理\n\n在 `HTTP status code` 中有 `429` 专用于返回此种错误\n\n同时应在响应头中提示用户,命名没有一定的规范,但也要遵守基本法,不要胡乱取名,示例:\n\n```\n\tX-Rate-Limit-Limit - 周期内允许请求的总数\n\tX-Rate-Limit-Remaining - 周期内剩余可请求次数\n\tX-Rate-Limit-Reset - 周期剩余时间\n```\n\nstackoverflow 上有关于这个问题的讨论[[8]](#缓存头信息返回方案)\n\n不要使用UNIX时间戳[[9]](#为什么不要使用UNIX时间戳)\n\n### 权限\n\nREST的重要原则之一就是无状态,所以不应该使用 `cookie` & `session` , 而是使用 凭证 来进行权限认证.\n\n对外的接口应使用 OAuth2.0 框架[[10]](#OAuth2.0),作为API的权限控制, 对内接口也可使用简化版的 OAuth2.0\n\n关于 为什么 `session` 是 不符合REST原则的 而 凭证 又是符合REST原则, 这里的答案可以进行参照[[11]](#REST无状态(stateless)原则)\n\n我的总结: 语义不同.\n\n`sessionID` 作为一种 标识着某个会话的KEY,给服务端传递请求的语义为:请帮我取出这个信息,在这里,信息是由服务端进行存储的,所以,毫无疑问这是违反REST无状态原则的.\n\n而凭据呢,是服务端期待着客户端传过来的用户验证身份的凭据,是由客户端进行存储的,所以是符合REST原则的\n\n### 缓存\n\nHTTP已经为我们提供了很好的解决方案 `ETag` & `Last-Modified`\n\n这里有一片讲解 `ETag` 的文章, 非常详细[[12]](#Etag详解)\n\n`Last-Modified` 基本与 `ETag` 相同,只是判断依据从 `ETag` 变为时间\n\n### 响应\n\n**始终返回适当的HTTP状态码**\n\n**使用 `JSON` 作为唯一的返回格式**\n\n正确(200 系)时返回所请求的数据即可,不要返回 `code = 0` 这样的无用信息\n\n错误时返回具体的错误信息\n\n```json\n{\n\t'message': 'Invalid Token'\n}\n```\n\n业务逻辑较为复杂时,返回业务逻辑错误码\n\n```json\n{\n\t'code' : 10010,\n\t'message': 'Insufficient balance'\n}\n```\n\n*业务逻辑错误码应与HTTP状态码不重复*\n\n*当你认为 `HTTP status code` 不够用时, 应该想着去使用 业务逻辑码 来解决问题,而不是自定义`HTTP status code`*\n\n**Enveloping**\n\n应考虑到客户端无法获取头信息的情况,这是要将头信息包含在实体中返回(例如 `JSONP`)\n\n请求参数 `?enveloping=jsonp`\n\n```\ncallback_function({\n\tstatus_code: 200,\n\tnext_page: \"https://..\",\n\tresponse: {\n\t\t... 正常的 JSON 实体 ... \n\t}\n})\n```\n\n**创建 & 更新**\n\n创建 & 更新的请求(POST & PUT) 应返回该资源的内容\n\n**常用的 `HTTP status codes`**\n\n - `200 OK` - 请求成功,并且请求结果已返回至响应实体中\n\n - `201 Created` - 请求已经被实现,而且有一个新的资源已经依据请求的需要而创建,其URI会返回在头信息中\n\n - `202 Accepted` - 请求已被接受,但尚未处理,请求有可能会拒绝执行 (例如 异步请求)\n\n - `204 No Content` - 请求成功,但没有内容返回 (例如 `DELET` 请求) \n\n - `304 Not Modified` - 请求的资源没有修改 适用于请求 缓存 没有变化的资源\n\n - `400 Bad Request` - 请求的格式不正确 客户端不应该重复该请求\n\n - `401 Unauthorized` - 需要客户端提供身份凭据\n\n - `403 Forbidden` - 客户端提供了身份凭据,但权限不足\n\n - `404 Not Found` - 请求的资源不存在 \n\n - `405 Method Not Allowed` - 不存在当前请求的HTTP动词\n\n - `410 Gone` - 请求的资源已废弃,并且没有对应新资源 (如果是转到了新的URL,应使用 `301 Moved Permanently`)\n\n - `422 Unprocessable Entity` - 通常用于请求格式正确,但是用户输入的值不符合服务端的需求 (表单验证)\n\n - `429 Too Many Requests` 请求的速率超过限制\n\n**美化返回结果**\n\n可以提供一个参数,让返回的结果是格式化后的 JSON 数据,便于使用者的调试.\n\n*如果你是一个使用者,并且api没有提供一个这样的参数的情况下,可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试*\n\n### 实践出真知\n\n在上面常见的HTTP动词中,我没有提到 `PATCH`, 是因为我在实际使用中没有碰到要划分 `PUT` 与 `PATH` 的情况,所以,觉得这个方法不是那么主要\n\n客户端要求不能直接返回数组型的 JSON 数据, 要加上 `KEY` .有时间可以学一学,做个小APP实践一下\n\n**当你认为你的业务不属于以上HTTP动词的范畴中时**\n\n对业务进行深层次解读,或拆分\n\n例如 : `search` 我的理解,  某种服务也是资源\n\n例如 : `login` 我的理解, 对于一个 API 来说, `login` 的行为在本质上是对 `凭据` 这个资源的创建,而且是幂等的\n\n**业务逻辑与代码逻辑冲突时,HTTP动词的选择**\n\n跟着业务逻辑走\n\n例如,业务的删除,在代码里的时间可能是软删除( `deleted_at =1` ),这个时候的HTTP动词一定要是 `DELETE`\n\n### 写在最后\n\n在我看来, RESTful 真的很好,简单直观,规范易懂,贴合web,更易于测试 等等等等, 但是 毕竟只是架构风格,过度纠结如何遵守规范反而是违背了设计API的初衷.\n\n我在实践中也有很多不遵守的地方,也曾经纠结过很多东西,事后证明大部分不过是浪费时间罢了.\n\nAPI的设计本身就是要从使用者的角度出发,如果是对外的接口,要尽量做的规范,这样能适应大多数人,对内的接口还是要多听取下使用者的意见,针对于本身的业务来进行调整.\n\n**This**\n\n本编文章是总结我对于REST与RESTful的理解,与实践结合而成.\n\n[《理解 REST 与 RESTful》](#理解-REST-与-RESTful) 一章来源与我看过博士的论文(英语不好,看的中文译本)后,融合网络上的RESTful规范理解而成\n\n[《RESTful API 实践》](#RESTful-API-实践) 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解,剩余部分是在网络中整理提炼出来的知识,将两者整合,应用于实践后的我的理解.\n\n**如果你认为有些地方有问题,或者歧义比较大的话,还望指出,thanks**\n\n*因为要整理的知识点很多,也很杂乱,所以写了一个chrome扩展来帮助自己做笔记,没有上架,还在完善中,有兴趣的同学可以去我的github上down来试一试*\n\n### 参考文章\n\n1. [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api) (本篇文章的大部分知识点来源于此,对于我理解应用RESTful有着很大的帮助)\n\n2. [架构风格与基于网络应用软件的架构设计（中文修订版）](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士的论文中文版 因为英语不太好,所以没有强行去看原版)\n\n3. [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ([Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)博士论文原版)\n\n4. [理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/) (帮助我理解了REST概念)\n\n5. [我所认为的RESTful API最佳实践](http://www.scienjus.com/my-restful-api-best-practices/) (找到的国内RESTful API实践中较好的一篇文章)\n\n6. [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) (使我了解了RESTful API,可惜东西讲解的有些少)\n\n7. [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html) (RESTful基础)\n\n8. [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) (理解OAuth2.0, 有这篇文章就够了)\n\n9. [对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm) (加深了我对于 无状态 的理解)\n\n### 注\n\n##### Fielding博士论文\n\n[英文原版](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)\n\n[中文译版](http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive)\n\n##### HTTP\n\n```\n我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0）[19]，并且为 HTTP/1.1 [42] 和 URI（统一资源标识符）[21] 的新规范设计扩展。在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，它成为了现代 Web 架构的基础。\n\n出自[中文译版] 结论\n```\n\n##### 低耦合性\n\n[理解本真的REST架构风格](http://www.infoq.com/cn/articles/understanding-restful-style/)\n\nREST特性讲解\n\n##### 所有的HTTP动词\n\n[ALL](https://tools.ietf.org/html/rfc2616#section-9)\n\n##### HATEOAS\n\n[在RESTFul API中使用HATEOAS的好处](http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages)\n\n##### JSON格式输入\n\n[QuQu大神博文](https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2)\n\n##### 流量控制与令牌桶算法\n\n[潘神- 流量控制与令牌桶算法](https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket)\n\n##### 缓存头信息返回方案\n\n[讨论](http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers)\n\n##### 为什么不要使用UNIX时间戳\n\n[为什么不要使用UNIX时间戳](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting)\n\n##### OAuth2.0\n\n[大神博客 - 理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n##### REST无状态(stateless)原则\n[对于REST中无状态(stateless)的一点认识](http://developer.51cto.com/art/200906/129424.htm)\n\n##### Etag详解\n\n[HTTP缓存 这里主要是讲的Etag](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)","slug":"RESTful API 实践","published":1,"date":"2016-12-26T09:21:24.337Z","updated":"2016-12-30T09:30:02.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixblm8k10004mwi417mpt6mz","content":"<h2 id=\"理解-REST-与-RESTful\"><a href=\"#理解-REST-与-RESTful\" class=\"headerlink\" title=\"理解 REST 与 RESTful\"></a>理解 REST 与 RESTful</h2><p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful.</p>\n<a id=\"more\"></a>\n<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容,资源就是”Representational State Transfer”这个词组中被省略的主语</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性),可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下,永远使用SSL/TLS!</p>\n<p>好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用</p>\n<p>这里推荐使用Postman,很好用的调试RESTful API的chrome应用</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的,版本升级的问题无法避免.</p>\n<p>版本号只允许枚举,不允许区间.</p>\n<p>关于API的版本号问题,有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些</li>\n<li>放入Header 信息中.URL更加优雅,api.github.com采用此方法</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户</p>\n<p>为了使接口调用者更加方便,可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任,可以试着查询参数json化,虽然不标准,但是已解决问题为主</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id,name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案,第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sortby=level&amp;order=asc</div></pre></td></tr></table></figure>\n<p>第二种,使用 <code>-</code> 表示倒序,使用 <code>,</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sort=-type,created_at</div></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种,第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?offset=10 - 偏移量</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>第二种是使用游标分页,需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页</li>\n<li>会出现重复数据问题</li>\n<li>当<code>offset</code>数值较大时,效率降低明显</li>\n<li>分页不涉及排序</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小,例如想要作为游标的字段有着重复的数据,不能适应负责的排序等.多数情况下,不推荐使用</p>\n<p><em>在实践中发现 重复数据 的问题有些严重,我的解决方案是增加首次分页的时间作为查询条件,取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示,</em></p>\n<h3 id=\"exceptional-返回时详细描述\"><a href=\"#exceptional-返回时详细描述\" class=\"headerlink\" title=\"exceptional 返回时详细描述**\"></a>exceptional 返回时详细描述**</h3><h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State), REST的重要原则之一</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法,比如,访问 api.github.com </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t\"current_user_url\": \"https://api.github.com/user\",</div><div class=\"line\">\t......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一,也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>,但是在实践中感觉用处不是很大,碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主题为 <code>json</code> 格式数据<br>关于优缺点不多做描述, QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a></p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中,不可避免的要遇到需要加载相关数据的情况,比如说获取一个用户信息的同时获取这个用户相关的部门信息,这个时候让客户端再请求一次部门的接口是不友好的,也不能在用户信息里加入相关部门信息.</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?embed=department.name,job</div></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段, 使用 <code>,</code> 分割资源列表</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>,</div><div class=\"line\">\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"user\"</span>,</div><div class=\"line\">\t<span class=\"attr\">\"department\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">\"job\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>,</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议,不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a></p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误</p>\n<p>同时应在响应头中提示用户,命名没有一定的规范,但也要遵守基本法,不要胡乱取名,示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</div><div class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</div><div class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</div></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a></p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a></p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态,所以不应该使用 <code>cookie</code> &amp; <code>session</code> , 而是使用 凭证 来进行权限认证.</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>,作为API的权限控制, 对内接口也可使用简化版的 OAuth2.0</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则, 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)</p>\n<p>我的总结: 语义不同.</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY,给服务端传递请求的语义为:请帮我取出这个信息,在这里,信息是由服务端进行存储的,所以,毫无疑问这是违反REST无状态原则的.</p>\n<p>而凭据呢,是服务端期待着客户端传过来的用户验证身份的凭据,是由客户端进行存储的,所以是符合REST原则的</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code></p>\n<p>这里有一片讲解 <code>ETag</code> 的文章, 非常详细<a href=\"#Etag详解\">[12]</a></p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同,只是判断依据从 <code>ETag</code> 变为时间</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可,不要返回 <code>code = 0</code> 这样的无用信息</p>\n<p>错误时返回具体的错误信息</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'message': 'Invalid Token'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时,返回业务逻辑错误码</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'code' : 10010,</div><div class=\"line\">\t'message': 'Insufficient balance'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时, 应该想着去使用 业务逻辑码 来解决问题,而不是自定义<code>HTTP status code</code></em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况,这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback_function(&#123;</div><div class=\"line\">\tstatus_code: 200,</div><div class=\"line\">\tnext_page: &quot;https://..&quot;,</div><div class=\"line\">\tresponse: &#123;</div><div class=\"line\">\t\t... 正常的 JSON 实体 ... </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功,并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现,而且有一个新的资源已经依据请求的需要而创建,其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受,但尚未处理,请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功,但没有内容返回 (例如 <code>DELET</code> 请求) </p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据,但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在 </p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃,并且没有对应新资源 (如果是转到了新的URL,应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确,但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数,让返回的结果是格式化后的 JSON 数据,便于使用者的调试.</p>\n<p><em>如果你是一个使用者,并且api没有提供一个这样的参数的情况下,可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中,我没有提到 <code>PATCH</code>, 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况,所以,觉得这个方法不是那么主要</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据, 要加上 <code>KEY</code> .有时间可以学一学,做个小APP实践一下</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读,或拆分</p>\n<p>例如 : <code>search</code> 我的理解,  某种服务也是资源</p>\n<p>例如 : <code>login</code> 我的理解, 对于一个 API 来说, <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建,而且是幂等的</p>\n<p><strong>业务逻辑与代码逻辑冲突时,HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走</p>\n<p>例如,业务的删除,在代码里的时间可能是软删除( <code>deleted_at =1</code> ),这个时候的HTTP动词一定要是 <code>DELETE</code></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来, RESTful 真的很好,简单直观,规范易懂,贴合web,更易于测试 等等等等, 但是 毕竟只是架构风格,过度纠结如何遵守规范反而是违背了设计API的初衷.</p>\n<p>我在实践中也有很多不遵守的地方,也曾经纠结过很多东西,事后证明大部分不过是浪费时间罢了.</p>\n<p>API的设计本身就是要从使用者的角度出发,如果是对外的接口,要尽量做的规范,这样能适应大多数人,对内的接口还是要多听取下使用者的意见,针对于本身的业务来进行调整.</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解,与实践结合而成.</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好,看的中文译本)后,融合网络上的RESTful规范理解而成</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解,剩余部分是在网络中整理提炼出来的知识,将两者整合,应用于实践后的我的理解.</p>\n<p><strong>如果你认为有些地方有问题,或者歧义比较大的话,还望指出,thanks</strong></p>\n<p><em>因为要整理的知识点很多,也很杂乱,所以写了一个chrome扩展来帮助自己做笔记,没有上架,还在完善中,有兴趣的同学可以去我的github上down来试一试</em></p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\" target=\"_blank\" rel=\"external\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此,对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士的论文中文版 因为英语不太好,所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"external\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\" target=\"_blank\" rel=\"external\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a> (使我了解了RESTful API,可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">理解OAuth 2.0</a> (理解OAuth2.0, 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"external\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\" target=\"_blank\" rel=\"external\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0）[19]，并且为 HTTP/1.1 [42] 和 URI（统一资源标识符）[21] 的新规范设计扩展。在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，它成为了现代 Web 架构的基础。</div><div class=\"line\"></div><div class=\"line\">出自[中文译版] 结论</div></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\" target=\"_blank\" rel=\"external\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\" target=\"_blank\" rel=\"external\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\" target=\"_blank\" rel=\"external\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\" target=\"_blank\" rel=\"external\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\" target=\"_blank\" rel=\"external\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\" target=\"_blank\" rel=\"external\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\" target=\"_blank\" rel=\"external\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"external\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\" target=\"_blank\" rel=\"external\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">HTTP缓存 这里主要是讲的Etag</a></p>\n","excerpt":"<h2 id=\"理解-REST-与-RESTful\"><a href=\"#理解-REST-与-RESTful\" class=\"headerlink\" title=\"理解 REST 与 RESTful\"></a>理解 REST 与 RESTful</h2><p>REST 是Fielding博士在他的论文<a href=\"#Fielding博士论文\">[1]</a>中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.<a href=\"#HTTP\">[2]</a></p>\n<p>符合 REST 原则的应用程序或设计称做 RESTful.</p>","more":"<p><strong>RESTful API 设计原则:</strong></p>\n<ol>\n<li><p>无状态</p>\n<ul>\n<li><p>通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端</p>\n</li>\n<li><p><em>有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存</em></p>\n</li>\n</ul>\n</li>\n<li><p>对于web的融入</p>\n<ul>\n<li>这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用</li>\n</ul>\n</li>\n<li><p>资源</p>\n<ul>\n<li><p>对于资源的抽象，是设计RESTful API的核心内容,资源就是”Representational State Transfer”这个词组中被省略的主语</p>\n</li>\n<li><p>REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。</p>\n</li>\n</ul>\n</li>\n<li><p>缓存</p>\n<ul>\n<li>应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择</li>\n</ul>\n</li>\n<li><p>低耦合</p>\n<ul>\n<li>REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）<a href=\"#低耦合性\">[3]</a></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"RESTful-API-实践\"><a href=\"#RESTful-API-实践\" class=\"headerlink\" title=\"RESTful API 实践\"></a>RESTful API 实践</h2><h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>RESTful 使用HTTP动词操作资源</p>\n<p><strong>常用的HTTP动词有下面四个<a href=\"#所有的HTTP动词\">[4]</a></strong></p>\n<ol>\n<li><code>GET</code> - 用于获取资源信息</li>\n<li><code>POST</code> - 用于新建或修改资源</li>\n<li><code>PUT</code> - 用于新建或修改资源</li>\n<li><code>DELETE</code> - 用于删除资源</li>\n</ol>\n<p><strong>幂等性(Idempotent)</strong></p>\n<p>幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE</p>\n<p>用一个点赞的示例来说明幂等性 &amp; POST与PUT的区别:</p>\n<p>当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法</p>\n<p><em>PUT方法的幂等性使我们能更好的处理逻辑</em></p>\n<p><strong>常见操作示例</strong></p>\n<ul>\n<li><code>GET /user</code> - 获取用户列表</li>\n<li><code>GET /user/uid</code> - 获取指定用户</li>\n<li><code>GET /user/uid/comments</code> - 获取指定用户的评论</li>\n<li><code>POST /user</code> - 新建一个用户</li>\n<li><code>PUT /user/uid</code> - 修改指定用户</li>\n<li><code>DELETE /user/uid</code> - 删除指定用户</li>\n</ul>\n<p><em>URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径</em></p>\n<p><strong>不被支持的HTTP动词</strong></p>\n<p>有些情况下会只支持GET&amp;POST方法(HTML的FORM标签method属性),可以在头信息中加入 <code>X-HTTP-Method-Override</code> 来表示当前的HTTP请求或在请求参数中加入 <code>_method</code> 来表示当前请求(laravel框架使用的此方法)</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>条件允许的情况下,永远使用SSL/TLS!</p>\n<p>好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持</p>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用</p>\n<p>这里推荐使用Postman,很好用的调试RESTful API的chrome应用</p>\n<h3 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h3><p>API不会是永远稳定的,版本升级的问题无法避免.</p>\n<p>版本号只允许枚举,不允许区间.</p>\n<p>关于API的版本号问题,有两种解决方案:</p>\n<ol>\n<li>放入URL中. 优点是更加直观些</li>\n<li>放入Header 信息中.URL更加优雅,api.github.com采用此方法</li>\n</ol>\n<h3 id=\"信息过滤\"><a href=\"#信息过滤\" class=\"headerlink\" title=\"信息过滤\"></a>信息过滤</h3><p>包括 筛选、排序、分页等</p>\n<p><strong>筛选</strong></p>\n<p><code>GET /users?name=张三</code> - 筛选出所有 <code>name = 张三</code> 的用户</p>\n<p>为了使接口调用者更加方便,可以将一些常见的查询参数使用别名表示:</p>\n<p><code>GET /users/vip</code> - 筛选出所有 <code>vip</code> 用户</p>\n<p><em>如果业务过于复杂导致普通的查询参数无法胜任,可以试着查询参数json化,虽然不标准,但是已解决问题为主</em></p>\n<p><strong>限制返回字段</strong></p>\n<p><code>?fields=id,name</code></p>\n<p><strong>排序</strong></p>\n<p>两种解决方案,第一种是拆分为两个参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sortby=level&amp;order=asc</div></pre></td></tr></table></figure>\n<p>第二种,使用 <code>-</code> 表示倒序,使用 <code>,</code> 分隔多个排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?sort=-type,created_at</div></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<p>常见的分页解决方案有两种,第一种是传统的 <code>offset</code> + <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?offset=10 - 偏移量</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>第二种是使用游标分页,需提供 <code>cursor</code> (下一页的游标) 与 <code>limit</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">?cursor=2015-01-01 15:20:30 - 使用时间作为游标</div><div class=\"line\">?limit=10 - 返回数量</div></pre></td></tr></table></figure>\n<p>总结一下传统分页的特点:</p>\n<ol>\n<li>传统分页可以进行跳页</li>\n<li>会出现重复数据问题</li>\n<li>当<code>offset</code>数值较大时,效率降低明显</li>\n<li>分页不涉及排序</li>\n</ol>\n<p>我认为使用游标的分页方式受众面比较小,例如想要作为游标的字段有着重复的数据,不能适应负责的排序等.多数情况下,不推荐使用</p>\n<p><em>在实践中发现 重复数据 的问题有些严重,我的解决方案是增加首次分页的时间作为查询条件,取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示,</em></p>\n<h3 id=\"exceptional-返回时详细描述\"><a href=\"#exceptional-返回时详细描述\" class=\"headerlink\" title=\"exceptional 返回时详细描述**\"></a>exceptional 返回时详细描述**</h3><h3 id=\"HATEOAS\"><a href=\"#HATEOAS\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h3><p>HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State), REST的重要原则之一</p>\n<p>在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法,比如,访问 api.github.com </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t\"current_user_url\": \"https://api.github.com/user\",</div><div class=\"line\">\t......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理应作为RESTful的设计原则之一,也看了在API中的用处<a href=\"#HATEOAS\">[5]</a>,但是在实践中感觉用处不是很大,碰到业务逻辑比较复杂的地方用起来也很麻烦.还是视情况应用吧</p>\n<h3 id=\"JSON格式请求\"><a href=\"#JSON格式请求\" class=\"headerlink\" title=\"JSON格式请求\"></a>JSON格式请求</h3><p>请求头的 <code>Content-Type</code> 设置为 <code>application/json</code> 告诉服务器端消息主题为 <code>json</code> 格式数据<br>关于优缺点不多做描述, QuQu大神 讲解的很详细了<a href=\"#JSON格式输入\">[6]</a></p>\n<h3 id=\"相关资源嵌入\"><a href=\"#相关资源嵌入\" class=\"headerlink\" title=\"相关资源嵌入\"></a>相关资源嵌入</h3><p>API在使用过程中,不可避免的要遇到需要加载相关数据的情况,比如说获取一个用户信息的同时获取这个用户相关的部门信息,这个时候让客户端再请求一次部门的接口是不友好的,也不能在用户信息里加入相关部门信息.</p>\n<p>解决方案是在请求参数中加入 <code>embed</code> 来表示相关资源的嵌入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?embed=department.name,job</div></pre></td></tr></table></figure>\n<p>使用 <code>.</code> 表示相关字段, 使用 <code>,</code> 分割资源列表</p>\n<p>这个请求的返回应该是:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>,</div><div class=\"line\">\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"user\"</span>,</div><div class=\"line\">\t<span class=\"attr\">\"department\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxx\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">\"job\"</span> : &#123;</div><div class=\"line\">\t\t<span class=\"attr\">\"id\"</span> : <span class=\"number\">1</span>,</div><div class=\"line\">\t\t<span class=\"attr\">\"name\"</span> : <span class=\"string\">\"xxxx\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>没有使用过HTTP2.0协议,不清楚 2.0 的多路复用(Multiplexing) 会不会适用此场景</em></p>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p>用户在一定时间内发出的请求次数要做出限制</p>\n<p>具体算法可以看大神博客<a href=\"#流量控制与令牌桶算法\">[7]</a></p>\n<p>这里主要说的是 RESTful API 在这方面做出的处理</p>\n<p>在 <code>HTTP status code</code> 中有 <code>429</code> 专用于返回此种错误</p>\n<p>同时应在响应头中提示用户,命名没有一定的规范,但也要遵守基本法,不要胡乱取名,示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Rate-Limit-Limit - 周期内允许请求的总数</div><div class=\"line\">X-Rate-Limit-Remaining - 周期内剩余可请求次数</div><div class=\"line\">X-Rate-Limit-Reset - 周期剩余时间</div></pre></td></tr></table></figure>\n<p>stackoverflow 上有关于这个问题的讨论<a href=\"#缓存头信息返回方案\">[8]</a></p>\n<p>不要使用UNIX时间戳<a href=\"#为什么不要使用UNIX时间戳\">[9]</a></p>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><p>REST的重要原则之一就是无状态,所以不应该使用 <code>cookie</code> &amp; <code>session</code> , 而是使用 凭证 来进行权限认证.</p>\n<p>对外的接口应使用 OAuth2.0 框架<a href=\"#OAuth2.0\">[10]</a>,作为API的权限控制, 对内接口也可使用简化版的 OAuth2.0</p>\n<p>关于 为什么 <code>session</code> 是 不符合REST原则的 而 凭证 又是符合REST原则, 这里的答案可以进行参照<a href=\"#REST无状态(stateless\">[11]</a>原则)</p>\n<p>我的总结: 语义不同.</p>\n<p><code>sessionID</code> 作为一种 标识着某个会话的KEY,给服务端传递请求的语义为:请帮我取出这个信息,在这里,信息是由服务端进行存储的,所以,毫无疑问这是违反REST无状态原则的.</p>\n<p>而凭据呢,是服务端期待着客户端传过来的用户验证身份的凭据,是由客户端进行存储的,所以是符合REST原则的</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>HTTP已经为我们提供了很好的解决方案 <code>ETag</code> &amp; <code>Last-Modified</code></p>\n<p>这里有一片讲解 <code>ETag</code> 的文章, 非常详细<a href=\"#Etag详解\">[12]</a></p>\n<p><code>Last-Modified</code> 基本与 <code>ETag</code> 相同,只是判断依据从 <code>ETag</code> 变为时间</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p><strong>始终返回适当的HTTP状态码</strong></p>\n<p><strong>使用 <code>JSON</code> 作为唯一的返回格式</strong></p>\n<p>正确(200 系)时返回所请求的数据即可,不要返回 <code>code = 0</code> 这样的无用信息</p>\n<p>错误时返回具体的错误信息</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'message': 'Invalid Token'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务逻辑较为复杂时,返回业务逻辑错误码</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t'code' : 10010,</div><div class=\"line\">\t'message': 'Insufficient balance'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>业务逻辑错误码应与HTTP状态码不重复</em></p>\n<p><em>当你认为 <code>HTTP status code</code> 不够用时, 应该想着去使用 业务逻辑码 来解决问题,而不是自定义<code>HTTP status code</code></em></p>\n<p><strong>Enveloping</strong></p>\n<p>应考虑到客户端无法获取头信息的情况,这是要将头信息包含在实体中返回(例如 <code>JSONP</code>)</p>\n<p>请求参数 <code>?enveloping=jsonp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback_function(&#123;</div><div class=\"line\">\tstatus_code: 200,</div><div class=\"line\">\tnext_page: &quot;https://..&quot;,</div><div class=\"line\">\tresponse: &#123;</div><div class=\"line\">\t\t... 正常的 JSON 实体 ... </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>创建 &amp; 更新</strong></p>\n<p>创建 &amp; 更新的请求(POST &amp; PUT) 应返回该资源的内容</p>\n<p><strong>常用的 <code>HTTP status codes</code></strong></p>\n<ul>\n<li><p><code>200 OK</code> - 请求成功,并且请求结果已返回至响应实体中</p>\n</li>\n<li><p><code>201 Created</code> - 请求已经被实现,而且有一个新的资源已经依据请求的需要而创建,其URI会返回在头信息中</p>\n</li>\n<li><p><code>202 Accepted</code> - 请求已被接受,但尚未处理,请求有可能会拒绝执行 (例如 异步请求)</p>\n</li>\n<li><p><code>204 No Content</code> - 请求成功,但没有内容返回 (例如 <code>DELET</code> 请求) </p>\n</li>\n<li><p><code>304 Not Modified</code> - 请求的资源没有修改 适用于请求 缓存 没有变化的资源</p>\n</li>\n<li><p><code>400 Bad Request</code> - 请求的格式不正确 客户端不应该重复该请求</p>\n</li>\n<li><p><code>401 Unauthorized</code> - 需要客户端提供身份凭据</p>\n</li>\n<li><p><code>403 Forbidden</code> - 客户端提供了身份凭据,但权限不足</p>\n</li>\n<li><p><code>404 Not Found</code> - 请求的资源不存在 </p>\n</li>\n<li><p><code>405 Method Not Allowed</code> - 不存在当前请求的HTTP动词</p>\n</li>\n<li><p><code>410 Gone</code> - 请求的资源已废弃,并且没有对应新资源 (如果是转到了新的URL,应使用 <code>301 Moved Permanently</code>)</p>\n</li>\n<li><p><code>422 Unprocessable Entity</code> - 通常用于请求格式正确,但是用户输入的值不符合服务端的需求 (表单验证)</p>\n</li>\n<li><p><code>429 Too Many Requests</code> 请求的速率超过限制</p>\n</li>\n</ul>\n<p><strong>美化返回结果</strong></p>\n<p>可以提供一个参数,让返回的结果是格式化后的 JSON 数据,便于使用者的调试.</p>\n<p><em>如果你是一个使用者,并且api没有提供一个这样的参数的情况下,可以使用chrome扩展(搜索 JSON VIEW 此类的关键词)或Postman 来进行调试</em></p>\n<h3 id=\"实践出真知\"><a href=\"#实践出真知\" class=\"headerlink\" title=\"实践出真知\"></a>实践出真知</h3><p>在上面常见的HTTP动词中,我没有提到 <code>PATCH</code>, 是因为我在实际使用中没有碰到要划分 <code>PUT</code> 与 <code>PATH</code> 的情况,所以,觉得这个方法不是那么主要</p>\n<p>客户端要求不能直接返回数组型的 JSON 数据, 要加上 <code>KEY</code> .有时间可以学一学,做个小APP实践一下</p>\n<p><strong>当你认为你的业务不属于以上HTTP动词的范畴中时</strong></p>\n<p>对业务进行深层次解读,或拆分</p>\n<p>例如 : <code>search</code> 我的理解,  某种服务也是资源</p>\n<p>例如 : <code>login</code> 我的理解, 对于一个 API 来说, <code>login</code> 的行为在本质上是对 <code>凭据</code> 这个资源的创建,而且是幂等的</p>\n<p><strong>业务逻辑与代码逻辑冲突时,HTTP动词的选择</strong></p>\n<p>跟着业务逻辑走</p>\n<p>例如,业务的删除,在代码里的时间可能是软删除( <code>deleted_at =1</code> ),这个时候的HTTP动词一定要是 <code>DELETE</code></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在我看来, RESTful 真的很好,简单直观,规范易懂,贴合web,更易于测试 等等等等, 但是 毕竟只是架构风格,过度纠结如何遵守规范反而是违背了设计API的初衷.</p>\n<p>我在实践中也有很多不遵守的地方,也曾经纠结过很多东西,事后证明大部分不过是浪费时间罢了.</p>\n<p>API的设计本身就是要从使用者的角度出发,如果是对外的接口,要尽量做的规范,这样能适应大多数人,对内的接口还是要多听取下使用者的意见,针对于本身的业务来进行调整.</p>\n<p><strong>This</strong></p>\n<p>本编文章是总结我对于REST与RESTful的理解,与实践结合而成.</p>\n<p><a href=\"#理解-REST-与-RESTful\">《理解 REST 与 RESTful》</a> 一章来源与我看过博士的论文(英语不好,看的中文译本)后,融合网络上的RESTful规范理解而成</p>\n<p><a href=\"#RESTful-API-实践\">《RESTful API 实践》</a> 一章的来源: 大部分知识点源自我对于 《Best Practices for Designing a Pragmatic RESTful API》的理解,剩余部分是在网络中整理提炼出来的知识,将两者整合,应用于实践后的我的理解.</p>\n<p><strong>如果你认为有些地方有问题,或者歧义比较大的话,还望指出,thanks</strong></p>\n<p><em>因为要整理的知识点很多,也很杂乱,所以写了一个chrome扩展来帮助自己做笔记,没有上架,还在完善中,有兴趣的同学可以去我的github上down来试一试</em></p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\">Best Practices for Designing a Pragmatic RESTful API</a> (本篇文章的大部分知识点来源于此,对于我理解应用RESTful有着很大的帮助)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\">架构风格与基于网络应用软件的架构设计（中文修订版）</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\">Fielding</a>博士的论文中文版 因为英语不太好,所以没有强行去看原版)</p>\n</li>\n<li><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\">Architectural Styles and the Design of Network-based Software Architectures</a> (<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\">Fielding</a>博士论文原版)</p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\">理解本真的REST架构风格</a> (帮助我理解了REST概念)</p>\n</li>\n<li><p><a href=\"http://www.scienjus.com/my-restful-api-best-practices/\">我所认为的RESTful API最佳实践</a> (找到的国内RESTful API实践中较好的一篇文章)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南</a> (使我了解了RESTful API,可惜东西讲解的有些少)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">理解RESTful架构</a> (RESTful基础)</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解OAuth 2.0</a> (理解OAuth2.0, 有这篇文章就够了)</p>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\">对于REST中无状态(stateless)的一点认识</a> (加深了我对于 无状态 的理解)</p>\n</li>\n</ol>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><h5 id=\"Fielding博士论文\"><a href=\"#Fielding博士论文\" class=\"headerlink\" title=\"Fielding博士论文\"></a>Fielding博士论文</h5><p><a href=\"http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\">英文原版</a></p>\n<p><a href=\"http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&amp;utm_medium=link&amp;utm_campaign=rest-deep-dive\">中文译版</a></p>\n<h5 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0）[19]，并且为 HTTP/1.1 [42] 和 URI（统一资源标识符）[21] 的新规范设计扩展。在开展这些工作的最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。这个关于整个 Web 应用中的交互的理想化模型，被称作表述性状态移交（REST）架构风格，它成为了现代 Web 架构的基础。</div><div class=\"line\"></div><div class=\"line\">出自[中文译版] 结论</div></pre></td></tr></table></figure>\n<h5 id=\"低耦合性\"><a href=\"#低耦合性\" class=\"headerlink\" title=\"低耦合性\"></a>低耦合性</h5><p><a href=\"http://www.infoq.com/cn/articles/understanding-restful-style/\">理解本真的REST架构风格</a></p>\n<p>REST特性讲解</p>\n<h5 id=\"所有的HTTP动词\"><a href=\"#所有的HTTP动词\" class=\"headerlink\" title=\"所有的HTTP动词\"></a>所有的HTTP动词</h5><p><a href=\"https://tools.ietf.org/html/rfc2616#section-9\">ALL</a></p>\n<h5 id=\"HATEOAS-1\"><a href=\"#HATEOAS-1\" class=\"headerlink\" title=\"HATEOAS\"></a>HATEOAS</h5><p><a href=\"http://www.infoq.com/cn/news/2009/04/hateoas-restful-api-advantages\">在RESTFul API中使用HATEOAS的好处</a></p>\n<h5 id=\"JSON格式输入\"><a href=\"#JSON格式输入\" class=\"headerlink\" title=\"JSON格式输入\"></a>JSON格式输入</h5><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2\">QuQu大神博文</a></p>\n<h5 id=\"流量控制与令牌桶算法\"><a href=\"#流量控制与令牌桶算法\" class=\"headerlink\" title=\"流量控制与令牌桶算法\"></a>流量控制与令牌桶算法</h5><p><a href=\"https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket\">潘神- 流量控制与令牌桶算法</a></p>\n<h5 id=\"缓存头信息返回方案\"><a href=\"#缓存头信息返回方案\" class=\"headerlink\" title=\"缓存头信息返回方案\"></a>缓存头信息返回方案</h5><p><a href=\"http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers\">讨论</a></p>\n<h5 id=\"为什么不要使用UNIX时间戳\"><a href=\"#为什么不要使用UNIX时间戳\" class=\"headerlink\" title=\"为什么不要使用UNIX时间戳\"></a>为什么不要使用UNIX时间戳</h5><p><a href=\"http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting\">为什么不要使用UNIX时间戳</a></p>\n<h5 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h5><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">大神博客 - 理解OAuth 2.0</a></p>\n<h5 id=\"REST无状态-stateless-原则\"><a href=\"#REST无状态-stateless-原则\" class=\"headerlink\" title=\"REST无状态(stateless)原则\"></a>REST无状态(stateless)原则</h5><p><a href=\"http://developer.51cto.com/art/200906/129424.htm\">对于REST中无状态(stateless)的一点认识</a></p>\n<h5 id=\"Etag详解\"><a href=\"#Etag详解\" class=\"headerlink\" title=\"Etag详解\"></a>Etag详解</h5><p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">HTTP缓存 这里主要是讲的Etag</a></p>"},{"title":"RESTful缓存方案","_content":"\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","source":"_posts/RESTful缓存方案.md","raw":"---\ntitle: RESTful缓存方案\n---\n\n**RESTful的缓存是使用了http缓存规范**  \n参考文章:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn \n\n<!--more-->  \n\n**http的缓存有两种方案`ETag`与` Last-Modified` 本文讲的是第一种,也就是参考文章里所讲的**  \n\n`ETag`缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等\n```\n200 OK\nCache-Controller: max-age=60\nETag: \"xxxxxxxxxxxxx\"\nContent-Lenght: 1024\n```\n上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  \n\n客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带`If-None-Match`值为前文收到的验证令牌.  \n服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回`304`+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回`200`+资源内容,响应头中附带缓存时间与新的验证令牌  \n```\n资源无更新示例:\n304 Not Modified\nCache-Controller: max-age=60\n\n资源有更新示例:\n200 OK\nCache-Controller: max-age=60\nETag: \"ooooooooooooo\"\nContent-Lenght: 1024\n```\n\n更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.","slug":"RESTful缓存方案","published":1,"date":"2016-10-25T01:30:35.259Z","updated":"2016-12-06T02:17:11.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixblm8k10005mwi4wmqejpar","content":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"external\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>\n<a id=\"more\"></a>  \n<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>\n","excerpt":"<p><strong>RESTful的缓存是使用了http缓存规范</strong><br>参考文章:<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a> </p>","more":"<p><strong>http的缓存有两种方案<code>ETag</code>与<code>Last-Modified</code> 本文讲的是第一种,也就是参考文章里所讲的</strong>  </p>\n<p><code>ETag</code>缓存方案的实现很简单,服务器返回响应头的时,加上缓存时间与验证令牌(ETag),如有需要还可以加上内容类型、长度等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;xxxxxxxxxxxxx&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>上面的示例代码中,服务器告诉了客户端,可以缓存60秒,验证令牌为:xxxxxxxxxxxxx,内容长度是1024  </p>\n<p>客户端在收到响应头时,可在本地缓存一个60秒的内容,60秒后,重新访问资源,并在请求头中附带<code>If-None-Match</code>值为前文收到的验证令牌.<br>服务器根据客户端提供的验证令牌,判断资源是否有更新,如果没有更新,则返回<code>304</code>+空的内容,响应头中附带新的可缓存时间,如果资源有更新,则返回<code>200</code>+资源内容,响应头中附带缓存时间与新的验证令牌<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">资源无更新示例:</div><div class=\"line\">304 Not Modified</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\"></div><div class=\"line\">资源有更新示例:</div><div class=\"line\">200 OK</div><div class=\"line\">Cache-Controller: max-age=60</div><div class=\"line\">ETag: &quot;ooooooooooooo&quot;</div><div class=\"line\">Content-Lenght: 1024</div></pre></td></tr></table></figure></p>\n<p>更详细的缓存方案也是半懂不懂,有时间应该买本《HTTP权威指南》.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}