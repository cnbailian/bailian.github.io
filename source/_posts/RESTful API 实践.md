---
title: RESTful API 实践
---

## 首先理解 REST 与 RESTful

REST 是Fielding博士在他的论文[1]中提出的一种新的架构风格,被称作表述性状态移交（Representational State Transfer）架构风格,它成为了现代 Web 架构的基础.[2]

符合 REST 原则的应用程序或设计称做 RESTful.

<!--more-->

**RESTful API 设计原则:**

1. 无状态

 - 通信必须在本质上是无状态的.无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端提出请求时，请求本身包含了这一请求所需的全部信息,会话状态因此要全部保存在客户端

 - *有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存*

2. 对于web的融入

 - 这个API应该能够使用浏览器来进行所有测试,能够方便的使用web功能测试、性能测试等工具进行测试,web类应用也方便将多个RESTful API进行整合应用

3. 资源

 - 对于资源的抽象，是设计RESTful API的核心内容,资源就是"Representational State Transfer"这个词组中被省略的主语

 - REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。

4. 缓存

 - 应当具有良好的缓存机制, HTTP的缓存机制就是个不错的选择

5. 低耦合

 - REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）[3]

## RESTful API 实践

### 请求

RESTful 使用HTTP动词操作资源

**常用的HTTP动词有下面四个[4]**

1. `GET` - 用于获取资源信息
2. `POST` - 用于新建或修改资源
3. `PUT` - 用于新建或修改资源
4. `DELETE` - 用于删除资源

**幂等性(Idempotent)**

幂等性是指: 多次请求所得到的结果与一次请求所得到的结果相同. 上方具有幂等性的方法有GET/PUT/DELETE

用一个点赞的示例来说明幂等性 & POST与PUT的区别:

当这个点赞一个人只能点赞一次的时候,应使用PUT方法,这个点赞是具有幂等性的,当一个人可以点赞无数次时,应使用POST方法

*PUT方法的幂等性使我们能更好的处理逻辑*

**常见操作示例**

- `GET /user` - 获取用户列表
- `GET /user/uid` - 获取指定用户
- `GET /user/uid/comments` - 获取指定用户的评论
- `POST /user` - 新建一个用户
- `PUT /user/uid` - 修改指定用户
- `DELETE /user/uid` - 删除指定用户

*URL的设计原则:资源不能使用动词、路径不宜过深,二三层即可,过深可以使用参数的方式来代表、永远使用最短的路径*

**不被支持的HTTP动词**

有些情况下会只支持GET&POST方法(HTML的FORM标签method属性),可以在头信息中加入 `X-HTTP-Method-Override` 来表示当前的HTTP请求或在请求参数中加入 `_method` 来表示当前请求(laravel框架使用的此方法)

### SSL/TLS

条件允许的情况下,永远使用SSL/TLS!

好处不多说了,再说一点: 不要将HTTP重定向到HTTPS,抛出错误就好,因为第一次的 HTTP 请求就有可能被劫持,导致请求无法到达服务器，从而构成 HTTPS 降级劫持

### 文档

文档应简单易懂并具有良好的示例,粘贴至浏览器能直接使用

这里推荐使用Postman,很好用的调试RESTful API的chrome应用

### 版本号

API不会是永远稳定的,版本升级的问题无法避免.

版本号只允许枚举,不允许区间.

关于API的版本号问题,有两种解决方案:

1. 放入URL中. 优点是更加直观些
2. 放入Header 信息中.URL更加优雅,api.github.com采用此方法

### 信息过滤

包括 筛选、排序、分页等

**筛选**

`GET /users?name=张三` - 筛选出所有 `name = 张三` 的用户

为了使接口调用者更加方便,可以将一些常见的查询参数使用别名表示:

`GET /users/vip` - 筛选出所有 `vip` 用户

*如果业务过于复杂导致普通的查询参数无法胜任,可以试着查询参数json化,虽然不标准,但是已解决问题为主*

**限制返回字段**

`?fields=id,name`

**排序**

两种解决方案,第一种是拆分为两个参数:

````
?sortby=level&order=asc
````

第二种,使用 `-` 表示倒序,使用 `,` 分隔多个排序:

````
?sort=-type,created_at
````

**分页**

常见的分页解决方案有两种,第一种是传统的 `offset` + `limit` :

````
?offset=10 - 偏移量
?limit=10 - 返回数量
````

第二种是使用游标分页,需提供 `cursor` (下一页的游标) 与 `limit` :

````
?cursor=2015-01-01 15:20:30 - 使用时间作为游标
?limit=10 - 返回数量
````

总结一下传统分页的特点:

1. 传统分页可以进行跳页
2. 会出现重复数据问题
3. 当`offset`数值较大时,效率降低明显
4. 分页不涉及排序

我认为使用游标的分页方式受众面比较小,例如想要作为游标的字段有着重复的数据,不能适应负责的排序等.多数情况下,不推荐使用

*在实践中发现 重复数据 的问题有些严重,我的解决方案是增加首次分页的时间作为查询条件,取所有小于这个时间的数据.缺点是会造成后续新增数据只有在刷新后才显示,*

### exceptional 返回时详细描述**

### HATEOAS

HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State), REST的重要原则之一

在 RESTful 中表现为: 返回结果中提供链接，连向其他API方法,比如,访问 api.github.com 

````json
{
    "current_user_url": "https://api.github.com/user",
}
````

理应作为RESTful的设计原则之一,但是在实践中的效果来看有些鸡肋.

