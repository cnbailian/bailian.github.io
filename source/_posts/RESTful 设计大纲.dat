RESTful 设计大纲

首先理解REST与RESTful
REST:
我们在互联网工程工作组（IETF）定义了现有的超文本移交协议（HTTP/1.0，并
且为 HTTP/1.1 和 URI（统一资源标识符）的新规范设计扩展。在开展这些工作的
最初阶段，我就认识到需要建立一个关于 Web 的运转方式的模型。这个关于整个 Web 应用中
的交互的理想化模型，被称作表述性状态移交（Representational State Transfer）架构风格，它成为了现代 Web 架构
的基础。
来自于Roy Thomas Fielding博士的论文的中文译本《架构风格与基于网络应用软件的架构设计（中文修订版）》译者:李锟
更多REST解读:http://www.ruanyifeng.com/blog/2011/09/restful.html 阮一峰
http://www.infoq.com/cn/articles/understanding-restful-style/ 中文译者

论文原文http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm
译本http://www.infoq.com/cn/minibooks/web-based-apps-archit-design?utm_source=minibooks_about_rest-deep-dive&utm_medium=link&utm_campaign=rest-deep-dive


RESTful:符合 REST 原则的应用程序或设计称做 RESTful。

一个设计良好的RESTful API 应当具有一下几种特征:

无状态: 通信必须在本质上是无状态的.从客户到服务器的每个请求都必须包含理解该请求所必需的所有信息,不能利用任何存储在服务器端的上下文，会话状态因此要全部保存在客户端.
无状态指的是任意一个Web请求必须完全与其他请求隔离，当请求端提出请求时，请求本身包含了相应端为相应这一请求所需的全部信息。
这一约束的出现改善了分布式系统的可见性、可靠性以及可伸缩性.
有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。

缓存:应当具有良好的缓存机制,HTTP缓存

资源:对于资源的抽象，是设计RESTful API的核心内容,资源就是"Representational State Transfer"这个词组中被省略的主语 REST 对于信息的核心抽象是资源.任何能够被命名的信息都能够作为一个资源:一份文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源的集合、一个非虚拟的对象（例如，人）等等。

web:能够很好的融入web,能够使用浏览器+html完成所有测试.能方便的使用web功能测试、性能测试等工具进行测试

低耦合: REST的几个特征保证了RESTful API的低耦合性, 对于资源（Resource）的抽象、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）

下面是api的设计细节
  

使用http请求操作资源
  get post put delete patch视情况使用  幂等性
  关系型资源  使用
  GET /tickets/12/messages
  GET /tickets/12/messages/12
  如果关系可以独立存在 可以使用
  GET /messages/12
  但是需要在返回中加入所属资源
  不被支持的http方法
  有些情况下会只支持GET&POST方法,我们可以在头信息中加入X-HTTP-Method-Override来表示当前http请求
  或在请求参数中加入_method来表示,laravel使用此方法

SSL
  条件允许下,永远使用ssl
  并且指向非ssl的地址不要重定向到带有ssl的地址 抛出一个错误就好

Documentation
  文档应简单易懂 并 具有良好的示例 粘贴至浏览器能直接使用

Versioning
  api不会是永远稳定的,版本问题无法避免
  版本号放置有两种方案
  header头中 or URL中
  个人倾向URL,更加直观

过滤信息
  如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果
  查询:
    GET /tickets?type=1 即查询所有type等于1的tickets
    如果业务过于复杂并且接口调用人员具有基本的sql知识的话,可以将查询参数json化,例如:
    GET /tickets?q= [{"name":"type","value":"1","operate":"="}]
    注意限制查询表与接口安全
    为了让使用者更加方便,可以将常见的查询用别名表示,例如:
    GET /tickets/closed 即查询所有已关闭的ticket
  限制返回字段:
    ?fields=id,type
  排序:
    有两种解决方案
    1:拆分两个参数
      ?sortby=type&order=asc
    2:使用-表示倒序 使用,分隔多个排序
      ?sort=-type,created_at
  限制数量与分页:
    *分页的返回应在头信息中加入上一页与下一页link 如果需要返回总数,也应一起加入头中X-Total-Count=20
    ?limit=10 返回数量
    ?offset=10 偏移量 返回的开始位置
    分页解决方案:
      分页的解决方案也有很多,例如使用offset与limit
      还可以:
      ?page=2&per_page=100 指定第几页，以及每页的记录数
      tip:
        分页不重复数据,可在查询参数中加入第一个分页时的时间,数据库中提供查询字段,所有大于这个时间的全部不显示,但是会造成后续加入数据不显示

Enveloping
  如果你的使用者无法获取头信息,应该给予一个参数 ?enveloping=true 来将头信息包裹在body中进行返回
  例如 JSONP
  callback_function({
    status_code: 200,
    next_page: "https://..",
    response: {
      //正常的body内容
    }
  })

HATEOAS(超媒体即应用状态引擎 Hypermedia as the Engine of Application State)
  REST重要原则之一
  光看这个名称我完全没有理解,继续看下去后才明白含义.
  即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么.
  访问http://api.github.com 可以得到标准的返回
  这么做的好处有很多,使用服务器返回的URI能减少部分错误与无破坏的升级接口等
  但是,由于这个规范不是很完善,又不能完全替代版本问题,各大框架也没有很好的支持,所以显得很鸡肋
  web 中超媒体取得了成功,但是在api中却显得有些鸡肋
  理应作为RESTful的设计原则

JSON格式输入
  话不多说,屈屈大神博客:https://imququ.com/post/four-ways-to-post-data-in-http.html#toc-2
  优缺点都说的很易懂了,很好用,但确实现在各个框架乃至语言对这方面的支持很不友好

相关资源嵌入
  api在实际应用中,不可避免的有需要加载相关资源的情况,而不是要求使用者请求多次接口.
  这不符合REST风格,我们可以通过参数化来尽量贴近原则.
  例如:?embed=customer.name,assigned_user
  用`,`分割资源列表,用`.`表示相关字段

限流
  用户在一定的时间内能发出的请求量要做出限制.
  具体算法可以看大神博客:https://blog.jamespan.me/2015/10/19/traffic-shaping-with-token-bucket
  这里主要说的是RESTful在这方面应该做出的处理.
  在HTTP status code中有`429`专用于返回此种错误
  应在HTTP Header中返回相应信息已提示用户,命名没有一定的规范,但也要遵守基本法,不要胡乱取名,示例:
    X-Rate-Limit-Limit - 周期内允许请求的总数
    X-Rate-Limit-Remaining - 周期内剩余可请求次数
    X-Rate-Limit-Reset - 周期剩余时间
  更多关于返回信息讨论:http://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers
  作者着重提出了不要使用周期结束时的UNIX时间戳

授权
  REST的无状态原则 服务端不应使用coookie or session 等会话来存储客户端的信息 使用凭据来验证身份
  虽然看上去差不多, 但是区别在于 语义不同.
  session ID 作为一种 标识着某个会话的KEY,给服务端传递请求的语义为:请帮我取出这个状态信息,在这里,状态信息是由服务端进行存储的,所以,毫无疑问这是违反REST无状态原则的
  而凭据呢,是服务端期待着客户端传过来的用户验证身份的凭据,是由客户端进行存储的,所以是符合REST原则的

  大部分情况下都应使用OAuth2.0框架,阮老师的关于OAuth2.0的博文:http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

缓存
  HTTP已经为我们提供了很好的缓存解决方案`Etag`与`Last-Modified`
  Etag可以看我以前的一篇博文:https://cnbailian.github.io/2016/10/RESTful%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/
  Last-Modified基本与Etag相同,只是判断依据从Etag变为时间

响应
  *api应始终返回正确的HTTP状态码
  https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
  使用JSON作为唯一的返回格式
  客户端错误 400系列 返回要带有message信息:
  { 'message': 'Invalid Token' }
  有需要可以在响应内容中加入错误代码.给予客户端一个凭据展示更详细的信息,多语言等
  如果说已github的api为RESTful参考标准的话,这不符合,但会使我们的api更加友好

  200系列 返回不应该带有`code:0`等无用信息,直接返回所需数据就好
