---
title: Clean Architecture 读书笔记
date: 2020/3/13 00:00:00
---


## 什么是软件架构

软件架构本身是一门划分边界的艺术，边界的作用是将软件划分成各种元素，重要的是分清高层策略与底层细节的边界，同时保证这些边界的依赖关系原则。

软件架构的目标：围绕着用例展开，支撑起系统的整个生命周期，让系统便于理解、易于修改、方便维护，并且能轻松部署。用最小的人力成本来满足构建和维护该系统的需求。

<!--more-->  



## 为好的软件架构而持续斗争

#### 价值维度

系统行为，是紧急的。系统架构，是重要的。根据艾森豪威尔矩阵来说：要优先重要的事。而业务人员有没有能力评估系统架构的重要程度，这是开发人员自己的工作职责。

#### 持续抗争

研发团队必须从长远的利益出发与其他部门抗争，软件的可维护性需要由你来保护，这是你角色的一部分，也是你职责中不可缺少的一部分。如果忽视软件架构的价值，系统将变得越来越难以维护，成本也会越来越高。终会有一天，系统将变得再也无法修改。



## 如何设计一个好的软件架构

#### 编程范式

编程范式告诉我了我们不能做什么，而不是可以做什么：

* 结构化编程对程序控制权的直接转移做出了限制。

* 面向对象编程对程序控制权的间接转移进行了限制和规范。

* 函数式编程对程序中的赋值进行了限制和规范。

编程范式的历史知识和软件架构的关系密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是个模块的算法实现基础。折合软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。

#### 设计原则

SOLID 设计原则可以写出整洁的代码，它的主要作用是告诉我们如何将数据和函数组织成“类”，以及如何将这些类连接起来成为程序。概要：

* SRP：单一职责原则

  定义任何一个软件模块都应该只对某一类行为者负责。如果要有其他因素的干扰，通过 facade 设计模式进行类与函数的拆分。简单的类比就是 Entity 与 Use Case 或 DDD 中的聚合与领域服务。

* OCP：开闭原则

  我们应该通过扩展来实现新的需求，而不是修改现有代码。在软件架构层面，软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些相互隔离的函数分组整理成组件结构。

* LSP：里式替换原则

  如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作独享 T 类型的程序 P 在使用 o2 替换 o1 时行为保持不变，我们就可以将 S 成为 T 的字类型。这里强调的是行为保持不变，也就是说子类型可以实现父类型的抽象方法，但不能覆盖父类型的实现。

* ISP：接口隔离原则

  避免不必要的依赖。

* DIP：依赖反转原则

  高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，相反，细节应该依赖抽象。

#### 组件

组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。设计良好饿组件应该永远保持可被独立部署的特性。

组件的聚合遵守以下三个基本原则：

* REP：复用/发布等同原则

  软件复用的最小粒度应等同于其发布的最小粒度

* CCP：共同闭包原则

  将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。

* CRP：共同复用原则

  不要强迫一个组件的用户依赖他们不需要的东西。也就是说，不是紧密相连的类不应该被放在同一个组件里。

其中 REP 和 CCP 是黏合性原则，它们会让组件变得更大，而 CRP 原则是排除性原则，它会让组件变小。软件架构师的任务就是要在这三个原则中进行取舍。一般来说，先期主要牺牲的是复用性，随着项目成熟，要达到平衡状态。

组件的互相依赖形成的依赖图中，不应该出现环，可通过依赖反转原则来打破。

组件的依赖关系必须要指向更稳定的方向。依赖越多越不稳定，越少越稳定。被依赖越多越稳定，越少越不稳定。以此，高层组件策略应该被放到稳定组件中，而不稳定组件中应该只包含哪些我们想要快速和方便修改的部分。

#### 保持独立性

一个设计良好的架构在行为上对系统对重要的作用就是明确和显示地反映系统设计意图的行为，非常直观地支持可能会涉及的所有用例，使其在架构层面上清晰可见。

但我们无法预知系统的所有用例，而且我们也无法提前预知系统的运行条件、开发团队的结构，或者系统的部署需求。就算我们能提前了解这些需求，随着系统生命周期的演进，这些需求也会不可避免的地发生变化。所以我们应该通过保留可选项的方式，让系统在任何情况下都能方便地作出必要的变更。

#### 重复

作为软件开发者，我们总是讨厌重复的内容，但是重复也存在着很多情况，其中有些是真正的重复，有些只是表面性的，随着时间推移，表面性重复随着时间的演变，最终可能会完全不同。正是这样的原因，我们必须加倍小心地避免让两个用例复用同一段代码。

*对业务逻辑的复用，会随着业务逻辑的改变而变得不可复用，这些只是表面性复用。真正的重复应该是辅助函数这种。*

#### 解耦模式

* 源码层次：我们可以控制源代码之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要重新变更。人们经常把这种模式叫单体结构。
* 部署层次：我们可以控制部署单元之间的依赖关系，以此实现一个模块的变更不会影响到其他模块的部署。在这中模式下，大部分组件还是存在同一个地址空间内，通过彼此的函数调用通信。比如 DLL 文件。
* 服务层次：我们可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。例如 SOA 或微服务。

服务层次的解耦不仅系统资源成本高昂，而且研发成本更高。通常我会更倾向于将系统的解耦推行到某种一旦有需要就可以随时转变为服务的程度即可，让整个程序尽量长时间地保持单体结构，以便给未来留下可选项。



## 整洁架构

![clean-architecture](https://tva1.sinaimg.cn/large/00831rSTly1gckddk2lbvj30lg0frwh4.jpg)

图中的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外圆代表的是机制，内圆代表的是策略。这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。

#### Entities 业务实体层

业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。

#### Use Case 用例层

*用例，也可以叫做使用案例，是软件系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。*

软件的用例层通常包含的是特定场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。

#### Controllers、Gateways、Presenters 接口适配器层

软件的接口适配器层通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便的操作格式，转化成外部系统（譬如数据库和 Web）最方便的操作的格式。

总之，在从该层再往内的同心圆中，其代码就不应该依赖任何数据库了。

#### DB、External Interfaces、UI...... 框架与驱动程序

最外层的模型层一般是由工具、数据库、Web 框架等组成的。这一层包含了所有的实现细节，我们将这些细节放在最外层，这样它们就很难影响到其他层了。

#### 只有这四层吗？

这个图是示意性的。你可能会发现你需要的不仅仅是这四个，也没有规定说你必须始终只有这四个。但是，依赖关系原则始终适用，源代码的依赖关系总是由外向内。外层是低层次的具体细节，内层是高层策略逻辑。

#### 跨边界流程

当发生如图右下角这样跨越边界的流程时，可通过依赖反转原则解决内向外的依赖关系。